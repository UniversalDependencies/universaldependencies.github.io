<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Dependencies</title>
    <link rel="root" href=""/> <!-- for JS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="../../css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style-vis.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/hint.css"/>
    <script type="text/javascript" src="../../lib/ext/head.load.min.js"></script>
    <script type="text/javascript" src="../../lib/ext/jquery.timeago.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.2.2/anchor.min.js"></script>
    <script>document.addEventListener("DOMContentLoaded", function(event) {anchors.add();});</script>
    <!-- Set up this custom Google search at https://cse.google.com/cse/business/settings?cx=001145188882102106025:dl1mehhcgbo -->
    <script>
      (function() {
        var cx = '001145188882102106025:dl1mehhcgbo';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->


  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
        <table width="100%"><tr><td width="50%">
          <span class="header-text"><a href="http://universaldependencies.org/#language-ru">home</a></span>


          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
        </td><td>
          <gcse:search></gcse:search>
        </td></tr></table>
      </div>

      <hr/>

      
      <div class="v1warning">
	This page still pertains to UD version 1.
      </div>
      
      
      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          <h1 id="dependencies">Dependencies</h1>

<table class="typeindex" border="1">
  <tr style="background-color:cornflowerblue">
      <td>	
	<table class="category">
	  <tr><td><strong></strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Nominals</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Clauses</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Modifier words</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Function Words</strong></td></tr>
	</table>
      </td>
  </tr>
  <tr>
      <td style="background-color:darkseagreen">
	<table class="category">
	  <tr><td><strong>Core arguments</strong></td></tr>
	</table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>nsubj</a></td>
	  </tr>
	  <tr>
	    <td><a>nsubj:pass</a></td>
	  </tr>
	  <tr>
	    <td><a>obj</a></td>
	  </tr>
	  <tr>
	    <td><a>iobj</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>csubj</a></td>
	  </tr>
	  <tr>
	    <td><a>csubj:pass</a></td>
	  </tr>
	  <tr>
	    <td><a>ccomp</a></td>
	  </tr>
	  <tr>
	    <td><a>xcomp</a></td>
	  </tr>
        </table>
      </td>
	  <td></td><td></td>
  </tr>
  <tr>
      <td style="background-color:darkseagreen">
	<table class="category">
	  <tr><td><strong>Non-core dependents</strong></td></tr>
	</table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>obl</a></td>
	  </tr>
	  <tr>
	    <td><a>obl:agent</a></td>
	  </tr>
	  <tr>
	    <td><a>vocative</a></td>
	  </tr>
	  <tr>
	    <td><a>expl</a></td>
	  </tr>
	  <tr>
	    <td><a>dislocated</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>advcl</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>advmod</a></td>
	  </tr>
	  <tr>
	    <td><a>discourse</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>aux</a></td>
	  </tr>
	  <tr>
	    <td><a>aux:pass</a></td>
	  </tr>
	  <tr>
	    <td><a>cop</a></td>
	  </tr>
	  <tr>
	    <td><a>mark</a></td>
	  </tr>
        </table>
      </td>
  </tr>
  <tr>
      <td style="background-color:darkseagreen">
	<table class="category">
	  <tr><td><strong>Nominal dependents</strong></td></tr>
	</table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>nmod</a></td>
	  </tr>
	  <tr>
	    <td><a>appos</a></td>
	  </tr>
	  <tr>
	    <td><a>nummod</a></td>
	  </tr>
	  <tr>
	    <td><a>nummod:gov</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>acl</a></td>
	  </tr>
	  <tr>
	    <td><a>acl:relcl</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>amod</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>det</a></td>
	  </tr>
	  <tr>
	    <td><a>case</a></td>
	  </tr>
        </table>
      </td>
  </tr>
  <tr style="background-color:cornflowerblue">	
      <td>	
	<table class="category">
	  <tr><td><strong>Coordination</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>MWE</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Loose</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Special</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Other</strong></td></tr>
	</table>
      </td>
  </tr>
  <tr>
      <td>
        <table class="category">
	  <tr>
	    <td><a>conj</a></td>
	  </tr>
	  <tr>
	    <td><a>cc</a></td>
	  </tr>
        </table>
      </td>
      <td>
        <table class="category">
	<tr>
	  <td><a>fixed</a></td>
	</tr>
	<tr>
	  <td><a>flat</a></td>
	</tr>
	<tr>
	  <td><a>compound</a></td>
	</tr>
      </table>
    </td>
    <td>
      <table class="category">
	<tr>
	  <td><a>list</a></td>
	</tr>
	<tr>
	  <td><a>parataxis</a></td>
	</tr>
      </table>
    </td>
    <td>
      <table class="category">
	<tr>
	  <td><a>orphan</a></td>
	</tr>
	<tr>
	  <td><a>goeswith</a></td>
	</tr>
	<tr>
	  <td><a>reparandum</a></td>
	</tr>
      </table>
    </td>
    <td>
      <table class="category">
	<tr>
	  <td><a>punct</a></td>
	</tr>
	<tr>
	  <td><a>root</a></td>
	</tr>
	<tr>
	  <td><a>dep</a></td>
	</tr>
      </table>

    </td>
  </tr>
</table>

<hr />

<p><a id="al-ru-dep/acl" class="al-dest"></a></p>
<h2><code>acl</code>: clausal modifier of noun</h2>

<p><code>acl</code> stands for finite and non-finite clauses that modify a nominal.  The <code>acl</code> relation 
contrasts with the <a href="">advcl</a> relation, which is used for adverbial clauses
that modify a predicate. The head of the <code>acl</code> relation is the noun
that is modified, and the dependent is the head of the clause that
modifies the noun.</p>

<pre><code class="language-sdparse">мужчина , о котором я говорил \n man , about whom I have-talked
acl(мужчина, говорил)
acl(man, have-talked)
</code></pre>

<p>This relation is also used for optional depictives.
The adjective is taken to modify the nominal of which it provides a secondary predication.
See <a href="">u-dep/xcomp</a> for further discussion of resultatives and depictives.</p>

<pre><code class="language-sdparse">Алена вошла в комнату незамеченной . \n Alena entered to room unnoticed .
acl(Алена, незамеченной)
acl(Alena, unnoticed)
</code></pre>

<pre><code class="language-sdparse">Он нарисовал свою жену обнаженной . \n He painted his wife naked .
acl(жену, обнаженной)
acl(wife, naked)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/acl.md" target="#">edit acl</a></p>

<p><a id="al-ru-dep/acl:relcl" class="al-dest"></a></p>
<h2><code>acl:relcl</code>: relative clause modifier</h2>

<p>The <code>acl:relcl</code> relation is used for relative clauses modifying
a nominal. The relation points from the head of the nominal to the
head of the relative clause.</p>

<pre><code class="language-sdparse">Я увидела мужчину , который любит тебя \n I saw the man who loves you
acl:relcl(мужчину, любит)
acl:relcl(man, loves)
nsubj(любит, который)
nsubj(loves, who)
obj(любит, тебя)
obj(loves, you)
</code></pre>

<pre><code class="language-sdparse">Я увидел мужчину , которого ты любишь  \n I saw the man who you love
acl:relcl(мужчину, любишь)
acl:relcl(man, love)
nsubj(любишь, ты)
nsubj(love, you)
obj(любишь, которого)
obj(love, who)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/acl-relcl.md" target="#">edit acl:relcl</a></p>

<p><a id="al-ru-dep/advcl" class="al-dest"></a></p>
<h2><code>advcl</code>: adverbial clause modifier</h2>

<p>An adverbial clause modifier is a clause which modifies a verb or other predicate (adjective, etc.),
as a modifier not as a core complement. This includes things such as a temporal clause, consequence, conditional clause, purpose
clause, etc. The dependent must be clausal (or else it is an <a href="">advmod</a>) and the dependent is the main predicate of the clause.</p>

<pre><code class="language-sdparse">Если вы знаете , кто это сделал , вы должны сказать учителю . \n If you know , who this did , you have to-tell the-teacher .
advcl(должны, знаете)
advcl(have, know)
</code></pre>

<pre><code class="language-sdparse">Он спешил , чтобы прийти вовремя . \n He rushed , in-order-to come in-time .
advcl(спешил, прийти)
advcl(rushed, come)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/advcl.md" target="#">edit advcl</a></p>

<p><a id="al-ru-dep/advmod" class="al-dest"></a></p>
<h2><code>advmod</code>: adverbial modifier</h2>

<p>An adverbial modifier of a word is a (non-clausal) <a href="ru-pos/ADV">adverb</a>
or adverbial phrase that serves to modify the meaning of the word.</p>

<p>We differentiate adverbials realized as adverbs (<code>advmod</code>) and
adverbials realized by noun phrases or adpositional phrases
(<a href="">nmod</a>).</p>

<pre><code class="language-sdparse">генетически модифицированная еда \n genetically modified food
advmod(модифицированная, генетически)
advmod(modified, genetically)
</code></pre>

<pre><code class="language-sdparse">менее часто \n less often
advmod(часто, менее)
advmod(often, less)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/advmod.md" target="#">edit advmod</a></p>

<p><a id="al-ru-dep/amod" class="al-dest"></a></p>
<h2><code>amod</code>: adjectival modifier</h2>

<p>An adjectival modifier of an NP is any adjectival phrase that serves to modify the meaning of the NP.</p>

<pre><code class="language-sdparse">Василий ест куриную лапшу . \n Vasily eats chicken noodles .
amod(лапшу, куриную)
amod(noodles, chicken)
</code></pre>

<pre><code class="language-sdparse">Первое впечатление было хорошим . \n First impression was positive .
amod(впечатление, Первое)
amod(impression, First)
nsubj(хорошим, впечатление)
nsubj(positive, impression)
</code></pre>
<p>Some pronominal modifiers are also considered as <code>amod</code>
Exception: if the modifying adjectival word is article-equivalent (i.e. tagged <a href="">ru-pos/DET</a>), the relation is <a href="">det</a> instead of <code>amod</code>.</p>

<pre><code class="language-sdparse">эти ваши новые группы \n these your new groups
amod(группы, новые)
amod(groups, new)
amod(группы, ваши)
amod(groups, your)
det(группы, эти)
det(groups, these)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/amod.md" target="#">edit amod</a></p>

<p><a id="al-ru-dep/appos" class="al-dest"></a></p>
<h2><code>appos</code>: appositional modifier</h2>

<p>An appositional modifier of a noun is a nominal immediately following the first noun that serves to define or modify that noun. It includes parenthesized examples, as well as defining abbreviations in one of these structures.</p>

<pre><code class="language-sdparse">Карл Четвертый , римский император и чешский король , царствовал в XIV веке . \n Charles IV , Roman Emperor and Czech king , ruled in 14th century .
appos(Карл, император)
appos(Charles, Emperor)
conj(император, король)
conj(Emperor, king)
</code></pre>

<pre><code class="language-sdparse">Польская Социалистическая Партия ( ПСП ) \n Polish Socialist Party ( PSP )
appos(Партия, ПСП)
appos(Party, PSP)
</code></pre>

<p>There is a slight deviation from the <a href="u-dep/appos">universal</a> standard in case of more than one appositive nominal.
Instead of attaching them all to the first noun, all the appositive modifiers are put together in coordination,
then attached as <code>appos</code> to the modified noun.
This is done regardless whether the appositives are joined by a coordinating conjunction or just a comma.</p>

<pre><code class="language-sdparse">Пришел Михаил , мой брат и кузен Давида . \n Came Mikhail , my brother and cousin of-David .
appos(Михаил, брат)
appos(Mikhail, brother)
conj(брат, кузен)
conj(brother, cousin)
</code></pre>

<pre><code class="language-sdparse">Михаил , мой брат , кузен Давида , придет завтра . \n Mikhail , my brother , cousin of-David , will-come tomorrow .
appos(Михаил, брат)
appos(Mikhail, brother)
conj(брат, кузен)
conj(brother, cousin)
</code></pre>

<p><code>appos</code> is also used to link key-value pairs in addresses, signatures, etc. (see also the <a href="">list</a> label):</p>

<pre><code class="language-sdparse">Иван Петров , тел . : 8(495)-000-11-22 , e-mail : petrov@mail.ru
name(Иван, Петров)
list(Иван, тел)
list(Иван, e-mail)
appos(тел, 8(495)-000-11-22-7)
appos(e-mail, petrov@mail.ru)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/appos.md" target="#">edit appos</a></p>

<p><a id="al-ru-dep/aux" class="al-dest"></a></p>
<h2><code>aux</code>: auxiliary</h2>

<p>An auxiliary of a clause is a form of the <a href="ru-pos/AUX">auxiliary verb</a> <em>быть</em> “to be”
used to construct the periphrastic future tense or conditional.</p>

<p>Exception: Auxiliary verb used to construct the passive
<a href="ru-feat/Voice">voice</a> is not labeled <code>aux</code> but <a href="">auxpass</a>.</p>

<p>Note that besides <code>aux</code> and <code>auxpass</code>, the verb <em>быть</em> may also act as a <a href="cop">copula</a>
and as the main verb.</p>

<pre><code class="language-sdparse">Завтра я буду выступать в университете . \n Tomorrow I will give-a-talk at the-university .
aux(выступать, буду)
aux(give-a-talk, will)
</code></pre>

<pre><code class="language-sdparse">Если бы я пришел раньше , я бы не пропустил поезд . \n If had I come earlier , I would not have-missed the-train .
aux(пришел, бы-2)
aux(come, had)
aux(пропустил, бы-8)
aux(have-missed, would)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/aux_.md" target="#">edit aux</a></p>

<p><a id="al-ru-dep/aux:pass" class="al-dest"></a></p>
<h2><code>aux:pass</code>: passive auxiliary</h2>

<p>A passive auxiliary of a clause is a form of the <a href="cs-pos/AUX">auxiliary verb</a> <em>быть</em> “to be” used to construct the periphrastic passive voice (in the past or future tense, in the infinitive, imperative or conditional mood).</p>

<pre><code class="language-sdparse">Кеннеди был убит . \n Kennedy was killed .
aux:pass(убит, был)
aux:pass(killed, was)
</code></pre>

<pre><code class="language-sdparse">Кеннеди будет убит . \n Kennedy will-be killed .
aux:pass(убит, будет)
aux:pass(killed, will-be)
</code></pre>

<pre><code class="language-sdparse">Кеннеди не знал , что ему суждено быть убитым . \n Kennedy did-not-anticipate that his fate is to-be killed .
aux:pass(убитым, быть)
aux:pass(killed, to-be)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/aux-pass.md" target="#">edit aux:pass</a></p>

<p><a id="al-ru-dep/case" class="al-dest"></a></p>
<h2><code>case</code>: case marking</h2>

<p>Russian uses a combination of oblique morphological cases and prepositions to express semantic case.
Prepositions in UD are treated as dependents of the noun they attach to. The relation between the noun and the preposition is labeled <code>case</code>.</p>

<pre><code class="language-sdparse">В пятницу.Acc по дороге.Dat к деревне.Dat мы разговаривали o событии.Loc . \n On Friday during the-journey to the-village we talked about the-event .
case(пятницу.Acc, В)
case(Friday, On)
case(дороге.Dat, по)
case(the-journey, during)
case(деревне.Dat, к)
case(the-village, to)
case(событии.Loc, o)
case(the-event, about)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/case.md" target="#">edit case</a></p>

<p><a id="al-ru-dep/cc" class="al-dest"></a></p>
<h2><code>cc</code>: coordinating conjunction</h2>

<p>For more on coordination, see the <a href="">conj</a> relation.
A <code>cc</code> is the relation between the first conjunct and
the <a href="ru-pos/CONJ">coordinating conjunction</a> delimiting another conjunct.
(Note: different dependency grammars have different treatments of coordination.
We take the first conjunct as the head of the coordination.)</p>

<pre><code class="language-sdparse">Он старый и мудрый мужчина. \n He-is old and wise man .
cc(старый, и)
cc(old, and)
</code></pre>

<p>A coordinating conjunction may also appear at the beginning of a
sentence. This is also called a <code>cc</code>, and it depends on the root
predicate of the sentence.
(In fact there is a coordination that spans multiple sentences.
We cannot attach a word to the first conjunct because it is in another sentence.
Thus we attach it to the first conjunct available in the current sentence: its main predicate.)</p>

<pre><code class="language-sdparse">И потом мы ушли . \n And then we left .
cc(ушли, И)
cc(left, And)
</code></pre>

<pre><code class="language-sdparse">У нас есть яблоки , груши , апельсины и бананы . \n By us are apples , pears , oranges and bananas .
nsubj(есть, яблоки)
nsubj(are, apples)
conj(яблоки, груши)
conj(яблоки, апельсины)
conj(яблоки, бананы)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(яблоки, и)
cc(apples, and)
punct(яблоки, ,-5)
punct(яблоки, ,-7)
punct(apples, ,-17)
punct(apples, ,-19)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/cc.md" target="#">edit cc</a></p>

<p><a id="al-ru-dep/cc:preconj" class="al-dest"></a></p>
<h2><code>cc:preconj</code>: cc:preconj</h2>

<p>NOTE: This relation is not in use in UD 2.0+. The universal relation <em>cc</em> is used instead since all cc’s are now attached to the next conjunct to the right.</p>

<p>A preconjunct is the relation between the head of an NP and a word
that appears at the beginning bracketing a conjunction (and puts
emphasis on it), such as <em>either</em>, <em>both</em>, <em>neither</em>, <em>and</em>, <em>but</em>).</p>

<pre><code class="language-sdparse">Но никто не знал ответ . \n But no-one knew the answer .
cc:preconj(никто, Но)
cc:preconj(no-one, But)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/cc-preconj.md" target="#">edit cc:preconj</a></p>

<p><a id="al-ru-dep/ccomp" class="al-dest"></a></p>
<h2><code>ccomp</code>: clausal complement</h2>

<p>A clausal complement of a verb or adjective is a dependent clause 
which is a core argument. That is, it functions like an object of the verb, or
adjective.</p>

<pre><code class="language-sdparse">Он говорит , что она работает в музее . \n He says , that she works in a museum .
ccomp(говорит, работает)
ccomp(says, works)
</code></pre>

<p>Such clausal complements may be finite or nonfinite. However, if the
subject of the clausal complement is controlled (that is, must be the same
as the higher subject or object, with no other possible interpretation)
the appropriate relation is <a href="">xcomp</a>.</p>

<pre><code class="language-sdparse">Генерал приказал нам выйти . \n General ordered us to-leave .
ccomp(приказал, выйти)
ccomp(ordered, to-leave)
</code></pre>

<pre><code class="language-sdparse">Мы начали писать тест . \n We started to-write test .
xcomp(начали, писать)
xcomp(started, to-write)
</code></pre>

<p>The key difference here is that, while it is possible to interpret the first
sentence to mean that the general will not be leaving, in the second
sentence it is clear that the subject of <strong>writing</strong> can only be <strong>we</strong>. This is
what distinguishes <code>ccomp</code> and <code>xcomp</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/ccomp.md" target="#">edit ccomp</a></p>

<p><a id="al-ru-dep/compound" class="al-dest"></a></p>
<h2><code>compound</code>: compound</h2>

<p><code>compound</code> is one of the relations in UD for compounding.
The rightmost numeral is the head, the other numerals are attached as its modifiers.</p>

<pre><code class="language-sdparse">Это будет стоить максимум 5 тысяч рублей . \n It will cost at-most 5 thousand rubles .
nummod:gov(рублей, тысяч)
nummod:gov(rubles, thousand)
compound(тысяч, 5-5)
compound(thousand, 5-14)
</code></pre>

<pre><code class="language-sdparse">Это будет стоить пятьдесят пять тысяч рублей . \n It will cost fifty five thousand rubles .
nummod:gov(рублей, тысяч)
nummod:gov(rubles, thousand)
compound(тысяч, пятьдесят)
compound(thousand, fifty)
compound(тысяч, пять)
compound(thousand, five)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/compound.md" target="#">edit compound</a></p>

<p><a id="al-ru-dep/conj" class="al-dest"></a></p>
<h2><code>conj</code>: conjunct</h2>

<p>A conjunct is the relation between two elements connected by a
coordinating conjunction, such as <em>and, or,</em> or a comma or other punctuation.
We treat coordination asymmetrically in what is known as the Stanford style:
The head of the relation is the first
conjunct and all the other conjuncts depend on it via the <code>conj</code> relation.</p>

<pre><code class="language-sdparse">Он старый и мудрый мужчина . \n He-is old and wise man .
conj(старый, мудрый)
conj(old, wise)
</code></pre>

<pre><code class="language-sdparse">У нас есть яблоки , груши , апельсины и бананы . \n By us are apples , pears , oranges and bananas .
nsubj(есть, яблоки)
nsubj(are, apples)
conj(яблоки, груши)
conj(яблоки, апельсины)
conj(яблоки, бананы)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(яблоки, и)
cc(apples, and)
punct(яблоки, ,-5)
punct(яблоки, ,-7)
punct(apples, ,-17)
punct(apples, ,-19)
</code></pre>

<p>Coordinate clauses are treated the same way as coordination of other constituent types:</p>

<pre><code class="language-sdparse">Он пришел домой , помылся и пошел в кровать . \n He came home , showered-himself and went to bed .
conj(пришел, помылся)
conj(пришел, пошел)
conj(came, showered-himself)
conj(came, went)
punct(пришел, ,-4)
punct(came, ,-15)
cc(пришел, и)
cc(came, and)
</code></pre>

<p>See <a href="u-dep/conj">universal/conj</a> for more details on various coordination-related issues.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/conj.md" target="#">edit conj</a></p>

<p><a id="al-ru-dep/cop" class="al-dest"></a></p>
<h2><code>cop</code>: copula</h2>

<p>A copula is the relation between the nominal predicate and
the copular verb <em><b>быть</b></em> “to be” (or its variants <em>бывал, был</em>).
The verb <em>становиться</em> “to become”, despite being counted among copular verbs by some authors,
is not analyzed as <code>cop</code>.</p>

<p>We normally take a copula as a dependent of its complement (the nominal predicate).
The nominal predicate is usually a <a href="cs-pos/NOUN">noun</a>, an <a href="cs-pos/ADJ">adjective</a>
or a <a href="../feat/VerbForm.html#part-participle">participle</a>.</p>

<pre><code class="language-sdparse">Андрей был честным человеком . \n Andrew was an honest man .
cop(человеком, был)
cop(man, was)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/cop.md" target="#">edit cop</a></p>

<p><a id="al-ru-dep/csubj" class="al-dest"></a></p>
<h2><code>csubj</code>: clausal subject</h2>

<p>A clausal subject is a clausal syntactic subject of a clause, i.e.,
the subject is itself a clause. The governor of this relation might
not always be a verb: when the verb is a copular verb, the root of the
clause is the complement of the copular verb. The dependent is the main lexical verb or other 
predicate of the subject clause.</p>

<pre><code class="language-sdparse">Забыть Ваню трудно . \n To-forget Vanya , it-is-hard .
csubj(трудно, Забыть)
csubj(it-is-hard, To-forget)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/csubj.md" target="#">edit csubj</a></p>

<p><a id="al-ru-dep/csubj:pass" class="al-dest"></a></p>
<h2><code>csubj:pass</code>: clausal passive subject</h2>

<p>A clausal passive subject is a clausal syntactic subject of a passive clause.</p>

<pre><code class="language-sdparse">Мне было сказано , чтобы я все хорошо взвесил . \n To-me it-has-been told , that I it-all very-well weighed-up .
csubj:pass(сказано, взвесил)
csubj:pass(told, weighed-up)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/csubj-pass.md" target="#">edit csubj:pass</a></p>

<p><a id="al-ru-dep/dep" class="al-dest"></a></p>
<h2><code>dep</code>: unspecified dependency</h2>

<p>A dependency is labeled as <code>dep</code> when a system is unable to
determine a more precise dependency relation between two words.  This
may be because of a weird grammatical construction, a limitation in
software, a parser error, or
because of an unresolved long distance dependency.</p>

<pre><code class="language-sdparse">А к чему – было не понятно . \n And for what – it-was not clear .
dep(понятно, чему)
dep(clear, what)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/dep.md" target="#">edit dep</a></p>

<p><a id="al-ru-dep/det" class="al-dest"></a></p>
<h2><code>det</code>: determiner</h2>

<p>The relation determiner (<code>det</code>) holds between a nominal head and its <a href="ru-pos/DET">determiner</a>.
This relation is used for pronominal adjectival modifiers of noun phrases.
Non-pronominal adjectives are tagged <a href="">ru-pos/ADJ</a> and the relation is labeled <a href="">amod</a>.</p>

<pre><code class="language-sdparse">Тот человек уже здесь . \n The man already is-here .
det(человек, Тот)
det(man, The)
</code></pre>

<pre><code class="language-sdparse">Он такой человек . \n He is this-kind-of man .
det(человек, такой)
det(man, this-kind-of)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/det.md" target="#">edit det</a></p>

<p><a id="al-ru-dep/discourse" class="al-dest"></a></p>
<h2><code>discourse</code>: discourse element</h2>

<p>At present we use the <code>discourse</code> relation for redundant or emotional items, redundant coreferential pronoun.</p>

<pre><code class="language-sdparse">Ты же обещал ! \n You still promised !
discourse(обещал, же)
</code></pre>
<p>(meaning “… but you promised”)</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/discourse.md" target="#">edit discourse</a></p>

<p><a id="al-ru-dep/dislocated" class="al-dest"></a></p>
<h2><code>dislocated</code>: dislocated elements</h2>

<p>NOTE: The relation <em>dislocated</em> is not in use in Russian UD 2.0+</p>

<p>The <code>dislocated</code> relation is used for fronted or postposed elements
that do not fulfill the usual core grammatical relations of a
sentence. Dislocated elements are attached to the same governor as the dependent that they double for.</p>

<pre><code class="language-sdparse">Это наша комната, моя и Дашина
dislocated(комната, моя)
cc(моя, и)
conj(моя, Дашина)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/dislocated.md" target="#">edit dislocated</a></p>

<p><a id="al-ru-dep/expl" class="al-dest"></a></p>
<h2><code>expl</code>: expletive: reflexive pronoun with an inherently reflexive verb</h2>

<p>The demonstrative particle <em>eto</em> can be used as an “extra” subject in the sentence, in this case all other sentence can be considered as the group of predicate. Cf. English construction with <em>there</em>-expletive.</p>

<pre><code class="language-sdparse">Это мама звонит . \n This-is my-mother calls .
expl(звонит, Это)
expl(calls, This-is)
nsubj(звонит, мама)
nsubj(calls, my-mother)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/expl.md" target="#">edit expl</a></p>

<p><a id="al-ru-dep/fixed" class="al-dest"></a></p>
<h2><code>fixed</code>: fixed multiword expression</h2>

<p>The fixed relation is one of the three relations (compound, fixed, flat) for special kinds of multiword expressions. It is used for fixed grammaticized expressions that behave like function words or short adverbials. The first word is always taken as the head, with all subsequent words as direct dependents.In Russian it is used for multi-word prepositions.</p>

<pre><code class="language-sdparse">В отличие от тебя , мне нечего стыдиться . \n In contrast to you , I-have nothing to-be-ashamed .
fixed(В, отличие)
fixed(В, от)
case(тебя, В)
fixed(In, contrast)
fixed(In, to)
case(you, In)
</code></pre>

<p>Multi-word prepositions usually form a contiguous span of the sentence. In exceptional cases however, they can be interrupted
by emphasizers and other words:</p>

<pre><code class="language-sdparse">в сравнении , например , с долгом \n in comparison , for-example , to loans
fixed(в, сравнении)
fixed(в, с)
case(долгом, в)
advmod:emph(долгом, например)
fixed(in, comparison)
fixed(in, to)
case(loans, in)
advmod:emph(loans, for-example)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/fixed.md" target="#">edit fixed</a></p>

<p><a id="al-ru-dep/flat" class="al-dest"></a></p>
<h2><code>flat</code>: flat</h2>

<p><code>flat</code> is one of the relations for compounding in UD.
In Russian it is used to join the first name of a person with the patronymic and the last name.</p>

<p>The leftmost name is always the head and the other name(s) are attached to it.</p>

<p>The relation is not used to attach adjectives to nouns within multi-word names of places, organizations etc.</p>

<pre><code class="language-sdparse">Президент Владимир Владимирович Путин вчера посетил Минеральные Воды . \n President Vladimir Vladimirovich Putin yesterday visited Mineralnye Vody .
flat(Владимир, Владимирович)
flat(Vladimir, Vladimirovich)
flat(Владимир, Путин)
flat(Vladimir, Putin)
nmod(Владимир, Президент)
nmod(Vladimir, President)
amod(Воды, Минеральные)
amod(Vody, Mineralnye)
</code></pre>

<pre><code class="language-sdparse">Нью - Йорк \n New York
flat(Нью, Йорк)
flat(New, York)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/flat.md" target="#">edit flat</a></p>

<p><a id="al-ru-dep/goeswith" class="al-dest"></a></p>
<h2><code>goeswith</code>: goes with</h2>

<p>This relation links two parts of a word that are separated in text
that is not well edited.
The head is in some sense the “main” part, often the second part.</p>

<pre><code class="language-sdparse">Он остановился чтобы о тдышаться .
goeswith(тдышаться, о)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/goeswith.md" target="#">edit goeswith</a></p>

<p><a id="al-ru-dep/iobj" class="al-dest"></a></p>
<h2><code>iobj</code>: indirect object</h2>

<p>The indirect object of a verb is any nominal phrase that is a core
argument of the verb but is not its subject or <a href="obj">direct object</a>.
The prototypical example is the recipient of ditransitive verbs of
exchange:</p>

<pre><code class="language-sdparse">Павел дал Петру две груши . \n Pavel gave Peter two pears .
iobj(дал, Петру)
iobj(gave, Peter)
</code></pre>

<p>However, Russian allows other semantic roles as additional objects.
The morphological <a href="">ru-feat/Case</a> of the objects is dictated by verb valency.</p>

<p>In the following Russian example, the verb takes two arguments. One of them is direct object (patient), the other is indirect (addressee). It is parallel to how the English translation would be annotated (where there is no morphological case marking) and also to verbs of giving (cf. a similar sentence, <em>he gave my daughter a class of maths</em>).</p>

<pre><code class="language-sdparse">Он преподает моей дочери математику . \n He teaches my daughter.Dat maths.Acc .
obj(преподает, математику)
iobj(преподает, дочери)
obj(teaches, maths.Acc)
iobj(teaches, daughter.Dat)
</code></pre>

<p>In general, if there is just one object, it should be labeled
<a href="">obj</a>, regardless of the morphological case or semantic role.
For example, <em>преподавать</em> “to teach” can take either the subject matter or the recipient as the only object,
and in both cases it would be analyzed as the <a href="">obj</a>:</p>

<pre><code class="language-sdparse">Он преподает математику . \n He teaches maths .
obj(преподает, математику)
obj(teaches, maths)
</code></pre>

<pre><code class="language-sdparse">Он преподает студентам . \n He teaches students .
obj(преподает, студентам)
obj(teaches, students)
</code></pre>

<p>The one exception is when there is a clausal complement.
Then the clausal complement is regarded as a “clausal direct object” and an object nominal will be an iobj, parallel to
the simple ditransitive case:</p>

<pre><code class="language-sdparse">Она сказала студентам , что сегодня вечером нужно учиться . \n She told students , that today evening they-needed to-study .
iobj(сказала, студентам)
ccomp(сказала, нужно)
iobj(told, students)
ccomp(told, they-needed)
</code></pre>

<pre><code class="language-sdparse">Она рассказала студентам свой план . \n She told students her plan .
iobj(рассказала, студентам)
obj(рассказала, план)
iobj(told, students)
obj(told, plan)
</code></pre>

<p>If there are two or more objects, one of them should be <a href="">obj</a> and the others should be <code>iobj</code>. In such cases it is necessary to decide what is the most directly affected object <em>(patient)</em>, and the Accusative <a href="">ru-feat/Case</a> has priority over the Dative, Instrumental, and Genitive cases.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/iobj.md" target="#">edit iobj</a></p>

<p><a id="al-ru-dep/list" class="al-dest"></a></p>
<h2><code>list</code>: list</h2>

<p>The <code>list</code> relation is used for chains of comparable items.
In lists with more than two items, all items of the list should modify the first one.
Informal and web text often contains passages which are meant to be interpreted as lists but are parsed as single sentences.
Email signatures often contain these structures, in the form of contact information:
the different contact information items are labeled as <code>list</code>; the key-value pair relations are labeled as <a href="">appos</a>.</p>

<p>However, <code>list</code> should not be over-used. If a construction can be easily analyzed
using the grammatical relations of standard sentences, such as when there is overt coordination,
then it should be analyzed with these more standard relations, even if it is laid out as a list typographically.</p>

<pre><code class="language-sdparse">Стив Джонс тел.: 555-9814 e-mail: jones@mail.ru
name(Стив-1, Джонс-2)
list(Стив-1, тел.:-3)
list(Стив-1, e-mail:-5)
appos(тел.:-3, 555-9814-4)
appos(e-mail:-5, jones@mail.ru-6)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/list.md" target="#">edit list</a></p>

<p><a id="al-ru-dep/mark" class="al-dest"></a></p>
<h2><code>mark</code>: marker</h2>

<p>A marker is the subordinating conjunction introducing a finite clause subordinate to another clause.
The mark is a dependent of the subordinate clause head.</p>

<pre><code class="language-sdparse">Я не знал , что ты говоришь по-немецки . \n I didn't know , that you speak German .
mark(говоришь, что)
mark(speak, that)
</code></pre>

<pre><code class="language-sdparse">Мы отправим товар , как только на наш счет поступят деньги . \n We will-dispatch goods , as soon-as at our account arrive money .
mark(поступят, как)
fixed(как, только)
mark(arrive, as)
fixed(as, soon-as)
</code></pre>

<p>Note that the subordinating conjunction should not be confused with relative pronouns and adverbs.
These fill a valency slot in the frame of the subordinate predicate,
and are labeled according to their role in the frame, they are not <code>mark</code>:</p>

<pre><code class="language-sdparse">Я бы хотел узнать , когда нам поступят деньги на счет . \n I would like to-know , when us arrive money at account .
advmod(поступят, когда)
advmod(arrive, when)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/mark.md" target="#">edit mark</a></p>

<p><a id="al-ru-dep/neg" class="al-dest"></a></p>
<h2><code>neg</code>: negation modifier</h2>

<p>The negation modifier is the relation between the negation word <em>не</em> and the
word it modifies.</p>

<p>Negation in Russian is most of the time expressed using a bound morpheme (the prefix <em>не-</em>).
Occurrences of the morpheme as a separate word are rare in comparison to other languages,
yet they exist.</p>

<pre><code class="language-sdparse">Она не ест рыбу . \n She not eats fish .
neg(ест, не)
neg(eats, not)
</code></pre>

<pre><code class="language-sdparse">Ему был нужен четвероногий , а не двуногий друг . \n To-him was needed quadrupedal , and not bipedal friend .
neg(двуногий, не)
neg(bipedal, not)
</code></pre>

<p>Note that the negative determiners (pronouns) are attached as <a href="">det</a>, not <code>neg</code>:</p>

<pre><code class="language-sdparse">Премьер не был никаким дураком . \n The-Prime-Minister not was no fool .
det(дураком, никаким)
det(fool, no)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/neg.md" target="#">edit neg</a></p>

<p><a id="al-ru-dep/nmod" class="al-dest"></a></p>
<h2><code>nmod</code>: nominal modifier</h2>

<p>The <code>nmod</code> relation is used for nominal modifiers. They depend 
on another noun (group “noun dependents”).</p>

<p><code>nmod</code> is a <a href="cs-pos/NOUN">noun</a> (or noun phrase) functioning as a
non-core (oblique) argument or adjunct.
This means that it functionally corresponds to an adverbial when it attaches to a verb, adjective or other adverb.
But when attaching to a noun, it usually corresponds to a non-agreeing attribute in genitive.</p>

<p>In Russian the <code>nmod</code> relation covers only those possessives that are expressed using the genitive.
If a possessive adjective is used, the relation is labeled <a href="">amod</a>.
If a possessive determiner (pronoun) is used, the relation is labeled <a href="">det</a>.</p>

<pre><code class="language-sdparse">карта студента \n card of-student
nmod(карта, студента)
nmod(card, of-student)
</code></pre>

<pre><code class="language-sdparse">студенческая карта \n student's card
amod(карта, студенческая)
amod(card, student's)
</code></pre>

<pre><code class="language-sdparse">его карта \n his card
amod(карта, его)
amod(card, his)
</code></pre>

<h2 id="agreeing-attribute-of-a-noun">Agreeing attribute of a noun</h2>

<p><code>nmod</code> noun phrases attached to nouns are usually in the genitive <a href="">ru-feat/Case</a> and follow the modified noun.
However, there is also a different kind of <code>nmod</code> that precedes the modified noun and agrees with it in case and number.
A typical example is a title attached to a name of a person. The relation is similar to the <a href="">flat</a> relation
that links the first and the last name, but it is not labeled <code>flat</code> because the title is not part of the name:</p>

<pre><code class="language-sdparse">российский президент Владимир Владимирович Путин \n Russian president Vladimir Vladimirovich Putin
amod(президент, российский)
amod(president, Russian)
nmod(Владимир, президент)
nmod(Vladimir, president)
name(Владимир, Путин)
name(Vladimir, Putin)
name(Владимир, Владимирович)
name(Vladimir, Vladimirovich)
</code></pre>

<p>Note that the same thing can be also expressed using an <a href="appos">apposition</a>.
In the case of apposition, the title follows the modified name and is separated by a punctuation symbol:</p>

<pre><code class="language-sdparse">Владимир Путин , российский президент \n Vladimir Putin , Russian president 
name(Владимир, Путин)
name(Vladimir, Putin)
punct(президент, ,-3)
punct(president, ,-9)
amod(президент, российский)
amod(president, Russian)
appos(Владимир, президент)
appos(Vladimir, president)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/nmod.md" target="#">edit nmod</a></p>

<p><a id="al-ru-dep/nsubj" class="al-dest"></a></p>
<h2><code>nsubj</code>: nominal subject</h2>

<p>A nominal subject is a NP which is the syntactic subject of a clause; in Russian, the phrase is in the Nominative <a href="">Case</a>.
(See <a href="">csubj</a> for when the subject is clausal. See <a href="">nsubjpass</a> and <a href="">csubjpass</a> for when the subject is not the proto-agent argument due to valence changing operations.)
The governor of the <code>nsubj</code> relation might not always be a verb: when the verb is a copular verb, the root of the clause is the complement of the copular verb, which can be an adjective or noun.</p>

<pre><code class="language-sdparse">Ленинградскую симфонию написал Шостакович . \n Leningrad Symphony wrote Shostakovich .
nsubj(написал, Шостакович)
nsubj(wrote, Shostakovich)
</code></pre>

<pre><code class="language-sdparse">Автомобиль красный . \n Car is-red .
nsubj(красный, Автомобиль)
nsubj(is-red, Car)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/nsubj.md" target="#">edit nsubj</a></p>

<p><a id="al-ru-dep/nsubj:pass" class="al-dest"></a></p>
<h2><code>nsubj:pass</code>: passive nominal subject</h2>

<p>A passive nominal subject is a noun phrase which is the syntactic
subject of a passive clause.</p>

<pre><code class="language-sdparse">Шварценберг был побеждён Земаном . \n Schwarzenberg was defeated by-Zeman .
nsubj:pass(побеждён, Шварценберг)
nsubj:pass(defeated, Schwarzenberg)
</code></pre>

<p>Reflexive passive (the meaning is “This will be solved tomorrow.”)</p>

<pre><code class="language-sdparse">Это решится завтра . \n This will-be-solved tomorrow .
nsubj:pass(решится, Это)
nsubj:pass(will-be-solved, This)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/nsubj-pass.md" target="#">edit nsubj:pass</a></p>

<p><a id="al-ru-dep/nummod" class="al-dest"></a></p>
<h2><code>nummod</code>: numeric modifier</h2>

<p>A numeric modifier of a noun is a <a href="ru-pos/NUM">numeral</a> or quantifier 
that serves to modify the meaning of the noun with a quantity.
The noun is always the head and the numeral (or quantifier) is always attached as its modifier.
Nevertheless, three different relation labels are used to mark situations where the numeral (or quantifier)
a) agrees in case with the noun: <strong>nummod</strong>;
b) governs the morphological case of the noun: <a href="nummod-gov.html"><strong>nummod:gov</strong></a>;
c) does not change the morphological form of the noun: <a href="nummod-entity.html"><strong>nummod:entity</strong></a>.</p>

<pre><code class="language-sdparse">Сидеть на двух стульях . \n To-sit on two chairs .
nummod(стульях, двух)
nummod(chairs, two)
</code></pre>

<pre><code class="language-sdparse">Два стула сломаны . \n Two chairs broke .
nummod:gov(стула, Два)
nummod:gov(chairs, Two)
</code></pre>

<pre><code class="language-sdparse">Дом два , подъезд четыре . \n Building two , entrance four .
nummod:entity(Дом, два)
nummod:entity(Building, two)
nummod:entity(подъезд, четыре)
nummod:entity(entrance, four)
</code></pre>

<h2 id="agreement-and-government-with-russian-quantifiers">Agreement and government with Russian quantifiers</h2>

<p>The morphological and syntactic behavior of Russian numerals is complicated, 
and depends on the type of numeral, it’s case, animacy, and sometimes some other factors.</p>

<p>The cardinal numeral <em>один</em> “one” agrees with the noun in case, number, and gender. 
It behaves in the same way as ordinal numerals and adjectives.</p>

<p>The paucal cardinal numerals <em>два</em> “two”, <em>три</em> “three”, <em>четыре</em> “four”, <em>оба</em> “both”, <em>пол</em> “half”, and <em>полтора</em> “one and a half” agree with the noun in grammatical case in most cases (nummod). In the Nominative and Accusative inanimate case, however, they govern the Genitive singular form of the noun (nummod:gov). The Accusative animate is similar to the Genitive (nummod).
<em>Два</em> “two”, <em>оба</em> “both”, and <em>полтора</em> “one and a half” also agree in gender with the noun in all grammatical cases.
Examples:</p>

<ul>
  <li><em><b>Один</b> мужчина спал, <b>два</b> мужчины играли в карты с <b>тремя</b> женщинами.</em> “One.Masc man.Masc slept, two.Masc men.Masc played cards with three women.”</li>
  <li><em><b>Одна</b> женщина спала, <b>две</b> женщины играли в карты с <b>тремя</b> мужчинами.</em> “One.Fem woman slept, two.Masc women.Masc played cards with three men.”</li>
  <li><em><b>Одно</b> чудовище спало, <b>два</b> чудовища играли в карты с <b>тремя</b> привидениями.</em> “One.Neut monster slept, two.Neut monsters played cards with three ghosts.”</li>
</ul>

<p>In the examples above, the dependencies of the numeral <em>один</em> “one” and the numeral <em>три</em> “three” (in the Instrumental case) are labeled as <code>nummod</code>:</p>

<pre><code class="language-sdparse">Одно чудовище спало , два чудовища играли в карты с тремя привидениями . \n One monster slept , two monsters played cards with three ghosts .
nummod(чудовище, Одно)
nummod(monster, One)
nummod(привидениями, тремя)
nummod(ghosts, three)
nummod:gov(чудовища, два)
nummod:gov(monsters, two)
</code></pre>

<p>The cardinal numerals of larger quantity (five and more, e.g. <em>пять</em> “five”, <em>шесть</em> “six”, <em>сто</em> “one hundred”) as well as quantifiers (e.g. <em>много</em> “how many, how much”, <em>сколько</em> “how many, how much”, <em>столько</em> “so many, so much”, <em>несколько</em> “a few”) agree with the noun in grammatical case in most cases exactly as other cardinal numerals (nummod). In the Nominative and Accusative inanimate case, however, they govern the Genitive plural form of the noun (nummod:gov). 
The following table shows the case of the whole phrase (numeral + noun; first column)
and the consequences for the case of the parts (note that these numerals have only
three distinct morphological forms, resulting in homonymy).</p>

<table>
<tr><th>Phrase Case</th><th>Example (paucal)</th><th>Example (larger quantity)</th><th>Numeral Case</th><th>Noun Case</th></tr>
<tr><td>Nom</td><td>две женщины</td><td>пять женщин</td><td>Nom</td><td>Gen</td></tr>
<tr><td>Gen</td><td>двух женщин</td><td>пяти женщин</td><td>Gen</td><td>Gen</td></tr>
<tr><td>Dat</td><td>двум женщинам</td><td>пяти женщинам</td><td>Dat</td><td>Dat</td></tr>
<tr><td>Acc</td><td>двух женщин/две вазы</td><td>пять женщин/пять ваз</td><td>Acc</td><td>Acc(anim)/Gen(inan)</td></tr>
<tr><td>Ins</td><td>двумя женщинами</td><td>пятью женщинами</td><td>Ins</td><td>Ins</td></tr>
<tr><td>Loc</td><td>двух женщинах</td><td>пяти женщинах</td><td>Loc</td><td>Loc</td></tr>
</table>

<p>We can say that the noun has the case of the whole phrase if it is in the Dative, Instrumental, or Locative case. 
The numeral then agrees with the noun in case.
The numeral forces the noun to the Genitive case if the whole phrase is in the Nominative and Accusative case.
(NB In the Vocative case, the phrase would behave like in the Nominative case, but the Vocative usage is rather hypothetical).
In Genitive, the noun and the numeral agree with each other; but note that the numeral uses its
inflected form, as in the other cases where it agrees with the noun.</p>

<p>Pronominal quantifiers behave as high-value numerals and govern the quantifed nouns:</p>

<ul>
  <li><em><b>Сколько</b> мужчин играло в карты?</em> “How many men played cards?”</li>
  <li><em><b>Несколько</b> (<b>много</b>, <b>мало</b>) мужчин играло в карты.</em> “Several (many, few) men played cards.”</li>
  <li><em><b>Столько</b> мужчин, играющих в карты, я никогда не видел.</em> “I have never seen so many men playing cards.”</li>
</ul>

<p>Examples:
~~~ sdparse
Три мужчины играли в карты . \n Three men played cards .
nummod:gov(мужчины, Три)
nsubj(играли, мужчины)
dobj(играли, карты)
case(карты, в)
punct(играли, .-6)
nummod:gov(men, Three)
nsubj(played, men)
dobj(played, cards)
punct(played, .-12)
~~~</p>

<pre><code class="language-sdparse">Пять мужчин играло в карты . \n Five men played cards .
nummod:gov(мужчин, Пять)
nsubj(играло, мужчин)
dobj(играло, карты)
case(карты, в)
punct(играло, .-6)
nummod:gov(men, Five)
nsubj(played, men)
dobj(played, cards)
punct(played, .-12)
</code></pre>

<pre><code class="language-sdparse">Сколько мужчин играло в карты ? \n How-many men played cards ?
det:numgov(мужчин, Сколько)
nsubj(играло, мужчин)
dobj(играло, карты)
case(карты, в)
punct(играло, ?-6)
det:numgov(men, How-many)
nsubj(played, men)
dobj(played, cards)
punct(played, ?-12)
</code></pre>

<pre><code class="language-sdparse">Играл я в карты с пятью мужчинами . \n Played I cards with five men .
nsubj(Играл, я)
dobj(Играл, карты)
case(карты, в)
iobj(Играл, мужчинами)
case(мужчинами, с)
nummod(мужчинами, пятью)
punct(Играл, .-8)
nsubj(Played, I)
dobj(Played, cards)
iobj(Played, men)
case(men, with)
nummod(men, five)
punct(Played, .-16)
</code></pre>

<pre><code class="language-sdparse">Не помню , со сколькими мужчинами я играл в карты . \n Not I-remember , with how-many men I played cards .
neg(помню, Не)
ccomp(помню, играл)
punct(играл, ,-3)
nsubj(играл, я)
dobj(играл, карты)
case(карты, в)
iobj(играл, мужчинами)
case(мужчинами, со)
det:nummod(мужчинами, сколькими)
punct(помню, .-11)
neg(I-remember, Not)
ccomp(I-remember, played)
punct(played, ,-15)
nsubj(played, I)
dobj(played, cards)
iobj(played, men)
case(men, with)
det:nummod(men, how-many)
punct(I-remember, .-22)
</code></pre>

<h2 id="additional-remarks">Additional remarks</h2>

<p><em>Миллион</em> “million” and <em>миллиард</em> “billion” are tagged as a <a href="ru-pos/NOUN">NOUN</a>. In the typical case, such words take the Genitive, it is preceded by a smaller number,
and it is not followed by smaller numerals (as it is in <em>million five hundred thousand</em>).
It is followed by the counted noun and gets the following analysis:</p>

<pre><code class="language-sdparse">50 миллионов крон \n 50 millions of-crowns
nummod:gov(миллионов, 50-1)
nummod:gov(millions, 50-5)
nmod(миллионов, крон)
nmod(millions, of-crowns)
</code></pre>

<p>On the other hand the word <em>тысяча</em> “thousand” may be a noun
(<em>на площади были тысячи людей</em> “there were thousands of people in the square”)
or a numeral:</p>

<pre><code class="language-sdparse">максимум 50 тысяч крон \n at-most 50 thousand crowns
advmod(крон, максимум)
nummod:gov(крон, тысяч)
compound(тысяч, 50-2)
advmod(crowns, at-most)
nummod:gov(crowns, thousand)
compound(thousand, 50-7)
</code></pre>

<p>Note that the two numeral words in the above example are joined using the <a href="">compound</a> relation.
Also note that the <a href="advmod:emph">intensifier</a> <em>максимум</em> is attached to the head of the phrase <em>(крон)</em> and not to the number.</p>

<p>Similarly there may be other nodes (such as punctuation) that are attached to the head of the phrase
and they are related to the whole phrase rather than directly to the head noun:</p>

<pre><code class="language-sdparse">( 9 дней ) \n ( 9 days )
punct(дней, (-1)
nummod:gov(дней, 9-2)
punct(дней, )-4)
punct(days, (-6)
nummod:gov(days, 9-7)
punct(days, )-9)
</code></pre>

<pre><code class="language-sdparse">5 минут с установкой \n 5 minutes including adjustment
nummod:gov(минут, 5-1)
nmod(минут, установкой)
case(установкой, с)
nummod:gov(minutes, 5-6)
nmod(minutes, adjustment)
case(adjustment, including)
</code></pre>

<h2 id="dates">Dates</h2>

<pre><code class="language-sdparse">Директор предложил расформировать персонал к 31 . 12 . \n Director proposed to-disband the-staff towards 31 st December .
advmod(расформировать, 12)
case(12, к)
punct(12, .-9)
nummod(12, 31-6)
punct(31-6, .-7)
advmod(to-disband, December)
case(December, towards)
punct(December, .-19)
nummod(December, 31-16)
punct(31-16, st)
</code></pre>

<h2 id="numbered-objects">Numbered objects</h2>

<p>House number in address is attached as <code>nummod</code> to the name of the street:</p>

<pre><code class="language-sdparse">в доме на Тверской 12 \n in the-building in Tverskaya 12
nmod(доме, Тверской-4)
case(Тверской-4, на-3)
nummod(Тверской-4, 12-5)
nmod(the-building, Tverskaya)
case(Tverskaya, in)
nummod(Tverskaya, 12-11)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/nummod.md" target="#">edit nummod</a></p>

<p><a id="al-ru-dep/nummod:gov" class="al-dest"></a></p>
<h2><code>nummod:gov</code>: numeric modifier governing the case of the noun</h2>

<p><code>nummod:gov</code> differs from <a href="">nummod</a>
in that the numeral requires the counted noun to be in its genitive form.
The whole phrase (numeral + noun) is treated as a singular neuter noun phrase
and it can fill roles where nominative, accusative or vocative noun phrases are expected.</p>

<p>In UD the numeral is annotated as dependent of the noun and the <code>nummod:gov</code> label is used to preserve
the information about case conditions.</p>

<pre><code class="language-sdparse">Пять мужчин играло в карты . \n Five men played cards .
nummod:gov(мужчин, Пять)
nsubj(играло, мужчин)
obj(играло, карты)
case(карты, в)
punct(играло, .-6)
nummod:gov(men, Five)
nsubj(played, men)
obj(played, cards)
punct(played, .-12)
</code></pre>

<p>See <a href="">nummod</a> for a broader discussion of the various situations with quantifiers.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/nummod-gov.md" target="#">edit nummod:gov</a></p>

<p><a id="al-ru-dep/obj" class="al-dest"></a></p>
<h2><code>obj</code>: object</h2>

<p>The object of a verb is the the second most core argument of a verb after the subject. 
Most often it is a direct object is in the <a href="ru-feat/Case">accusative case</a>, a noun phrase that denotes the entity acted upon.
However, in Russian there are many verbs that require their objects be in other cases (except for
nominative and vocative).</p>

<p>Accusative example:</p>

<pre><code class="language-sdparse">Я купил машину . \n I have-bought car .
obj(купил, машину)
obj(have-bought, car)
</code></pre>

<p>Genitive example:</p>

<pre><code class="language-sdparse">Я не боюсь этого . \n I-am not afraid of this .
obj(боюсь, этого)
obj(afraid, this)
</code></pre>

<p>Dative example:</p>

<pre><code class="language-sdparse">Но это не соответствует действительности . \n But this not corresponds to-reality .
obj(соответствует, действительности)
obj(corresponds, to-reality)
</code></pre>

<p>Instrumental example:</p>

<pre><code class="language-sdparse">Президент руководит страной . \n The President rules the country .
obj(руководит, страной)
obj(rules, country)
</code></pre>

<p>In general, if there is only one object, it should be labeled <code>obj</code>,
regardless of the morphological case or semantic role that it bears. If there are two or more
objects, one of them should be <code>obj</code> and the others should be
<a href="">iobj</a>. In such cases it is necessary to decide what is the most
directly affected object <em>(patient).</em> The one exception is when there is a clausal complement: 
then the clausal complement is regarded as a “clausal object” and an object nominal will be an iobj.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/obj.md" target="#">edit obj</a></p>

<p><a id="al-ru-dep/obl" class="al-dest"></a></p>
<h2><code>obl</code>: oblique modifier</h2>

<p>The <code>obl</code> relation is used for non-core nominal dependents of clausal
predicates.</p>

<pre><code class="language-sdparse">Последний раз мы разговаривали зимой . \n Last time we talked in-winter .
obl(разговаривали, зимой)
obl(talked, in-winter)
</code></pre>

<p>One subtype of <code>obl</code> is introduced in Russian: <a href="">obl:agent</a> for agents of passive verbs.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/obl.md" target="#">edit obl</a></p>

<p><a id="al-ru-dep/obl:agent" class="al-dest"></a></p>
<h2><code>obl:agent</code>: agent oblique nominal </h2>

<p>The relation <code>obl:agent</code> is used for agents of passive verbs</p>

<pre><code class="language-sdparse">Решение было принято моим отцом \n Decision was made by my father 
obl:agent(принято, отцом)
obl:agent(made, father)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/obl-agent.md" target="#">edit obl:agent</a></p>

<p><a id="al-ru-dep/orphan" class="al-dest"></a></p>
<h2><code>orphan</code>: orphan in ellipsis</h2>

<p>The <code>orphan</code> relation is used in cases of head ellipsis where simple promotion would result in unnatural 
and misleading dependency relation. The typical case is predicate ellipsis where one of the core arguments 
have to be promoted to clausal head.</p>

<pre><code class="language-sdparse">Павел заказал говядину , а Мария свинину . \n Pavel  ordered beef and Maria pork .
nsubj(заказал, Павел)
nsubj(ordered, Pavel)
obj(заказал, говядину)
obj(ordered, beef)
conj(Павел, Мария)
conj(Pavel, Maria)
orphan(говядину, свинину)
orphan(beef, pork)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/orphan.md" target="#">edit orphan</a></p>

<p><a id="al-ru-dep/parataxis" class="al-dest"></a></p>
<h2><code>parataxis</code>: parataxis</h2>

<p>The parataxis relation (from Greek for “place side by side”) is a
relation between a word (often the main predicate of a sentence) and other
elements, such as a sentential parenthetical or a clause after a “:” or
a “;”, placed side by side without any explicit
coordination, subordination, or argument relation with the head word. Parataxis is a discourse-like equivalent of coordination, and so usually obeys an iconic ordering. Hence it is normal for the first part of a sentence to be the head and the second part to be the parataxis dependent, regardless of the headedness properties of the language.  But things do get more complicated, such as cases of parentheticals, which appear medially.</p>

<h2 id="an-inventory-of-constructions-to-which-parataxis-has-been-applied">An inventory of constructions to which parataxis has been applied</h2>

<h3 id="treatment-of-reported-speech">Treatment of reported speech</h3>

<p>For this reported speech example:</p>

<pre><code class="language-sdparse">Тот парень , сказал Вася , ушёл рано утром  . \n The guy , said Vasya , left early in-the-morning .
parataxis(ушёл, сказал)
parataxis(left, said)
</code></pre>

<p>There are paraphrases that convey essentially the same meaning but with a different syntactic structure. When the reported speech is embedded in a subordinate clause (with or without an overt complementizer <em>что</em> “that”), the subordinate clause is a <a href="">ccomp</a> of the speech verb. When the reported speech follows the speech verb and is separated by a colon, the reported speech forms a main clause that attaches to the preceding main clause with a <a href="">parataxis</a> relation, hence with the speech verb as its head.
However, when the speech verb occurs as a medial or final parenthetical, the relation is reversed and the speech verb is treated as a <a href="">parataxis</a> of the reported speech. 
This analysis is not uncontroversial but follows many authorities, such as Huddleston and Pullum (2002),
<em>The Cambridge Grammar of the English Language</em> (see chapter 11, section 9).</p>

<pre><code class="language-sdparse">Вася сказал , что тот парень ушёл рано утром . \n Vasya said , that the guy left early in-the-morning .
ccomp(сказал, ушёл)
ccomp(said, left)
</code></pre>

<pre><code class="language-sdparse">Вася сказал : " Тот парень ушёл рано утром . " \n Vasya said : " The guy left early in-the-morning . "
parataxis(сказал, ушёл)
parataxis(said, left)
</code></pre>

<pre><code class="language-sdparse">" Тот парень ушёл рано утром , " сказал Вася . \n " The guy left early in-the-morning , " said Vasya .
parataxis(ушёл, сказал)
parataxis(left, said)
</code></pre>

<pre><code class="language-sdparse">" Тот парень , " — сказал Вася , — " ушёл рано утром . " \n " The guy , " — said Vasya , — " left early in-the-morning . "
parataxis(ушёл, сказал)
parataxis(left, said)
</code></pre>

<p>An argument for this analysis is that in the cases analyzed as embedding, the entire clause can be further embedded 
(<em>I was taken aback when John said the guy left early in the morning.</em>),
while this is not possible with medial or final placement of the speech verb 
(<em>*I was taken aback when the guy left early this morning, John said.</em>).</p>

<h3 id="news-article-bylines">News article bylines</h3>

<p>The <code>parataxis</code> relation should be used to connect the parts of a news article byline.
There does not seem to be a better relation to use.</p>

<pre><code class="language-sdparse">Вашингтон ( CNN ) :
parataxis(Вашингтон, CNN)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/parataxis.md" target="#">edit parataxis</a></p>

<p><a id="al-ru-dep/punct" class="al-dest"></a></p>
<h2><code>punct</code>: punctuation</h2>

<p>This is used for any piece of punctuation in a clause.</p>

<pre><code class="language-sdparse">Иди домой ! \n Go home !
punct(Иди, !-3)
punct(Go, !-7)
</code></pre>

<p>Tokens with the relation <code>punct</code> always attach to content words (except in cases of ellipsis) and can never have dependents.
Since <code>punct</code> is not a normal dependency relation, the usual criteria for determining the head word do not apply. 
Instead, we use the following principles:</p>

<ol>
  <li>A punctuation mark separating coordinated units is attached to the first conjunct.</li>
  <li>A punctuation mark preceding or following a subordinated unit is attached to this unit.</li>
  <li>Within the relevant unit, a punctuation mark is attached at the highest possible node that preserves projectivity.</li>
  <li>Paired punctuation marks (quotes and brackets) should be attached to the same word unless that would create non-projectivity. This word is usually the head of the phrase enclosed in the paired punctuation.</li>
</ol>

<pre><code class="language-sdparse">Мы покупаем яблоки , груши , апельсины и бананы . \n We buy apples , pears , oranges and bananas .
obj(покупаем, яблоки)
obj(buy, apples)
conj(яблоки, груши)
conj(яблоки, апельсины)
conj(яблоки, бананы)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(яблоки, и)
cc(apples, and)
punct(яблоки, ,-4)
punct(яблоки, ,-6)
punct(apples, ,-15)
punct(apples, ,-17)
</code></pre>

<pre><code class="language-sdparse">Мужчина , которого ты вчера видел , пришёл снова . \n Man , whom you-have yesterday seen , came again .
punct(видел, ,-2)
punct(seen, ,-13)
punct(видел, ,-7)
punct(seen, ,-18)
punct(пришёл, .-10)
punct(came, .-21)
</code></pre>

<pre><code class="language-sdparse">Аббревиатура напр . означает " например " . \n The-abbreviation eg . means " for-example " .
punct(напр, .-3)
punct(eg, .-12)
punct(например, "-5)
punct(for-example, "-14)
punct(например, "-7)
punct(for-example, "-16)
punct(означает, .-8)
punct(means, .-17)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/punct.md" target="#">edit punct</a></p>

<p><a id="al-ru-dep/reparandum" class="al-dest"></a></p>
<h2><code>reparandum</code>: overridden disfluency</h2>

<p>We use <code>reparandum</code> to indicate disfluencies overridden in a speech
repair. The disfluency is the dependent of the repair.</p>

<pre><code class="language-sdparse">Идите напра- налево . \n Go to-the-righ- to-the-left .
reparandum(налево, напра-)
reparandum(to-the-left, to-the-righ-)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/reparandum.md" target="#">edit reparandum</a></p>

<p><a id="al-ru-dep/root" class="al-dest"></a></p>
<h2><code>root</code>: root</h2>

<p>The <code>root</code> grammatical relation points to the root of the sentence. A
fake node <code>ROOT</code> is used as the governor. The <code>ROOT</code> node is indexed
with 0, since the indexing of real words in the sentence starts at 1.</p>

<pre><code class="language-sdparse">ROOT Люблю индийскую еду . \n ROOT I-love Indian food .
root(ROOT-1, Люблю)
root(ROOT-7, I-love)
</code></pre>

<p>There is just one node with the <code>root</code> dependency relation in every
tree. If the main predicate is not present (due to
<a href="http://universaldependencies.org/cs/overview/specific-syntax.html#ellipsis">ellipsis</a>)
and there are
multiple orphaned dependents, the leftmost dependent is promoted to
the head (root) position and the other orphans are attached to it.</p>

<p>An example sentence-like segment that lacks the main verb:
<em>И что он на это ?</em>
“And what [does] he [say] to it?”</p>

<pre><code class="language-sdparse">ROOT И что он на это ? \n ROOT And what he to it ?
root(ROOT-1, И)
root(ROOT-9, And)
obj(И, что)
obj(And, what)
nmod(И, это)
nmod(And, it)
case(это, на)
case(it, to)
nsubj(И, он)
nsubj(And, he)
punct(И, ?-7)
punct(And, ?-15)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/root.md" target="#">edit root</a></p>

<p><a id="al-ru-dep/vocative" class="al-dest"></a></p>
<h2><code>vocative</code>: vocative</h2>

<p>The <code>vocative</code> relation is used to mark dialogue participant addressed in text.
The relation links the addressee’s name to its host sentence.
In Russian, the addressee’s name can also appear in the vocative <a href="">Case</a> form.</p>

<pre><code class="language-sdparse">Мужчина , Вы дурак ! \n Sir , you-are a-fool !
vocative(дурак, Мужчина)
vocative(a-fool, Sir)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/vocative.md" target="#">edit vocative</a></p>

<p><a id="al-ru-dep/xcomp" class="al-dest"></a></p>
<h2><code>xcomp</code>: open clausal complement</h2>

<p>An open clausal complement (<code>xcomp</code>) of a verb or an adjective is a
predicative or clausal complement without its own subject. The
reference of the subject is necessarily determined by an argument
external to the xcomp (normally by the subject of the next higher
clause). This is often referred to as <em>obligatory control</em>. 
These complements are always non-finite, and they are
complements (arguments of the higher verb or adjective) rather than
adjuncts/modifiers, such as a purpose clause. The name <code>xcomp</code> is
borrowed from Lexical-Functional Grammar.</p>

<pre><code class="language-sdparse">Хочешь плавать ? \n Do-you-want to-swim ?
xcomp(Хочешь, плавать)
xcomp(Do-you-want, to-swim)
</code></pre>

<pre><code class="language-sdparse">Я начал там работать вчера . \n I started there to-work yesterday .
xcomp(начал, работать)
xcomp(started, to-work)
</code></pre>

<p>Note that the above condition “without its own subject” does not mean that a 
clause is an <code>xcomp</code> just because its subject is not <em>overt.</em>
The subject must be necessarily inherited from a fixed position in the higher clause.
That is, there should be no available interpretation where the subject of the lower clause may be distinct
from the specified role of the upper clause.
In cases where the missing subject may or must be distinct from a fixed role in the higher clause,
<a href="">ccomp</a> should be used instead, as below.  This includes cases of arbitrary subjects and anaphoric control.</p>

<pre><code class="language-sdparse">Начальник приказал выкопать ров . \n Boss ordered to-dig ditch .
ccomp(приказал, выкопать)
ccomp(ordered, to-dig)
</code></pre>

<p>Pro-drop languages have clauses where the subject is not present as a separate word,
yet it is inherently present (and often deducible from the form of the verb)
and it does not depend on arguments from a higher clause.
Thus in neither of the following two Russian examples is there any overt subject,
yet only the second example contains an <code>xcomp</code>.</p>

<pre><code class="language-sdparse">Пишу , потому что я это обещал . \n I-write , because that I-have it promised .
advcl(Пишу, обещал)
advcl(I-write, promised)
</code></pre>

<pre><code class="language-sdparse">Я обещал писать . \n I have-promised to-write .
xcomp(обещал, писать)
xcomp(have-promised, to-write)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ru-dep/xcomp.md" target="#">edit xcomp</a></p>



      </div>

<!-- support for embedded visualizations -->
<script type="text/javascript">
    var root = '../../'; // filled in by jekyll
    head.js(
        // External libraries
        root + 'lib/ext/jquery.min.js',
        root + 'lib/ext/jquery.svg.min.js',
        root + 'lib/ext/jquery.svgdom.min.js',
        root + 'lib/ext/jquery.timeago.js',
        root + 'lib/ext/jquery-ui.min.js',
        root + 'lib/ext/waypoints.min.js',
        root + 'lib/ext/jquery.address.min.js',

        // brat helper modules
        root + 'lib/brat/configuration.js',
        root + 'lib/brat/util.js',
        root + 'lib/brat/annotation_log.js',
        root + 'lib/ext/webfont.js',
        // brat modules
        root + 'lib/brat/dispatcher.js',
        root + 'lib/brat/url_monitor.js',
        root + 'lib/brat/visualizer.js',

        // embedding configuration
        root + 'lib/local/config.js',
        // project-specific collection data
        root + 'lib/local/collections.js',

        // NOTE: non-local libraries
        'https://spyysalo.github.io/annodoc/lib/local/annodoc.js',
        'https://spyysalo.github.io/conllu.js/conllu.js'
    );

    var webFontURLs = [
//        root + 'static/fonts/Astloch-Bold.ttf',
        root + 'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        root + 'static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var setupAccordions = function() {
	// preserve state in URL hash, following in part
	// http://www.boduch.ca/2011/05/remembering-jquery-ui-accordion.html
	var accordionChange = function(event, ui) {
	    var context = ui.newHeader ? ui.newHeader.context : null;
	    if (context) {
		var languageCode = context.getAttribute('data-lc');
		if (languageCode !== null) {
		    window.location.hash = languageCode;
		}
	    }
	}
        // jQuery UI "accordion" element initialization
	$(".jquery-ui-accordion").accordion({
	    collapsible: true,
	    active: false,
	    change: accordionChange
	});
	if ($(".jquery-ui-accordion").length) {
	    var matches = window.location.hash.match(/^\#(.*)$/);
	    console.log(matches);
	    if (matches !== null) {
		var languageCode = matches[1];
		var tab = $('[data-lc="'+languageCode+'"]');
		// the following will only work after accordion is initialized
		var index = $('.jquery-ui-accordion div.ui-accordion-header').index(tab);
		if (index !== -1) {
		    $(".jquery-ui-accordion").accordion({ active: index });
		}
	    }
	}
    };

    var setupTimeago = function() {
        jQuery("time.timeago").timeago();
    };

    var setupTabs = function() {
        // standard jQuery UI "tabs" element initialization
        $(".jquery-ui-tabs").tabs({ heightStyle: "auto" });

        // use jQuery address to preserve tab state
        // (see https://github.com/UniversalDependencies/docs/issues/65,
        // http://stackoverflow.com/a/3330919)
        if ($(".jquery-ui-tabs").length > 0) {
            $.address.change(function(event){
	        $(".jquery-ui-tabs").tabs("select", window.location.hash)
	    });
	    $(".jquery-ui-tabs").bind("tabsselect", function(event, ui) { 
	        window.location.hash = ui.tab.hash;
	    });
        }
    };

    head.ready(function() {
        // set up UI tabs on page
        setupTabs();
        setupAccordions();
        setupTimeago();

        // mark current collection (filled in by Jekyll)
        Collections.listing['_current'] = 'ru-overview';

	// perform all embedding and support functions
	Annodoc.activate(Config.bratCollData, Collections.listing);
    });
</script>


<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55233688-1', 'auto');
  ga('send', 'pageview');

</script>


      <div id="footer">
	  <p class="footer-text">&copy; 2014 
	    <a href="http://universaldependencies.org/introduction.html#contributors" style="color:gray">Universal Dependencies contributors</a>. 
	    Site powered by <a href="http://spyysalo.github.io/annodoc" style="color:gray">Annodoc</a> and <a href="http://brat.nlplab.org/" style="color:gray">brat</a></p>.
      </div>
    </div>
  </body>
</html>
