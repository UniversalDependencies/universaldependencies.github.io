<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Universal Dependencies</title>
    <link rel="root" href=""/> <!-- for JS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="../../css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style-vis.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/hint.css"/>
    <script type="text/javascript" src="../../lib/ext/head.load.min.js"></script>
    <script type="text/javascript" src="../../lib/ext/jquery.timeago.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.2.2/anchor.min.js"></script>
    <script>document.addEventListener("DOMContentLoaded", function(event) {anchors.add();});</script>
    <!-- Set up this custom Google search at https://cse.google.com/cse/business/settings?cx=001145188882102106025:dl1mehhcgbo -->
    <script>
      (function() {
        var cx = '001145188882102106025:dl1mehhcgbo';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->


  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
        <table width="100%"><tr><td width="50%">
          <span class="header-text"><a href="http://universaldependencies.org/#language-u">home</a></span>


          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
        </td><td>
          <gcse:search></gcse:search>
        </td></tr></table>
      </div>

      <hr/>

      
      <div class="v2complete">
	This page pertains to UD version 2.
      </div>
      
      
      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          <h1 id="universal-dependencies">Universal Dependencies</h1>

<p>The following table lists the 37 universal syntactic relations used in UD v2. It is a revised version of the relations 
originally described in <a href="http://nlp.stanford.edu/pubs/USD_LREC14_paper_camera_ready.pdf"><em>Universal Stanford Dependencies: A cross-linguistic typology</em></a> (de Marneffe <em>et al.</em> 2014).</p>

<p>The upper part of the table follows the main organizing principles of the UD taxonomy:</p>

<ul>
  <li>Rows correspond to functional categories in relation to the head:
    <ul>
      <li>Core arguments of clausal predicates</li>
      <li>Non-core dependents of clausal predicates</li>
      <li>Dependents of nominals</li>
    </ul>
  </li>
  <li>Columns correspond to structural categories of the dependent:
    <ul>
      <li>Nominals</li>
      <li>Clauses</li>
      <li>Modifier words</li>
      <li>Function words</li>
    </ul>
  </li>
</ul>

<p>The lower part of the table lists relations that are not dependency relations in the narrow sense:</p>

<ul>
  <li>Relations used to analyze coordination</li>
  <li>Relations used to analyze multiword expressions (MWE)</li>
  <li>Loose joining relations</li>
  <li>Special relations for ellipsis, disfluencies, and orthographic errors</li>
  <li>Special relations for clausal heads, punctuation and other relations</li>
</ul>

<table class="typeindex" border="1">
  <tr style="background-color:cornflowerblue">
      <td>	
	<table class="category">
	  <tr><td><strong></strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Nominals</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Clauses</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Modifier words</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Function Words</strong></td></tr>
	</table>
      </td>
  </tr>
  <tr>
      <td style="background-color:darkseagreen">
	<table class="category">
	  <tr><td><strong>Core arguments</strong></td></tr>
	</table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>nsubj</a></td>
	  </tr>
	  <tr>
	    <td><a>obj</a></td>
	  </tr>
	  <tr>
	    <td><a>iobj</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>csubj</a></td>
	  </tr>
	  <tr>
	    <td><a>ccomp</a></td>
	  </tr>
	  <tr>
	    <td><a>xcomp</a></td>
	  </tr>
        </table>
      </td>
	  <td></td><td></td>
  </tr>
  <tr>
      <td style="background-color:darkseagreen">
	<table class="category">
	  <tr><td><strong>Non-core dependents</strong></td></tr>
	</table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>obl</a></td>
	  </tr>
	  <tr>
	    <td><a>vocative</a></td>
	  </tr>
	  <tr>
	    <td><a>expl</a></td>
	  </tr>
	  <tr>
	    <td><a>dislocated</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>advcl</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>advmod</a>*</td>
	  </tr>
	  <tr>
	    <td><a>discourse</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>aux</a></td>
	  </tr>
	  <tr>
	    <td><a>cop</a></td>
	  </tr>
	  <tr>
	    <td><a>mark</a></td>
	  </tr>
        </table>
      </td>
  </tr>
  <tr>
      <td style="background-color:darkseagreen">
	<table class="category">
	  <tr><td><strong>Nominal dependents</strong></td></tr>
	</table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>nmod</a></td>
	  </tr>
	  <tr>
	    <td><a>appos</a></td>
	  </tr>
	  <tr>
	    <td><a>nummod</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>acl</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>amod</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>det</a></td>
	  </tr>
	  <tr>
	    <td><a>clf</a></td>
	  </tr>
	  <tr>
	    <td><a>case</a></td>
	  </tr>
        </table>
      </td>
  </tr>
  <tr style="background-color:cornflowerblue">	
      <td>	
	<table class="category">
	  <tr><td><strong>Coordination</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>MWE</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Loose</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Special</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Other</strong></td></tr>
	</table>
      </td>
  </tr>
  <tr>
      <td>
        <table class="category">
	  <tr>
	    <td><a>conj</a></td>
	  </tr>
	  <tr>
	    <td><a>cc</a></td>
	  </tr>
        </table>
      </td>
      <td>
        <table class="category">
	<tr>
	  <td><a>fixed</a></td>
	</tr>
	<tr>
	  <td><a>flat</a></td>
	</tr>
	<tr>
	  <td><a>compound</a></td>
	</tr>
      </table>
    </td>
    <td>
      <table class="category">
	<tr>
	  <td><a>list</a></td>
	</tr>
	<tr>
	  <td><a>parataxis</a></td>
	</tr>
      </table>
    </td>
    <td>
      <table class="category">
	<tr>
	  <td><a>orphan</a></td>
	</tr>
	<tr>
	  <td><a>goeswith</a></td>
	</tr>
	<tr>
	  <td><a>reparandum</a></td>
	</tr>
      </table>
    </td>
    <td>
      <table class="category">
	<tr>
	  <td><a>punct</a></td>
	</tr>
	<tr>
	  <td><a>root</a></td>
	</tr>
	<tr>
	  <td><a>dep</a></td>
	</tr>
      </table>

    </td>
  </tr>
</table>

<hr />

<p><a id="al-u-dep/acl" class="al-dest"></a></p>
<h2><code>acl</code>: clausal modifier of noun (adjectival clause)</h2>

<p><code>acl</code> stands for finite and non-finite clauses that modify a nominal.  The <code>acl</code> relation 
contrasts with the <a href="">advcl</a> relation, which is used for adverbial clauses
that modify a predicate. The head of the <code>acl</code> relation is the noun
that is modified, and the dependent is the head of the clause that
modifies the noun.</p>

<pre><code class="language-sdparse">the issues as he sees them
acl(issues, sees)
</code></pre>

<pre><code class="language-sdparse">There are many online sites offering booking facilities .
acl(sites, offering)
</code></pre>

<pre><code class="language-sdparse">I have a parakeet named cookie .
acl(parakeet, named)
</code></pre>

<pre><code class="language-sdparse">I just want a simple way to get my discount .
acl(way, get)
</code></pre>

<pre><code class="language-sdparse">Cette affaire Ã  suivre \n This case to follow 
acl(affaire, suivre)
</code></pre>

<p>This relation is also used for optional depictives. The adjective is taken to modify the nominal of which it provides a secondary predication. See <a href="">xcomp</a> for further discussion of resultatives and depictives.</p>

<pre><code class="language-sdparse">She entered the room sad
acl(She, sad)
</code></pre>

<pre><code class="language-sdparse">He painted the model naked
acl(model, naked)
</code></pre>

<p>A relative clause is an instance of <code>acl</code>, characterized by finiteness and usually omission of 
the modified noun in the embedded clause. Some languages use a language-particular subtype <code>acl:relcl</code> for the traditional class of relative clauses.</p>

<pre><code class="language-sdparse">I saw the man you love
acl:relcl(man, love)
</code></pre>

<p>Some languages allow finite clausal complements for nouns with 
a subset of nouns like <em>fact</em> or <em>report</em>. These look roughly like relative clauses, but do not have any omitted role in the dependent clause. This is the class of âcontent
clausesâ in Huddleston and Pullum 2002). These are also analyzed as <code>acl</code>.</p>

<pre><code class="language-sdparse">the fact that nobody cares
acl(fact, cares)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/acl.md" target="#">edit acl</a></p>

<p><a id="al-u-dep/advcl" class="al-dest"></a></p>
<h2><code>advcl</code>: adverbial clause modifier</h2>

<p>An adverbial clause modifier is a clause which modifies a verb or other predicate (adjective, etc.),
as a modifier not as a core complement. This includes things such as a temporal clause, consequence, conditional clause, purpose
clause, etc. The dependent must be clausal (or else it is an <a href="">advmod</a>) and the dependent is the main predicate of the clause.</p>

<pre><code class="language-sdparse">The accident happened as night was falling
advcl(happened, falling)
</code></pre>

<pre><code class="language-sdparse">If you know who did it, you should tell the teacher
advcl(tell, know)
</code></pre>

<pre><code class="language-sdparse">He talked to him in order to secure the account
advcl(talked, secure)
</code></pre>

<pre><code class="language-sdparse">He was upset when I talked to him
advcl(upset, talked)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/advcl.md" target="#">edit advcl</a></p>

<p><a id="al-u-dep/advmod" class="al-dest"></a></p>
<h2><code>advmod</code>: adverbial modifier</h2>

<p>An adverbial modifier of a word is a (non-clausal) <a href="u-pos/ADV">adverb</a>
or adverbial phrase that serves to modify a predicate or a modifier word.</p>

<p>Note that in some grammatical traditions, the term <em>adverbial modifier</em> covers
constituents that function like adverbs regardless whether they are realized
by adverbs, adpositional phrases, or nouns in particular morphological 
<a href="u-feat/Case">cases</a>.
We differentiate adverbials realized as adverbs <em>(advmod)</em> and
adverbials realized by noun phrases or adpositional phrases
(<a href="">obl</a>). However, we do not differentiate between modifiers of predicates
(adverbials in a narrow sense) and modifiers of other modifier words like
adjectives or adverbs (sometime called qualifiers). These functions are all
subsumed under <code>advmod</code>.</p>

<pre><code class="language-sdparse">Genetically modified food
advmod(modified, Genetically)
</code></pre>

<pre><code class="language-sdparse">less often
advmod(often, less)
</code></pre>

<pre><code class="language-sdparse">Where/ADV do/AUX you/PRON want/VERB to/ADP go/VERB later/ADV ?/PUNCT
advmod(go, Where)
advmod(go, later)
</code></pre>

<pre><code class="language-sdparse">About 200 people came to the party
advmod(200, About)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/advmod.md" target="#">edit advmod</a></p>

<p><a id="al-u-dep/amod" class="al-dest"></a></p>
<h2><code>amod</code>: adjectival modifier</h2>

<p>An adjectival modifier of a noun is any adjectival phrase that serves
to modify the meaning of the noun.</p>

<pre><code class="language-sdparse">Sam eats red meat
amod(meat, red)
</code></pre>

<pre><code class="language-sdparse">Sam took out  a 3 million dollar loan
amod(loan, dollar)
</code></pre>

<pre><code class="language-sdparse">Sam took out  a $ 3 million loan
amod(loan, $)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/amod.md" target="#">edit amod</a></p>

<p><a id="al-u-dep/appos" class="al-dest"></a></p>
<h2><code>appos</code>: appositional modifier</h2>

<p>An appositional modifier of a noun is a nominal immediately following
the first noun that serves to define, modify, name, or describe that noun. It includes
parenthesized examples, as well as defining abbreviations in one of
these structures.</p>

<pre><code class="language-sdparse">Sam , my brother , arrived
appos(Sam-1, brother-4)
</code></pre>

<pre><code class="language-sdparse">Bill ( John 's cousin )
appos(Bill-1, cousin-5)
</code></pre>

<pre><code class="language-sdparse">The Australian Broadcasting Corporation ( ABC )
appos(Corporation-4, ABC-6)
</code></pre>

<p><code>appos</code> is intended to be used between two nominals. In general, modulo punctuation, the two halves of an apposition can be switched. 
For example, you could also say <em>My brother, Sam, arrived.</em> There are somewhat similar constructions with titles 
where the title is less than a full nominal, such as <em>state senator Paul Mnuchin</em>, where reversal is impossible 
or would require insertion of a determiner to make a 
full nominal. Some grammatical traditions, descending from Latin, call <em>state senator</em> in such cases a âfixed (or close) appositionâ and take the name as the head. However, we seem to have only one nominal not two here. For example:</p>

<blockquote>
  <p>President Obama</p>
</blockquote>

<blockquote>
  <p>*Obama President</p>
</blockquote>

<blockquote>
  <p>state senator Paul Mnuchin</p>
</blockquote>

<blockquote>
  <p>*Paul Mnuchin state senator</p>
</blockquote>

<p><code>appos</code> should not be used in such cases. However, the examples can usually be rendered in a fuller form, corresponding to âloose (or wide) appositionâ in the Latin tradition, where there are two full phrases. Then the relation <code>appos</code> is appropriate, for example:</p>

<pre><code class="language-sdparse">Paul Mnuchin , the senior Oregon state senator
appos(Mnuchin-2, senator-8)
</code></pre>

<p>As is often the case, there are borderline cases. In formal writing, punctuation is usually a good signal of apposition, 
but there are certainly cases of apposition where no punctuation is used:</p>

<pre><code class="language-sdparse">the leader of the militant Lebanese Shiite group Hassan Nasrallah
appos(group-8, Hassan-9)
flat(Hassan-9, Nasrallah-10)
</code></pre>

<p>Good tests include to ask whether the two halves are full nominals, whether the two halves can be swapped or not, and whether 
there is case or agreement concord (in a language with rich morphology). So we have:</p>

<pre><code class="language-sdparse">I met the French actor Gaspard Ulliel
nsubj(met-2, I-1)
det(actor-5, the-3)
amod(actor-5, French-4)
obj(met-2, actor-5)
appos(actor-5, Gaspard-6)
flat(Gaspard-6, Ulliel-7)
</code></pre>

<pre><code class="language-sdparse">I met Gaspard Ulliel the French actor 
nsubj(met-2, I-1)
obj(met-2, Gaspard-3)
flat(Gaspard-3, Ulliel-4)
det(actor-7, the-5)
amod(actor-7, French-6)
appos(Gaspard-3, actor-7)
</code></pre>

<pre><code class="language-sdparse">I met Gaspard Ulliel , the French actor 
nsubj(met-2, I-1)
obj(met-2, Gaspard-3)
flat(Gaspard-3, Ulliel-4)
punct(Gaspard-3, ,-5)
det(actor-8, the-6)
amod(actor-8, French-7)
appos(Gaspard-3, actor-8)
</code></pre>

<pre><code class="language-sdparse">I met French actor Gaspard Ulliel
nsubj(met-2, I-1)
amod(actor-4, French-3)
obj(met-2, actor-4)
flat(actor-4, Gaspard-5)
flat(actor-4, Ulliel-6)
</code></pre>

<p>While items like abbreviations are generally reversable, the determiner test suggested above doesnât quite work there, since the determiner seems to belong with the main item:</p>

<pre><code class="language-sdparse">The ABC ( Australian Broadcasting Corporation )
appos(ABC-2, Corporation-6)
</code></pre>

<p>While <code>appos</code> is normally between two nominals, there are a few cases where there is a relation with a clause, 
such as when describing facts or events for which <code>appos</code> still feels appropriate:</p>

<pre><code class="language-sdparse">This problem , that people could lower their tax rates by choosing to become corporations , might become acute .
appos(problem-2, lower-7)
</code></pre>

<p>In the rare cases of more than one appositive nominal, all nouns should be marked as modifying the first noun, rather than being chained:</p>

<pre><code class="language-sdparse">Sam , my brother , John 's cousin , arrived
appos(Sam-1, brother-4)
appos(Sam-1, cousin-8)
</code></pre>

<p>Note however that nested apposition cannot be completely excluded. It may occur in combination with coordination:</p>

<pre><code class="language-sdparse">You can choose between four subjects , language ( German or French ) , economy , technology and art .
appos(subjects, language)
conj(language, economy)
conj(language, technology)
conj(language, art)
cc(art, and)
appos(language, German)
conj(German, French)
cc(French, or)
</code></pre>

<p><code>appos</code> is also used to link key-value pairs in addresses, signature blocs, etc. (see also the <a href="">list</a> label):</p>

<pre><code class="language-sdparse">Steve Jones Phone: 555-9814 Email: jones@abc.edf
flat:name(Steve-1, Jones-2)
list(Steve-1, Phone:-3)
list(Steve-1, Email:-5)
appos(Phone:-3, 555-9814-4)
appos(Email:-5, jones@abc.edf-6)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/appos.md" target="#">edit appos</a></p>

<p><a id="al-u-dep/aux" class="al-dest"></a></p>
<h2><code>aux</code>: auxiliary</h2>

<p>An <code>aux</code> (auxiliary) of a clause is a function word associated with a verbal predicate that
expresses categories such as tense, mood, aspect, voice or evidentiality. It is often a verb 
(which may have non-auxiliary uses as well) but many languages have nonverbal TAME markers and these
are also treated as instances of <code>aux</code>.</p>

<p><strong>New from v2:</strong> Auxiliares used to construct the passive <a href="u-feat/Voice">voice</a> are now also labeled <code>aux</code>,
although we strongly encourage the use of the subtype <code>aux:pass</code> in language that have a grammaticalized (periphrastic)
passive.</p>

<pre><code class="language-sdparse">Reagan has died
aux(died-3, has-2)
</code></pre>

<pre><code class="language-sdparse">He should leave
aux(leave-3, should-2)
</code></pre>

<pre><code class="language-sdparse">Do you think that he will have left when we come ?
aux(think, Do)
aux(left, will)
aux(left, have)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/aux_.md" target="#">edit aux</a></p>

<p><a id="al-u-dep/case" class="al-dest"></a></p>
<h2><code>case</code>: case marking</h2>

<p>The <code>case</code> relation is used for any case-marking element which is treated as a separate syntactic word (including prepositions, postpositions, and clitic case markers). Case-marking elements are treated as dependents of the noun or clause they attach to or introduce. (Thus, contrary to SD, UD abandons treating a preposition as a mediator between a modified word and its object.) The <code>case</code> relation aims at providing a more uniform analysis of nominal elements, prepositions and case in morphologically rich languages: a nominal in an oblique case will receive the same dependency structure as a nominal introduced by an adposition.</p>

<pre><code class="language-sdparse">the Chair 's office
det(Chair-2, the-1)
nmod(office-4, Chair-2)
case(Chair-2, 's-3)
</code></pre>

<pre><code class="language-sdparse">the office of the Chair
det(office-2, the-1)
nmod(office-2, Chair-5)
case(Chair-5, of-3)
det(Chair-5, the-4)
</code></pre>

<p>French:</p>

<pre><code class="language-sdparse">le bureau du prÃ©sident \n the office of the_Chair
det(bureau, le)
nmod(bureau, prÃ©sident)
case(prÃ©sident, du)
</code></pre>

<p>Hebrew:</p>

<pre><code class="language-sdparse">hwa/PRON rah/VERB at/PART[Case=Acc] h/DET klb/NOUN \n he saw ACC the dog  
obj(rah-2, klb-5)
case(klb-5, at-3)
</code></pre>

<p>When case markers are morphemes, they are not divided off the noun as a separate case dependent,
but the noun as a whole is analyzed as <a href="">obl</a> (if dependent on a predicate) or <a href="">nmod</a> (if dependent on noun).
To overtly mark case,
<a href="../pos/index.html">POS tags</a> and
<a href="../feat/index.html">features</a>
are included in the representation as shown below on a Russian example
(put your mouse pointer over the words to see additional morphosyntactic features).</p>

<pre><code class="language-conllu"># I wrote the letter with a quill.
1   Ð¯         ja         PRON   _   Case=Nom|Number=Sing|Person=1|PronType=Prs        2   nsubj   _   I
2   Ð½Ð°Ð¿Ð¸ÑÐ°Ð»   napisat'   VERB   _   Gender=Masc|Number=Sing|VerbForm=Part|Voice=Act   0   root    _   wrote
3   Ð¿Ð¸ÑÑÐ¼Ð¾    pis'mo     NOUN   _   Case=Acc|Gender=Neut|Number=Sing                  2   obj    _   the-letter
4   Ð¿ÐµÑÐ¾Ð¼     pero       NOUN   _   Case=Ins|Gender=Neut|Number=Sing                  2   obl    _   with-a-quill
</code></pre>

<p>This treatment provides parallelism between different constructions
across and within languages. A good result is that we now have greater
parallelism between prepositional phrases and subordinate clauses,
which are often introduced by a preposition in some languages:</p>

<pre><code class="language-sdparse">Sue left after the rehearsal
nsubj(left-2, Sue-1)
obl(left-2, rehearsal-5)
det(rehearsal-5, the-4)
case(rehearsal-5, after-3)
</code></pre>

<pre><code class="language-sdparse">Sue left after we did
nsubj(left-2, Sue-1)
advcl(left-2, did-5)
mark(did-5, after-3)
nsubj(did-5, we-4)
</code></pre>

<p>We also obtain parallel constructions for</p>

<ul>
  <li>the possessive alternation</li>
</ul>

<pre><code class="language-sdparse">the Chair 's office
det(Chair-2, the-1)
nmod(office-4, Chair-2)
case(Chair-2, 's-3)
</code></pre>

<pre><code class="language-sdparse">the office of the Chair
det(office-2, the-1)
nmod(office-2, Chair-5)
case(Chair-5, of-3)
det(Chair-5, the-4)
</code></pre>

<ul>
  <li>variant forms with case, a preposition or a
postposition in Finnish</li>
</ul>

<pre><code class="language-sdparse">etsiÃ¤ ilman johtolankaa \n to_search without clue.PARTITIVE
obl(etsiÃ¤, johtolankaa)
case(johtolankaa, ilman)
</code></pre>

<pre><code class="language-sdparse">etsiÃ¤ taskulampun kanssa \n to_search torch.GENITIVE with
obl(etsiÃ¤, taskulampun)
case(taskulampun, kanssa)
</code></pre>

<pre><code class="language-sdparse">etsiÃ¤ johtolangatta \n to_search clue.ABESSIVE
obl(etsiÃ¤, johtolangatta)
</code></pre>

<ul>
  <li>the dative alternation where the prepositional construction gets a similar
analysis to the double object construction</li>
</ul>

<pre><code class="language-sdparse">give the children the toys
obj(give, toys)
iobj(give, children)
</code></pre>

<pre><code class="language-sdparse">give the toys to the children
obj(give, toys)
obl(give, children)
case(children, to)
</code></pre>

<pre><code class="language-conllu"># give the toys to the children
1     donner    donner   VERB   _   VerbForm=Inf               0   root   _   give
2     les       le       DET    _   Definite=Def|Number=Plur   3   det    _   the
3     jouets    jouet    NOUN   _   Gender=Masc|Number=Plur    1   obj   _   toys
4-5   aux       _        _      _   _                          _   _      _   _
4     Ã          Ã         ADP    _   _                          6   case   _   to
5     les       le       DET    _   Definite=Def|Number=Plur   6   det    _   the
6     enfants   enfant   NOUN   _   Gender=Masc|Number=Plur    1   obl   _   children
</code></pre>

<p>Another advantage of this new analysis is that it provides a treatment
of prepositional phrases that are predicative complements of âbeâ that is consistent with the treatment of nominal predicative
complements:</p>

<pre><code class="language-sdparse">Sue is in shape
nsubj(shape-4, Sue-1)
cop(shape-4, is-2)
case(shape-4, in-3)
</code></pre>

<p>When prepositions are stacked (that is, there is a sequence of prepositions), there are two possible analyses. If the sequence is a frozen combination with a specific meaning, then the best analysis is as <code>fixed</code>. An English example of this is <em>out of</em>:</p>

<pre><code class="language-sdparse">Out of all this , something good will come .
case(this-4, Out-1)
fixed(Out-1, of-2)
det(this-4, all-3)
obl(come, this-4)
</code></pre>

<p>However, if various combinations of prepositions can be used to express different meaning combinations or nuances, then  each preposition is independently analyzed as a case dependent. Examples of this in English include <em>up beside</em> (which can alternate with <em>down beside</em> or <em>up near</em>) or <em>except during</em> which can alternate with <em>as during</em> or <em>except after</em>:</p>

<pre><code class="language-sdparse">The cafe up beside the lookout
det(cafe-2, The-1)
case(lookout-6, up-3)
case(lookout-6, beside-4)
det(lookout-6, the-5)
nmod(cafe-2, lookout-6)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/case.md" target="#">edit case</a></p>

<p><a id="al-u-dep/cc" class="al-dest"></a></p>
<h2><code>cc</code>: coordinating conjunction</h2>

<!--For more on coordination, see the [conj]() relation.-->
<p>A <code>cc</code> is the relation between a conjunct and
a preceding <a href="../pos/CCONJ">coordinating conjunction</a>.
<!--(Note: different dependency grammars have different treatments of coordination.
We take the first conjunct as the head of the coordination.)--></p>

<pre><code class="language-sdparse">Bill is big and honest
conj(big, honest)
cc(honest, and)
</code></pre>

<p>A coordinating conjunction may also appear at the beginning of a
sentence. This is also called a <code>cc</code>, even though there is no preceding conjunct
(except implicitly or in a preceding sentence).</p>

<pre><code class="language-sdparse">And then we left .
cc(left, And)
</code></pre>

<div id="punct1" class="sd-parse">
We have apples , pears , oranges , and bananas .
obj(have, apples)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(bananas, and)
punct(pears, ,-4)
punct(oranges, ,-6)
punct(bananas, ,-8)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/cc.md" target="#">edit cc</a></p>

<p><a id="al-u-dep/ccomp" class="al-dest"></a></p>
<h2><code>ccomp</code>: clausal complement</h2>

<p>A clausal complement of a verb or adjective is a dependent clause 
which is a core argument. That is, it functions like an object of the verb, or
adjective.</p>

<pre><code class="language-sdparse">He says that you like to swim
ccomp(says, like)
mark(like, that)
</code></pre>

<pre><code class="language-sdparse">He says you like to swim
ccomp(says, like)
</code></pre>

<p>Such clausal complements may be finite or nonfinite. However, if the
subject of the clausal complement is controlled (that is, must be the same
as the higher subject or object, with no other possible interpretation)
the appropriate relation is <a href="">xcomp</a>.</p>

<pre><code class="language-sdparse">The boss said to start digging
ccomp(said, start)
mark(start, to)
</code></pre>

<pre><code class="language-sdparse">We started digging
xcomp(started, digging)
</code></pre>

<p>The key difference here is that, while it is possible to interpret the first
sentence to mean that the boss will not be doing any digging, in the second
sentence it is clear that the subject of <strong>digging</strong> can only be <strong>we</strong>. This is
what distinguishes <code>ccomp</code> and <code>xcomp</code>.</p>

<p>Additionally, <code>ccomp</code> is used with copulas in equational constructions involving full clauses.</p>

<pre><code class="language-sdparse">The important thing is to keep calm.
ccomp(is, keep)
nsubj(is, thing)
</code></pre>

<pre><code class="language-sdparse">The problem is that this has never been tried .
ccomp(is, tried)
nsubj(is, problem)
</code></pre>

<p>(In these cases, the copula is treated as a head to preserve the integrity of clause boundaries and prevent one predicate to
be assigned two subjects. This is not an optimal solution given the analysis of equational constructions involving nominals, where one of the nominals is treated as the head, but it is the preferred solution for now.)</p>

<p><em>Note:</em> In earlier versions of SD/USD, complement
clauses with nouns like <em>fact</em> or <em>report</em> were also analyzed as <code>ccomp</code>. 
However, we now analyze them as <a href="">acl</a>. Hence, <code>ccomp</code> does not appear in nominals.
This makes sense, since nominals normally do not take core arguments.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/ccomp.md" target="#">edit ccomp</a></p>

<p><a id="al-u-dep/clf" class="al-dest"></a></p>
<h2><code>clf</code>: classifier</h2>

<p>A <code>clf</code> (classifier) is a word which accompanies a noun in certain grammatical contexts. 
The most canonical use is numeral classifiers, where the word is used with a number for counting objects. 
A classifier generally reflects some kind of 
conceptual classification of nouns, based principally on features of their referents. 
Etymologically, classifiers are normally historically nouns, and the words may still also be used as independent nouns,
but in their classifier use they have scant semantics left.
In most cases, the most appropriate UPOS to give classifiers will still be NOUN, though you may wish to give the words a feature
indicating their special status as a classifier. (There is at present no Universal feature for classifiers, but <code>NounType=Clf</code>
might be apt.)
The <code>clf</code> function is intended for languages which have highly grammaticalized systems of classifiers.
The greatest density of such languages is in Asia.
As well as core classifiers, there are often also other words, sometimes called âmassifiersâ that are used in counting with
similar behavior to classifiers. These typically include words for containers (âcupâ, âboxâ) and units (âmonthâ, âinchâ),
such as Chinese è¢ âbagâ in ä¸è¢ç±³ [one bag rice] âa bag of riceâ.
In a classifier language, it is usually most appropriate to also analyze these words as classifiers.
Most other languages also count things with units, however, for these languages, such as English, <code>clf</code> is not used and rather
standard noun phrase relations are still used (despite there also being incipient grammaticalization in many cases, including English).
See the examples for English at the end.</p>

<p>Here are some examples from Mandarin/Putonghua Chinese:</p>

<ul>
  <li>ä¸ä¸ªå­¦ç (ä¸åå­¸ç) sÄn gÃ¨ xuÃ©shÄng = âthree studentsâ, literally âthree [human-classifier] studentâ</li>
  <li>ä¸æ£µæ  (ä¸æ£µæ¨¹) sÄn kÄ shÃ¹ = âthree treesâ, literally âthree [tree-classifier] treeâ</li>
  <li>ä¸åªé¸ (ä¸é»é³¥) sÄn zhÄ« niÇo = âthree birdsâ, literally âthree [bird-classifier] birdâ</li>
  <li>ä¸æ¡æ²³ (ä¸æ¢æ²³) sÄn tiÃ¡o hÃ© = âthree riversâ, literally âthree [long-wavy-classifier] riverâ</li>
</ul>

<p>Syntactically, the classifier groups with the numeral rather than the noun and we therefore treat
classifiers as functional dependents of numerals (or possessives) using the new <code>clf</code> relation. (This
is one of Greenbergâs universals and is true in almost all cases. 
A couple of exceptions are noted in Aikhenvald (2000: 105) <em>Classifiers</em>, OUP, but it is noticeable that in those languages
the putative head noun is in the genitive case.)</p>

<div class="sd-parse">
sÄn gÃ¨ xuÃ©shÄng \n three clf student
nummod(xuÃ©shÄng, sÄn)
clf(sÄn, gÃ¨)
</div>

<p>Classifier words also occur in various other constructions, and so it is important to distinguish the word in a particular
language from the universal classifier function proposed in UD. We go through here some further examples with Chinese classifiers.</p>

<p>No noun may appear with the number and classifier. 
In this case, the classifier takes the role of the missing noun, and we promote the classifier to be the head.
So æ è²· å© æ¬ âI am buying twoâ is regarded as âI am buying two [books-CLF]â.</p>

<div class="sd-parse">
æ è²· å© æ¬ \n I buy two CLF
obj(è²·, æ¬)
nummod(æ¬, å©)
</div>

<p>In some languages, including Chinese, a classifier can also appear without a number, and frequently then has some sort of
determinative function. We use the relation <code>det</code> for such uses of a classifier. For instance, in Cantonese âShe bought a/the bookâ:</p>

<div class="sd-parse">
ä½¢ è²· å æ¬ æ¸ \n keoi maai zo bun syu \n 3sg buy PERF CLF book
obj(è²·, æ¸)
det(æ¸, æ¬)
</div>

<p>For languages without highly grammaticalized classifier systems, standard nominal modification relationships are used
even when things are being counted in groups (with âmassifiersâ). For example, in English:</p>

<div class="sd-parse">
three cups of rolled oats
nummod(cups, three)
case(oats, of)
amod(oats, rolled)
nmod(cups, oats)
</div>

<div class="sd-parse">
three cups rolled oats
nummod(cups, three)
amod(oats, rolled)
nmod(cups, oats)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/clf.md" target="#">edit clf</a></p>

<p><a id="al-u-dep/compound" class="al-dest"></a></p>
<h2><code>compound</code>: compound</h2>

<p>The <code>compound</code> relation is one of three relations for multiword expressions (MWEs) (the other two being <code>fixed</code> and <code>flat</code>). It is used for</p>

<ul>
  <li>any kind of X<sup>0</sup> compounding: noun compounds (e.g., <em>phone book</em>), but also verb and
adjective compounds that are more common in other languages (such as Persian or Japanese light verb constructions).</li>
</ul>

<pre><code class="language-sdparse">Phone book
compound(book, Phone)
</code></pre>

<ul>
  <li>for particle verbs (with the subtype <code>compound:prt</code>):</li>
</ul>

<pre><code class="language-sdparse">put up
compound:prt(put, up)
</code></pre>

<ul>
  <li>for serial verbs (with the subtype <code>compound:svc</code>):</li>
</ul>

<pre><code class="language-sdparse">Musa bÃ© lÃ¡ Ã¨bi \n Musa came took knife
nsubj(bÃ©, Musa)
compound:svc(bÃ©, lÃ¡)
obj(bÃ©, Ã¨bi)
</code></pre>

<p>The <code>compound</code> relation (nor any subtype thereof) is not used to link an inherently reflexive verb with the reflexive morpheme, despite the similarity of this construction to particle verbs. The current UD guideline is to use an appropriate <a href="/2015-08-23-uppsala/clitics.html">subtype</a> of the <a href="">expl</a> relation.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/compound.md" target="#">edit compound</a></p>

<p><a id="al-u-dep/conj" class="al-dest"></a></p>
<h2><code>conj</code>: conjunct</h2>

<p>A conjunct is the relation between two elements connected by a
coordinating conjunction, such as <em>and, or,</em> etc.  We treat
conjunctions asymmetrically: The head of the relation is the first
conjunct and all the other conjuncts depend on it via the <code>conj</code> relation.</p>

<pre><code class="language-sdparse">Bill is big and honest
conj(big, honest)
</code></pre>

<div id="punct1" class="sd-parse">
We have apples , pears , oranges , and bananas .
obj(have, apples)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(bananas, and)
punct(pears, ,-4)
punct(oranges, ,-6)
punct(bananas, ,-8)
</div>

<p>Coordinated clauses are treated the same way as coordination of other constituent types:</p>

<pre><code class="language-sdparse">He came home , took a shower and immediately went to bed .
conj(came, took)
conj(came, went)
punct(took, ,-4)
cc(went, and)
</code></pre>

<p>Coordination may be <em>asyndetic,</em> which means that the coordinating conjunction is omitted.
Commas or other punctuation symbols will delimit the conjuncts in the typical case.
Asyndetic coordination may be more frequent in some languages, while in others, conjunction will appear between every two conjuncts <em>(John and Mary and Bill).</em></p>

<pre><code class="language-sdparse">Veni , vidi , vici .
conj(Veni, vidi)
conj(Veni, vici)
punct(vidi, ,-2)
punct(vici, ,-4)
</code></pre>

<h3 id="shared-dependents-and-effective-parents-in-coordination">Shared Dependents and Effective Parents in Coordination</h3>

<p>Note that the current basic annotation scheme cannot distinguish between a dependent of the first conjunct
and a shared dependent of the whole coordination:</p>

<pre><code class="language-sdparse">He met her at the station and kissed her .
conj(met, kissed)
nsubj(met, He)
</code></pre>

<p>vs.</p>

<pre><code class="language-sdparse">He met her at the station and she kissed him .
conj(met, kissed)
nsubj(met, He)
nsubj(kissed, she)
</code></pre>

<p>In contrast, the additional dependencies in the enhanced representation
can be used to encode the fact that in the first case, <em>he</em> is also subject of <em>kissed:</em></p>

<pre><code class="language-sdparse">He met her at the station and kissed her .
conj(met, kissed)
nsubj(met, He)
nsubj(kissed, He)
</code></pre>

<p>Furthermore, the enhanced representation can also capture the relation of each conjunct
to the parent of the coordination. Nevertheless, the effective parents can be found
algorithmically and showing them explicitly is for convenience only, while
the information about shared dependents is otherwise not available.</p>

<pre><code class="language-sdparse">I saw that he met her at the station and kissed her .
conj(met, kissed)
nsubj(met, he)
nsubj(kissed, he)
ccomp(saw, met)
ccomp(saw, kissed)
</code></pre>

<p>If a dependent is shared among conjuncts, the basic representation always links it to the
first conjunct (coordination head), while the enhanced representation shows all dependencies.
In the following example, relations that are only part of the enhanced representation are shown in red.</p>

<pre><code class="language-conllu"># visual-style 6 1 amod color:red
# visual-style 4 3 amod color:red
# visual-style 6 3 amod color:red
1 American   _ _ _ _ 4 amod 6:amod        _
2 and        _ _ _ _ 3 cc   _             _
3 British    _ _ _ _ 1 conj 4:amod|6:amod _
4 professors _ _ _ _ 0 root _             _
5 and        _ _ _ _ 6 cc   _             _
6 students   _ _ _ _ 4 conj 0:root        _
</code></pre>

<h3 id="nested-coordination">Nested Coordination</h3>

<p>Note further that the basic annotation scheme has only a limited capability to capture nested coordination
such as <em>apples and pears or oranges and lemons.</em>
Consider coordinations</p>

<ul>
  <li>A, B, C</li>
  <li>(A, B), C</li>
  <li>A, (B, C)</li>
</ul>

<p>The first two cases, i.e. (A, B, C) and ((A, B), C), lead to the same tree:</p>

<pre><code class="language-sdparse">A B C
conj(A, B)
conj(A, C)
</code></pre>

<p>Only the right-nesting case (A, (B, C)) can be distinguished because its tree is different:</p>

<pre><code class="language-sdparse">A B C
conj(B, C)
conj(A, B)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/conj.md" target="#">edit conj</a></p>

<p><a id="al-u-dep/cop" class="al-dest"></a></p>
<h2><code>cop</code>: copula</h2>

<p>A <code>cop</code> (copula) is the relation of a function word used to link a subject to a nonverbal predicate.
It is often a verb but nonverbal copulas are also frequent in the worldâs languages. The <code>cop</code> relation
should only be used for pure copulas that add at most TAME categories to the meaning of the predicate,
which means that most languages have at most one copula, and only when the nonverbal predicate is treated
as the head of the clause.</p>

<pre><code class="language-sdparse">Bill is honest
nsubj(honest, Bill)
cop(honest, is)
</code></pre>

<pre><code class="language-sdparse">Ivan is the best dancer
nsubj(dancer-5, Ivan-1)
cop(dancer-5, is-2)
det(dancer-5, the-3)
amod(dancer-5, best-4)
</code></pre>

<p>The copula <em>be</em> is not treated as the head of a clause, but rather the nonverbal predicate, as exemplified above.</p>

<p>Such an analysis is motivated by the fact that many languages often or always lack an overt copula in such
constructions, as in the the following Russian example:</p>

<pre><code class="language-sdparse">Ivan luÄÅ¡ij tancor \n Ivan best dancer
nsubj(tancor, Ivan)
amod(tancor, luÄÅ¡ij)
</code></pre>

<p>In informal English, this may also arise.</p>

<pre><code class="language-sdparse">Email usually free if you have Wifi.
nsubj(free, Email)
</code></pre>

<p>This analysis is adopted also when the predicate is a prepositional phrase, provided that the same copula
(or absence thereof) is used here, in which case the nominal part of the
prepositional phrase is the head of the clause.</p>

<pre><code class="language-sdparse">Sue is in shape
nsubj(shape, Sue)
cop(shape, is)
case(shape, in)
</code></pre>

<!--A parallel can also be drawn to so-called raising-to-object or small clause constructions in English.
Under the basic analysis proposed for SD, the predicate complement is
not linked to its subject argument, but in the enhanced representation
(see below), the linkage is then parallel to the treatment in a zero
copula language:

~~~ sdparse
I judge Ivan the best dancer
nsubj(judge-2, I-1)
obj(judge-2, Ivan-3)
xcomp(judge-2, dancer-6)
det(dancer-6, the-4)
amod(dancer-6, best-5)
nsubj(dancer-6, Ivan-3)
~~~
-->

<p>If the copula is accompanied by other verbal auxiliaries for tense, aspect, etc., then they are also given a flat structure, and taken as dependents of the lexical predicate:</p>

<pre><code class="language-sdparse">Sue has been helpful
nsubj(helpful, Sue)
cop(helpful, been)
aux(helpful, has)
</code></pre>

<p>The motivation for this choice is that this structure is parallel to the flat structure which we give to auxiliary verbs accompanying verbs. In particular, in languages such as English, it is often very difficult to decide whether to regard a participle as a verb or an adjective.  Perhaps the following sentence is such a case:</p>

<pre><code class="language-sdparse">The presence of troops will be destabilizing .
nsubj(destabilizing, presence)
cop(destabilizing, be)
aux(destabilizing, will)
</code></pre>

<p>While a part of speech has to be decided in such cases, it would be unfortunate if the choice of part of speech also changed the dependency structure. Note, however, that the exact distribution of the copula construction is subject to language-specific variation.</p>

<p>Finally, the <code>cop</code> relation is not used when the nonverbal predicate has the form of a clause, which typically occur in equational constructions like the following:</p>

<pre><code class="language-sdparse">The important thing is to keep calm .
ccomp(is, keep)
nsubj(is, thing)
</code></pre>

<pre><code class="language-sdparse">The problem is that this has never been tried .
ccomp(is, tried)
nsubj(is, problem)
</code></pre>

<p>If we took the predicate of the clause as the head, instead of the copula verb, it would have two subjects, which would be unworkable. Examples like the above <em>could</em> be analyzed reversed with the initial noun phrase as the predicate, but in addition to this seeming undesirable, it would fail to be a solution if there were a clause on both sides of <em>be</em>, such as in: <em>(For us) to not attempt to solve the problem is (for us) to acknowledge defeat</em>. (Note: This solution is not perfect and refining it is a possible direction for the future.)</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/cop.md" target="#">edit cop</a></p>

<p><a id="al-u-dep/csubj" class="al-dest"></a></p>
<h2><code>csubj</code>: clausal subject</h2>

<p>A clausal subject is a clausal syntactic subject of a clause, i.e.,
the subject is itself a clause. The governor of this relation might
not always be a verb: when the verb is a copular verb, the root of the
clause is the complement of the copular verb. The dependent is the main lexical verb or other 
predicate of the subject clause. In the following
examples, <em>what she said</em> (that is, <em>said</em>) is the clausal subject of <em>makes</em> and <em>interesting</em>, respectively.</p>

<p><strong>New from v2:</strong> The <code>csubj</code> relation is also used for the clausal subject of a passive verb or verb group. For languages
that have a grammaticalized passive transformation, it is strongly recommended to use the subtype <code>csubj:pass</code> in 
such cases.</p>

<pre><code class="language-sdparse">What she said makes sense
csubj(makes, said)
</code></pre>

<pre><code class="language-sdparse">What she said is interesting
csubj(interesting, said)
</code></pre>

<pre><code class="language-sdparse">What she said was well received
csubj:pass(received, said)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/csubj.md" target="#">edit csubj</a></p>

<p><a id="al-u-dep/dep" class="al-dest"></a></p>
<h2><code>dep</code>: unspecified dependency</h2>

<p>A dependency can be labeled as <code>dep</code> when it is impossible to determine a more precise relation.
This may be because of a weird grammatical construction, or a limitation in conversion or parsing software.
The use of <code>dep</code> should be avoided as much as possible.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/dep.md" target="#">edit dep</a></p>

<p><a id="al-u-dep/det" class="al-dest"></a></p>
<h2><code>det</code>: determiner</h2>

<p>The relation determiner (<code>det</code>) holds between a nominal head and its
<a href="u-pos/DET">determiner</a>. Most commonly, a word of POS <code>DET</code> will have the relation <code>det</code> and vice versa. The known exceptions at present are:</p>

<ul>
  <li>In some of the datasets, a possessive determiner like [en] <em>my</em> is currently given the POS tag <code>DET</code> but the relation <a href="">nmod</a>, so that it is parallel with other possessive constructions. This is not yet completely parallel across languages; in some languages, it is much more clear than in English how possessive determiners relate to adjectives, and the <code>nmod</code> relation is out of question.</li>
</ul>

<pre><code class="language-sdparse">The man is here
det(man, The)
</code></pre>

<pre><code class="language-sdparse">Which book do you prefer ?
det(book, Which)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/det.md" target="#">edit det</a></p>

<p><a id="al-u-dep/discourse" class="al-dest"></a></p>
<h2><code>discourse</code>: discourse element</h2>

<p>This is used for <a href="u-pos/INTJ">interjections</a> and other discourse <a href="u-pos/PART">particles</a> and
elements (which are not clearly linked to the structure of the
sentence, except in an expressive way). We generally follow the
guidelines of what the Penn Treebanks count as an INTJ.  They define
this to include: interjections (<em>oh</em>, <em>uh-huh</em>, <em>Welcome</em>), fillers
(<em>um</em>, <em>ah</em>), and discourse markers (<em>well</em>, <em>like</em>, <em>actually</em>, but
not <em>you know</em>).</p>

<p>These discourse elements are attached to the head of the most relevant nearby clause, 
which is why they are grouped with non-core clausal dependents even though they are normally
not dependents of the predicates as such.</p>

<pre><code class="language-sdparse">Iguazu is in Argentina :)
discourse(is-2, :)-5)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/discourse.md" target="#">edit discourse</a></p>

<p><a id="al-u-dep/dislocated" class="al-dest"></a></p>
<h2><code>dislocated</code>: dislocated elements</h2>

<p>The <code>dislocated</code> relation is used for fronted or postposed elements
that do not fulfill the usual core grammatical relations of a
sentence. These elements often appear to be in the periphery of the sentence, and may be separated off with a comma intonation.</p>

<p>It is used for fronted elements that introduce the topic of a sentence, as in the following Japanese and Greek examples. The dislocated element attaches to the head of the clause to which it belongs:</p>

<pre><code class="language-sdparse">è±¡ ã¯ é¼» ã é·ã \n zoo wa hana ga naga-i \n elephant TOPIC nose SUBJ long-PRES
dislocated(é·ã-5, è±¡-1)
</code></pre>

<pre><code class="language-sdparse">to jani ton kserume poli kala \n the John-Acc him know-1pl very well 
dislocated(kserume, jani)
</code></pre>

<p>However, it would not be used for a topic-marked noun that is also the subject of the sentence; this would be an <a href="">nsubj</a>.</p>

<p>It is also used for postposed elements. The dislocated elements attach to the same governor as the dependent that they double for. Right dislocated elements are frequent in spoken languages. French and Greek examples follow.</p>

<pre><code class="language-sdparse">Il faut pas la manger , la plasticine \n It must not it eat , the playdough
obj(manger, la-4)
dislocated(manger, plasticine)
obj(eat, it-13)
dislocated(eat, playdough)
</code></pre>

<pre><code class="language-sdparse">ton kserume oli mas edho poli kala, to jani 
dislocated(kserume, jani)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/dislocated.md" target="#">edit dislocated</a></p>

<p><a id="al-u-dep/expl" class="al-dest"></a></p>
<h2><code>expl</code>: expletive</h2>

<p>This relation captures expletive or pleonastic nominals. These are nominals that appear in an argument position of a predicate but which do not themselves satisfy any of the semantic roles of the predicate. The main predicate of the clause (the verb or predicate adjective or noun) is the governor. In English, this is the case for some uses of <em>it</em> and <em>there</em>: the existential <em>there</em>, and <em>it</em> when used in extraposition constructions.  (Note that both <em>it</em> and <em>there</em> also have non-expletive uses.)</p>

<pre><code class="language-sdparse">There is a ghost in the room
expl(is, There)
</code></pre>

<pre><code class="language-sdparse">It is clear that we should decline .
expl(clear, It)
</code></pre>

<p>Some languages do not have expletives of the English sort, including most languages with free pro-drop (the ability to use zero anaphora rather than overt pronouns). In languages with expletives of this sort, they can be positioned where normally a core argument appears: the subject and direct object (and even indirect object) slots, as in the examples below. Note that in the analysis of these examples, we treat the postposed subject or clausal argument as a regular core argument, and mark the expletive with <code>expl</code>.</p>

<pre><code class="language-sdparse">There is a ghost in the room
expl(is, There)
nsubj(is, ghost)
obl(is, room)
</code></pre>

<pre><code class="language-sdparse">I believe there to be a ghost in the room
nsubj(believe, I)
expl(believe, there)
xcomp(believe, be)
nsubj(be, ghost)
obl(be, room)
</code></pre>

<pre><code class="language-sdparse">It is clear that we should decline .
expl(clear, It)
csubj(clear, decline)
</code></pre>

<pre><code class="language-sdparse">That we should decline is clear .
csubj(clear, decline)
</code></pre>

<pre><code class="language-sdparse">I mentioned it to Mary that Sue is leaving
nsubj(mentioned, I)
expl(mentioned, it)
obl(mentioned, Mary)
ccomp(mentioned, leaving)
</code></pre>

<p>A second, related, use of the <code>expl</code> relation is for cases of true clitic doubling.  For languages in which clitics and lexical nominals are ususally in complementary distribution â languages, such as French, which obey âKayneâs generalizationâ â then whichever of a clitic or a lexical nominal occurs will get the appropriate role, such as <a href="">obj</a> or <a href="">iobj</a>. In such languages, when doubling does occur, such as in spoken French, the right analysis is to regard the lexical nominal as <a href="">dislocated</a> (see the examples there). As such, the analysis will be the same as when a noun phrase doubles another noun phrase or a regular pronoun that fills a nominal argument position. However, other languages, such as Greek and Bulgarian, standardly allow doubling of a lexical nominal and a pronominal clitic, with the former still appearing in its regular role as an argument of the predicate. In these cases, if only one of the lexical nominal and the clitic appear in a clause, then whichever appears will be given the grammatical role of <a href="">obj</a>, <a href="">iobj</a>, etc. â parallel to the treatment of lexical nominals and pronouns in other languages, modulo the clitic pronoun having a different position in the sentence.  However, if both occur, the lexical nominal will be given the grammatical role of <a href="">obj</a>, <a href="">iobj</a>, etc., and the clitic will be treated as a pronominal copy, which does not receive its own semantic role, and hence will get the role <code>expl</code>. Modulo the different word order, this is fairly parallel to the treatment of <em>it</em> and <em>there</em> in English mentioned above, where another phrase satisfies the semantic role of the predicate. Examples from Greek and Bulgarian follow:</p>

<pre><code class="language-sdparse">Î¤Î·Ï ÏÎ¿Î½ Î­Î´ÏÏÎµ ÏÎ·Ï ÎÎ±Î¯ÏÎ·Ï ÏÎ¿Î½ Î±Î½Î±ÏÏÎ®ÏÎ± \n PRON.Fem.Gen PRON.Masc.Acc gave ART.Fem.Gen Keti.Gen ART.Masc.Acc lighter.Acc
expl(Î­Î´ÏÏÎµ, Î¤Î·Ï-1)
iobj(Î­Î´ÏÏÎµ, ÎÎ±Î¯ÏÎ·Ï)
det(ÎÎ±Î¯ÏÎ·Ï, ÏÎ·Ï-4)
expl(Î­Î´ÏÏÎµ, ÏÎ¿Î½-2)
obj(Î­Î´ÏÏÎµ, Î±Î½Î±ÏÏÎ®ÏÎ±)
det(Î±Î½Î±ÏÏÎ®ÏÎ±, ÏÎ¿Î½-6)
</code></pre>

<pre><code class="language-sdparse">Marija mu izprati pismo na rabotnika \n Maria 3.S.M.IO sent letter to the.worker
expl(izprati, mu)
obj(izprati, pismo)
iobj(izprati, rabotnika)
case(rabotnika, na)
</code></pre>

<p>The expletive relation is also used for reflexive pronouns (see the feature <a href="">u-feat/Reflex</a>)
attached to inherently reflexive verbs, i.e. verbs that cannot occur without the reflexive
pronoun and thus the pronoun does not play the role of a normal object
(otherwise it would be possible to substitute it with an irreflexive pronoun or other nominal).
A Czech example:</p>

<pre><code class="language-sdparse">Martin se bojÃ­ zvÃ­Åat . \n Martin REFLEX fears animals .
expl(bojÃ­, se)
expl(fears, REFLEX)
</code></pre>

<p>Further general discussion of expletives can be found in Postal, P. M., and G. K. Pullum (1988) âExpletive Noun Phrases in Subcategorized Positions,â <em>Linguistic Inquiry</em> 19(4): 635â670. The status of clitic doubling, and arguments for the lexical nominal being an argument with the clitic a kind of pronominal copy, appear inter alia in Boris Harizanov (2014) <a href="http://stanford.edu/~bharizan/pdfs/Harizanov_2014_NLLT.pdf">Clitic doubling at the syntax-morphology interface: A-movement and morphological merger in Bulgarian</a>. <em>Natural Language and Linguistic Theory</em>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/expl.md" target="#">edit expl</a></p>

<p><a id="al-u-dep/fixed" class="al-dest"></a></p>
<h2><code>fixed</code>: fixed multiword expression</h2>

<p>The <code>fixed</code> relation is one of the three relations for multiword expressions (MWEs)
(the other two being <a href="">flat</a> and <a href="">compound</a>). 
It is used for certain fixed grammaticized expressions that behave
like function words or short adverbials.</p>

<p><strong>New from v2:</strong> The <code>fixed</code> relation replaces the old <code>fixed</code> relation to prevent misunderstanding regarding its scope.</p>

<p>The scope of <code>fixed</code> MWEs corresponds roughly to the <em>fixed
expressions</em> category of
<a href="http://lingo.stanford.edu/pubs/WP-2001-03.pdf">Sag et al.</a>
and excludes any semi-fixed or flexible MWEs.</p>

<p>Fixed MWEs are annotated in a flat structure, where all subsequent words in the expression 
are attached to the first one using the <code>fixed</code> label. The assumption is that these expressions
do not have any internal syntactic structure (except from a historical perspective) and that the
structural annotation is in principle arbitrary. In practice, however, it is highly desirable to use
a consistent annotation of all fixed MWEs in all languages.</p>

<pre><code class="language-sdparse">I like dogs as well as cats
fixed(as-4, well-5)
fixed(as-4, as-6)
</code></pre>

<pre><code class="language-sdparse">He cried because of you
fixed(because, of)
</code></pre>

<pre><code class="language-sdparse">Je prÃ©fÃ¨re prendre un dessert plutÃ´t qu' une entrÃ©e \n I prefer getting a dessert rather than an appetizer
fixed(plutÃ´t, qu')
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/fixed.md" target="#">edit fixed</a></p>

<p><a id="al-u-dep/flat" class="al-dest"></a></p>
<h2><code>flat</code>: flat multiword expression</h2>

<p>The <code>flat</code> relation is one of three relations for multiword expressions multiword expressions (MWEs) in UD 
(the other two being <a href="">fixed</a> and <a href="">compound</a>). It is used for exocentric (headless) semi-fixed MWEs like
names (<em>Hillary Rodham Clinton</em>) and dates (<em>24 December</em>). It contrasts with <a href="">fixed</a>, which applies to
completely fixed grammaticized (function word-like) MWEs (like <em>in spite of</em>), and with <a href="">compound</a>, which applies to
endocentric (headed) MWEs (like <em>apple pie</em>).</p>

<p>Flat MWEs are annotated with a flat structure, where all subsequent words in the expression are attached to the 
first one using the <code>flat</code> label. The assumption is that these expressions do not have any internal syntactic structure 
and that the structural annotation is in principle arbitrary. In practice, however, it is highly desirable to use 
a consistent annotation of all flat MWEs in all languages.</p>

<p>Below we describe some of the most common uses of <a href="">flat</a> across languages. Note that semantically
equivalent expressions in different languages (or even in the same language) may require a different analysis if sometimes
there is and sometimes there is not a regular compositional syntactic structure.</p>

<h2 id="names">Names</h2>

<p>In many languages, there are multiword proper names with no clear internal syntactic structure and no clear 
evidence that one of the words is the syntactic head. Such names are annotated using the <code>flat</code> relation, 
with the optional subtype <code>flat:name</code>.</p>

<pre><code class="language-sdparse">Hilary Rodham Clinton
flat(Hilary, Rodham)
flat(Hilary, Clinton)
</code></pre>

<pre><code class="language-sdparse">Carl XVI Gustaf
flat(Carl-1, Gustaf-3)
flat(Carl-1, XVI-2)
</code></pre>

<pre><code class="language-sdparse">New York
flat(New, York)
</code></pre>

<p>Titles/honorifics are also analyzed using the <code>flat</code> relation. Note that some titles are complex
and have their own internal syntactic structure. Such structure is shown with regular relations embedded under <code>flat</code>:</p>

<pre><code class="language-sdparse">Mr. Smith
flat(Mr., Smith)
</code></pre>

<pre><code class="language-sdparse">President Obama
flat(President, Obama)
</code></pre>

<pre><code class="language-sdparse">French actor Gaspard Ulliel
amod(actor-2, French-1)
flat(actor-2, Gaspard-3)
flat(actor-2, Ulliel-4)
</code></pre>

<pre><code class="language-sdparse">MilliardÃ¤r Ross Perot \n billionaire Ross Perot
flat(MilliardÃ¤r-1, Ross-2)
flat(MilliardÃ¤r-1, Perot-3)
</code></pre>

<p>However if the two halves of a descriptive title and a name appear to be two separate nominals, 
then analysis with <code>flat</code> is not appropriate, and <a href="">u-dep/appos</a> is appropriate. These cases are often set off by
punctuation, such as a comma, but no punctuation may appear in more informal text. 
You can generally test for such examples by asking if the two halves can be reversed; if they can, it is probably an <code>appos</code>; 
see the examples there.</p>

<p>In contrast to the above, names that have a regular syntactic structure, like <em>The Lord of the Rings</em> and <em>Captured By
Aliens</em>, should be annotated with regular syntactic relations.</p>

<pre><code class="language-sdparse">The Lord of the Rings
det(Lord, The)
nmod(Lord, Rings)
case(Rings, of)
det(Rings, the)
</code></pre>

<pre><code class="language-sdparse">The king of Sweden
det(king-2, The-1)
nmod(king-2, Sweden-4)
case(Sweden-4, of-3)
</code></pre>

<p>For organization names with clear syntactic modification structure, the dependencies should 
also reflect the syntactic modification structure using regular syntactic relations, as in:</p>

<pre><code class="language-sdparse">Natural Resources Conservation Service
amod(Resources-2, Natural-1)
compound(Conservation-3, Resources-2)
compound(Service-4, Conservation-3)
</code></pre>

<p>In addition, regular syntactic relations are used: (i) for a modifying determiner or similar function word and (ii) to connect 
together the words of a description or name which involve embedded prepositional phrases, sentences, etc.,
when these relations are (i) recognized in the language being annotated (i.e., the analyses below are for
French, German, and Spanish, not English) and (ii) deemed not to be grammaticalized to the extent that the original role
of the function words has been lost.</p>

<pre><code class="language-sdparse">Le Japon
det(Japon-2, Le-1)
</code></pre>

<pre><code class="language-sdparse">Ludwig van Beethoven
case(Beethoven, van)
nmod(Ludwig, Beethoven)
</code></pre>

<pre><code class="language-sdparse">Miguel de Cervantes y Saavedra
conj(Cervantes, Saavedra)
cc(Saavedra, y)
case(Cervantes, de)
nmod(Miguel, Cervantes)
</code></pre>

<pre><code class="language-sdparse">RÃ­o de la Plata
case(Plata-4, de-2)
det(Plata-4, la-3)
nmod(RÃ­o-1, Plata-4)
</code></pre>

<p>The above analyses of <em>Ludwig van Beethoven</em> and <em>Miguel de Cervantes y Saavedra</em> assume that <em>van</em> resp. <em>de</em> are prepositions.
This is true in the languages of the namesâ origin, but it can be expected to change when the name is used in foreign text 
or when sufficient grammaticalization has taken place. For example,
when names like this are annotated in English, the appropriate analysis is as a <code>flat</code> name:</p>

<pre><code class="language-sdparse">Ludwig van Beethoven was a famous German composer .
flat(Ludwig, van)
flat(Ludwig, Beethoven)
det(composer, a)
amod(composer, famous)
amod(composer, German)
cop(composer, was)
nsubj(composer, Ludwig)
punct(composer, .)
</code></pre>

<pre><code class="language-sdparse">RÃ­o de la Plata
flat(RÃ­o-1, de-2)
flat(RÃ­o-1, la-3)
flat(RÃ­o-1, Plata-4)
</code></pre>

<pre><code class="language-sdparse">Al Arabiya is a Saudi-owned news organization
flat(Al-1, Arabiya-2)
nsubj(organization-7, Al-1)
</code></pre>

<p>And in Modern German or French, these prepositions have generally just become a fossilized part of a family name 
and regularly appear without the given name. Again, here, analysis as <code>flat</code> seems correct:</p>

<pre><code class="language-sdparse">Von Hohenlohe gewann das Rennen . \n Von Hohenlohe won the race .
flat(Von-1, Hohenlohe-2)
nsubj(gewann-3, Von-1)
</code></pre>

<p>In the case of proper entities named after people, e.g. <em>Leland Stanford Jr. University</em>, the <code>flat</code> relation 
should only be used inside the person name, with the rest of the construction analyzed compositionally using 
normal syntactic relations:</p>

<pre><code class="language-sdparse">Leland Stanford Jr. University
compound(Leland-1, University-4)
flat(Leland-1, Stanford-2)
flat(Leland-1, Jr.-3)
</code></pre>

<h3 id="some-further-notes-on-relations-for-names">Some further notes on relations for names</h3>

<p><em>This paragraph briefly records some of the arguments that have been made in the past on relations for name structure. It is an issue over which there has historically been variation and about which there is some continuing debate.</em> Examples like 
<em>French actor Gaspard Ulliel:</em> Some treebanks have used <code>nmod</code> for titles and honorifics like <em>Mr.</em> or <em>French actor</em>. Most people think this is inappropriate, since an <code>nmod</code> dependent should be a full phrase, which will typically take its own case as a modifier in a cased language. In contrast, these titles seem to be part of the same phrase as the name that follows them; they show case agreement concord in a cased language. Some grammatical traditions, descending from Latin, call <em>French actor</em> in such cases a âfixed (or close) appositionâ and take the name as the head. UD has restricted the <code>appos</code> relation to following appositives (corresponding to âloose (or wide) appositionâ in the Latin tradition). The relation <code>appos</code> is only used when you have two full nominals, typically joined loosely, and often separated by a punctuation mark like a comma. So <code>appos</code> is not correct for these cases. Sometimes the relation <code>compound</code> has been used, but this does not seem right. It implies headedness, and titles do not usually behave like compounds: in German, they are not joined to the following words, as compounds are normally joined in German, and they appear at the beginning of names in both German and Hebrew, even though German compounds are head last and Hebrew compounds are head first. So <code>compound</code> does not seem appropriate either. Some UDv1 treebanks used <code>flat</code> for honorifics like <em>Mr.</em>, although some felt that was wrong and <code>flat</code> should be restricted to joining the proper nouns of multi-word names. In UDv2, <code>flat</code> was removed and replaced by <code>flat</code>, which allowed a broader notion of a chunk of unheaded material. In the UDv2 guidelines, cases of both titles and honorifics are joined to names with <code>flat</code>.</p>

<h2 id="dates-and-complex-numerals">Dates and Complex Numerals</h2>

<p>Date expressions come in many shapes and forms across languages. In some cases, they have a very clear syntactic
structure, as in <em>the 4th of July</em>, and should be annotated with regular dependency relations. In other cases, they
have a flat structure with no clearly discernible head, as in <em>1 December 2016</em>, in which case the <code>flat</code> relation 
should be used.</p>

<pre><code class="language-sdparse">the 4th of July
det(4th, the)
nmod(4th, July)
case(July, of)
</code></pre>

<pre><code class="language-sdparse">1 December 2016
flat(1, December)
flat(1, 2016)
</code></pre>

<p>The <code>flat</code> relation can also be used for other numerals and other numerical expressions that lack phrasal structure.</p>

<pre><code class="language-sdparse">four thousand
flat(four, thousand)
</code></pre>

<h2 id="foreign-phrases">Foreign Phrases</h2>

<p>The <code>flat</code> relation, with the optional subtype <code>flat:foreign</code> should also be used when a foreign phrase
cannot be given a compositional analysis. In this case, it replaces the <code>foreign</code> relation, which was used
in v1 but is no longer part of the relation taxonomy.</p>

<pre><code class="language-sdparse">And then she went : gjiko frac zen .
parataxis(went, gjiko)
flat(gjiko, frac)
flat(gjiko, zen)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/flat.md" target="#">edit flat</a></p>

<p><a id="al-u-dep/goeswith" class="al-dest"></a></p>
<h2><code>goeswith</code>: goes with</h2>

<p>This relation links two or more parts of a word that are separated in text that is not well edited.
These parts should be written together as one word according to the ortographic rules of a given language.
The head is always the first part, the other parts are attached to it with the <code>goeswith</code> relation
(for consistency, similarly as in <a href="">flat</a>, <a href="">fixed</a> and <a href="">conj</a>).
Note that only the last part may be annotated with <code>SpaceAfter=No</code>.</p>

<pre><code class="language-sdparse">They come here with out legal permission
goeswith(with-4, out-5)
</code></pre>

<pre><code class="language-sdparse">never the less/[SpaceAfter=No] ,
goeswith(never, the)
goeswith(never, less)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/goeswith.md" target="#">edit goeswith</a></p>

<p><a id="al-u-dep/iobj" class="al-dest"></a></p>
<h2><code>iobj</code>: indirect object</h2>

<p>The indirect object of a verb is any nominal phrase that is a core
argument of the verb but is not its subject or (direct) <a href="obj">object</a>.
The prototypical example is the recipient of ditransitive verbs of
exchange:</p>

<pre><code class="language-sdparse">She gave me a raise
iobj(gave, me)
</code></pre>

<p>However, many languages allow other semantic roles as additional objects. The most common case is allowing benefactives, but some languages allow other roles. Examples include instruments, such as in the Kinyarwanda example below, or comitatives. At the other extreme, some languages lack all indirect objects.</p>

<pre><code class="language-sdparse">UmukoÃ³bwa a-ra-andik-iish-a Ã­bÃ¡rÃºwa Ã­kÃ¡rÃ¡mu \n girl 1-PRS-write-APPL-ASP letter pen
obj(a-ra-andik-iish-a, Ã­bÃ¡rÃºwa)
iobj(a-ra-andik-iish-a, Ã­kÃ¡rÃ¡mu)
</code></pre>

<p>In languages distinguishing morphological <a href="u-feat/Case">cases</a>, the indirect object will often be marked by the dative case. However, verb valency may occasionally dictate that the direct object is in dative, or that the indirect objects shall take various other forms.</p>

<p>In the following Czech example, the verb takes two arguments, both are nouns in the accusative case. One of them is direct object (patient), the other is indirect (addressee). It is parallel to how the English translation would be annotated (where there is no morphological case marking) and also to verbs of giving (consider a similar sentence, <em>he gave my daughter a class of maths</em>).</p>

<pre><code class="language-sdparse">On uÄÃ­ mou dceru matematiku . \n He teaches my daughter.Acc maths.Acc .
obj(uÄÃ­, matematiku)
iobj(uÄÃ­, dceru)
obj(teaches, maths.Acc)
iobj(teaches, daughter.Acc)
</code></pre>

<p>In general, if there is just one object, it should be labeled
<a href="">obj</a>, regardless of the morphological case or semantic role. For example, in English, <em>teach</em> can take either the subject matter or the recipient as the only object, and in both cases it would be analyzed as the <a href="">obj</a>:</p>

<pre><code class="language-sdparse">She teaches introductory logic
obj(teaches, logic)
</code></pre>

<pre><code class="language-sdparse">She teaches the first-year students
obj(teaches, students)
</code></pre>

<p>This is consistent with the analysis of Huddleston and Pullum (2002) âThe Cambridge Grammar of the English Languageâ,
chapter 4 section 4 (p. 251).  As they note, it is no different to the same semantic role being sometimes the subject
and sometimes the object in intransitive/transitive alternations.</p>

<!--The one exception is when there is a clausal complement.
Then the clausal complement is regarded as a âclausal objectâ and an object nominal will be an iobj, parallel to
the simple ditransitive case:

~~~ sdparse
She told the students that they needed to study this evening
iobj(told, students)
ccomp(told, needed)
~~~

~~~ sdparse
She told the students the plan
iobj(told, students)
obj(told, plan)
~~~

If there are two or
more objects, one of them should be [obj]() and the others should be
`iobj`. In such cases it is necessary to decide what is the
most directly affected object _(patient)._ If possible,
language-specific documentation should help identify direct and
indirect objects.
-->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/iobj.md" target="#">edit iobj</a></p>

<p><a id="al-u-dep/list" class="al-dest"></a></p>
<h2><code>list</code>: list</h2>

<p>The <code>list</code> relation is used for chains of comparable items. In lists with more than two items, all items of the list should modify the first one. Informal and web text often contains passages which are meant to be interpreted as lists but are parsed as single sentences. Email signatures often contain these structures, in the form of contact information: the different contact information items are labeled as <code>list</code>; the key-value pair relations are labeled as <a href="">appos</a>.</p>

<pre><code class="language-sdparse">Steve Jones Phone: 555-9814 Email: jones@abc.edf
flat:name(Steve-1, Jones-2)
list(Steve-1, Phone:-3)
list(Steve-1, Email:-5)
appos(Phone:-3, 555-9814-4)
appos(Email:-5, jones@abc.edf-6)
</code></pre>

<p>Another place where <code>list</code> has been used is for a sequence of attributes or descriptive terms used as the title line of a review (such as product or restaurant reviews, etc.:</p>

<pre><code class="language-sdparse">Long Lines , Silly Rules , Rude Staff , Ok Food
list(Lines, Rules)
list(Lines, Staff)
list(Lines, Food)
</code></pre>

<p>However, <code>list</code> should not be over-used. If a construction can be easily analyzed using the grammatical relations of standard sentences, such as when there is overt coordination, then it should be analyzed with these more standard relations, even if it is laid out as a list typographically.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/list.md" target="#">edit list</a></p>

<p><a id="al-u-dep/mark" class="al-dest"></a></p>
<h2><code>mark</code>: marker</h2>

<p>A marker is the word introducing a finite clause subordinate to
another clause. For a <a href="ccomp">complement clause</a>, this is words like [en] <em>that</em>
or <em>whether.</em> For an <a href="advcl">adverbial clause</a>, the marker is typically a
<a href="../pos/SCONJ">subordinating conjunction</a> like [en] <em>while</em> or <em>although.</em> The mark is a dependent of the
subordinate clause head. In a relative clause, it is a normally uninflected word, which simply introduces a relative clause, such as [he] Å¡e. (In this last use, one needs to distinguish between relative clause markers, which are <code>mark</code> from relative pronouns, which fill a regular verbal argument or modifier grammatical relation.</p>

<pre><code class="language-sdparse">Forces engaged in fighting after insurgents attacked
mark(attacked, after)
</code></pre>

<pre><code class="language-sdparse">He says that you like to swim
mark(swim, that)
</code></pre>

<pre><code class="language-sdparse">Er kam wieder , um das Werk zu Ende zu bringen \n He came again , so-that the work to end to bring
mark(bringen, um)
mark(bringen, zu-10)
mark(bring, so-that)
mark(bring, to-22)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/mark.md" target="#">edit mark</a></p>

<p><a id="al-u-dep/nmod" class="al-dest"></a></p>
<h2><code>nmod</code>: nominal modifier</h2>

<p>The <code>nmod</code> relation is used for nominal dependents of another noun or noun phrase and functionally corresponds to
an attribute, or genitive complement.</p>

<p><strong>New from v2:</strong> The <code>nmod</code> relation was previously used also for nominal dependents of verbs, adjectives, and adverbs. The latter are now covered by the new <a href="">obl</a> relation.</p>

<p>In conjunction with the <a href="">case</a> relation, <code>nmod</code> provides a uniform analysis for the possessive alternation (with the option of a subtype like <code>nmod:poss</code> to distinguish non-adpositional case):</p>

<pre><code class="language-sdparse">the office of the Chair
det(office-2, the-1)
nmod(office-2, Chair-5)
case(Chair-5, of-3)
det(Chair-5, the-4)
</code></pre>

<pre><code class="language-sdparse">the Chair 's office
det(Chair-2, the-1)
nmod:poss(office-4, Chair-2)
case(Chair-2, 's-3)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/nmod.md" target="#">edit nmod</a></p>

<p><a id="al-u-dep/nsubj" class="al-dest"></a></p>
<h2><code>nsubj</code>: nominal subject</h2>

<p>A nominal subject (<code>nsubj</code>) is a nominal which is the syntactic subject and the proto-agent of a clause.
That is, it is in the position that passes typical grammatical test for subjecthood, and this argument is the more agentive,
the do-er, or the proto-agent of the clause. This nominal may be headed by a noun, 
or it may be a pronoun or relative pronoun or, in ellipsis contexts, other things such as an adjective.</p>

<p><strong>New from v2:</strong> The <code>nsubj</code> relation is also used for the nominal subject of a passive verb or verb group, even
though the subject is then not typically the proto-agent argument due to valency changing operations. For languages
that have a grammaticalized passive transformation, it is strongly recommended to use the subtype <code>nsubj:pass</code> in 
such cases.</p>

<p>The governor of the <code>nsubj</code> relation might not always be a verb: when
the verb is a copular verb, the root of the clause is the complement
of the copular verb, which can be an adjective or noun, including a noun marked by a preposition,
as in the examples below.</p>

<p>The <code>nsubj</code> role is only applied to semantic arguments of a predicate.
When there is an empty argument in a grammatical subject position (sometimes called a pleonastic or expletive),
it is labeled as <a href="">expl</a>. If there is then a displaced subject
in the clause, as in the English existential <em>there</em> construction, it will be labeled as <code>nsubj</code>.)</p>

<pre><code class="language-sdparse">Clinton defeated Dole
nsubj(defeated, Clinton)
</code></pre>

<pre><code class="language-sdparse">Dole was defeated by Clinton
nsubj:pass(defeated, Dole)
</code></pre>

<pre><code class="language-sdparse">The car is red .
nsubj(red, car)
</code></pre>

<pre><code class="language-sdparse">Sue is a true patriot .
nsubj(patriot, Sue)
</code></pre>

<pre><code class="language-sdparse">We are in the barn .
nsubj(barn, We)
</code></pre>

<pre><code class="language-sdparse">Agatha is in trouble .
nsubj(trouble, Agatha)
</code></pre>

<pre><code class="language-sdparse">There is a ghost in the room .
expl(is, There)
nsubj(is, ghost)
</code></pre>

<pre><code class="language-sdparse">These links present the many viewpoints that existed .
acl(viewpoints, existed)
nsubj(existed, that)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/nsubj.md" target="#">edit nsubj</a></p>

<p><a id="al-u-dep/nummod" class="al-dest"></a></p>
<h2><code>nummod</code>: numeric modifier</h2>

<p>A numeric modifier of a noun is any <a href="u-pos/NUM">number</a> phrase
that serves to modify the meaning of the noun with a quantity.</p>

<pre><code class="language-sdparse">Sam ate 3 sheep
nummod(sheep, 3)
</code></pre>

<pre><code class="language-sdparse">Sam spent forty dollars
nummod(dollars, forty)
</code></pre>

<pre><code class="language-sdparse">Sam spent $ 40
nummod($, 40)
</code></pre>

<p>Note that indefinite quantifiers such as <em>few, many</em> are tagged
<a href="">u-pos/DET</a> rather than <a href="">u-pos/NUM</a>. 
Therefore their relation to the quantified noun is not <code>nummod</code> but
<a href="">det</a>:</p>

<pre><code class="language-sdparse">Sam ate many sheep
det(sheep, many)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/nummod.md" target="#">edit nummod</a></p>

<p><a id="al-u-dep/obj" class="al-dest"></a></p>
<h2><code>obj</code>: object</h2>

<p>The object of a verb is the second most core argument of a verb after the subject. 
Typically, it is the noun phrase that denotes the entity acted upon or which undergoes a change of state or motion (the proto-patient).</p>

<pre><code class="language-sdparse">She gave me a raise
obj(gave, raise)
</code></pre>

<p>In languages distinguishing morphological <a href="u-feat/Case">cases</a>, the
object will often be marked by the accusative case. However,
verb valency may occasionally dictate a different form, such as the
dative case in the following German example:</p>

<pre><code class="language-sdparse">jemandem begegnen \n someone.Dat to-meet
obj(begegnen, jemandem)
</code></pre>

<p>In general, if there is just one object, it should be labeled <code>obj</code>,
regardless of the morphological case or semantic role that it bears. If there are two or more
objects, one of them should be <code>obj</code> and the others should be
<a href="">iobj</a>. In such cases it is necessary to decide what is the most
directly affected object <em>(patient).</em></p>

<!--The one exception is when there is a clausal complement. 
Then the clausal complement is regarded as a âclausal objectâ and an object nominal will be an [iobj]().-->

<p>There is more discussion of constructions with multiple objects on the page for <a href="">iobj</a>. 
If possible, language-specific documentation should be available to help identify the primary (or direct) object.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/obj.md" target="#">edit obj</a></p>

<p><a id="al-u-dep/obl" class="al-dest"></a></p>
<h2><code>obl</code>: oblique nominal</h2>

<p>The <code>obl</code> relation is used for a nominal (noun, pronoun, noun phrase) functioning as a non-core (oblique) argument or 
adjunct. This means that it functionally corresponds to an adverbial attaching to a verb, adjective or other adverb.</p>

<p>The <code>obl</code> relation can be further specified by the case. In conjunction with the <a href="">case</a> relation, it provides a uniform
analysis for:</p>

<ul>
  <li>variant forms with case, a preposition or a postposition, as in Finnish for example:</li>
</ul>

<pre><code class="language-sdparse">etsiÃ¤ ilman johtolankaa \n to_search without clue.PARTITIVE
obl(etsiÃ¤, johtolankaa)
case(johtolankaa, ilman)
</code></pre>

<pre><code class="language-sdparse">etsiÃ¤ taskulampun kanssa \n to_search torch.GENITIVE with
obl(etsiÃ¤, taskulampun)
case(taskulampun, kanssa)
</code></pre>

<pre><code class="language-sdparse">etsiÃ¤ johtolangatta \n to_search clue.ABESSIVE
obl(etsiÃ¤, johtolangatta)
</code></pre>

<ul>
  <li>the dative alternation where the prepositional construction gets a similar analysis to the double object construction:</li>
</ul>

<pre><code class="language-sdparse">give the children the toys
obj(give, toys)
iobj(give, children)
</code></pre>

<pre><code class="language-sdparse">give the toys to the children
obj(give, toys)
obl(give, children)
case(children, to)
</code></pre>

<pre><code class="language-conllu"># give the toys to the children
1     donner    donner   VERB   _   VerbForm=Inf               0   root   _   give
2     les       le       DET    _   Definite=Def|Number=Plur   3   det    _   the
3     jouets    jouet    NOUN   _   Gender=Masc|Number=Plur    1   obj   _   toys
4-5   aux       _        _      _   _                          _   _      _   _
4     Ã          Ã         ADP    _   _                          6   case   _   to
5     les       le       DET    _   Definite=Def|Number=Plur   6   det    _   the
6     enfants   enfant   NOUN   _   Gender=Masc|Number=Plur    1   obl   _   children
</code></pre>

<p><code>obl</code> is also used for temporal and locational nominal modifiers:</p>

<pre><code class="language-sdparse">Last night , I swam in the pool
obl(swam, night)
obl(swam, pool)
</code></pre>

<p>and for the agent of a passive verb (with the optional subtype obl:agent):</p>

<pre><code class="language-sdparse">the cat was chased by the dog
nsubj:pass(chased, cat)
obl:agent(chased, dog)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/obl.md" target="#">edit obl</a></p>

<p><a id="al-u-dep/orphan" class="al-dest"></a></p>
<h2><code>orphan</code>: orphan</h2>

<p>The âorphanâ relation is used in cases of head <a href="http://universaldependencies.org/u/overview/specific-syntax.html#ellipsis">ellipsis</a> where simple promotion would result in unnatural 
and misleading dependency relation. The typical case is predicate ellipsis where one of the core arguments
have to be promoted to clausal head.</p>

<pre><code class="language-sdparse">Marie won gold and Peter bronze
nsubj(won, Marie)
obj(won, gold)
conj(won, Peter)
cc(Peter, and)
orphan(Peter, bronze)
</code></pre>

<p>In this example, the subject <em>Peter</em> is promoted to the head position in the second conjunct. Attaching
the object <em>bronze</em> to the subject is necessary to preserve the integrity of the clause, but using the
standard relation <a href="">obj</a> would be misleading because <em>bronze</em> is not the object of <em>Peter</em>. Therefore,
the <code>orphan</code> relation is used to indicate that this is a non-standard attachment. By contrast, the coordinating
conjunction <em>and</em> performs essentially the same function as in the non-elliptical case and therefore retains
its normal relation <code>cc</code>.</p>

<p>See further discussion of <a href="http://universaldependencies.org/u/overview/specific-syntax.html#ellipsis">ellipsis</a>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/orphan.md" target="#">edit orphan</a></p>

<p><a id="al-u-dep/parataxis" class="al-dest"></a></p>
<h2><code>parataxis</code>: parataxis</h2>

<p>The parataxis relation (from Greek for âplace side by sideâ) is a
relation between a word (often the main predicate of a sentence) and other
elements, such as a sentential parenthetical or a clause after a â:â or
a â;â, placed side by side without any explicit
coordination, subordination, or argument relation with the head word. Parataxis is a discourse-like equivalent of coordination, and so usually obeys an iconic ordering. Hence it is normal for the first part of a sentence to be the head and the second part to be the parataxis dependent, regardless of the headedness properties of the language.  But things do get more complicated, such as cases of parentheticals, which appear medially.</p>

<pre><code class="language-sdparse">Let 's face it we 're annoyed
parataxis(Let, annoyed)
</code></pre>

<pre><code class="language-sdparse">The guy , John said , left early in the morning
parataxis(left, said)
punct(said, ,-3)
punct(said, ,-6)
</code></pre>

<h2 id="an-inventory-of-constructions-to-which-parataxis-has-been-applied">An inventory of constructions to which parataxis has been applied</h2>

<h3 id="side-by-side-sentences-run-on-sentences">Side-by-side sentences (ârun-on sentencesâ)</h3>

<p>The relation parataxis is used for a pair of what could have been standalone sentences, 
but which are being treated together as a single sentence. This may happen because sentence
segmentation of the sentence was done primarily following the presence of sentence-final punctuation,
and these clauses are joined by punctuation such as a colon or comma, or not delimited by punctuation
at all. In a spoken corpus, it may happen because what is labeled as a sentence is more
commonly an utterance turn. Even if the treebanker is doing the sentence division, it may
happen because there seems to be a clear discourse relation linking two clauses. 
Sometimes there are more than two sentences joined in this way. In this case we make all the later sentences
dependents of the first one, to maximize similarity to the analysis used for conjunction.</p>

<pre><code class="language-sdparse">Bearded dragons are sight hunters , they need to see the food to move .
parataxis(hunters, need)
punct(need, ,)
</code></pre>

<p>This relation may happen with units that are smaller than sentences:</p>

<pre><code class="language-sdparse">Divided world the CIA
amod(world, Divided)
parataxis(world, CIA)
det(CIA, the)
</code></pre>

<h3 id="treatment-of-reported-speech">Treatment of reported speech</h3>

<p>For this reported speech example:</p>

<pre><code class="language-sdparse">The guy , John said , left early in the morning
parataxis(left, said)
punct(said, ,-3)
punct(said, ,-6)
</code></pre>

<p>there are paraphrases that convey essentially the same meaning but
with a different syntactic structure. When the reported speech is embedded in a subordinate clause (with or 
without an overt complementizer <em>that</em>), the subordinate clause is a <a href="">ccomp</a> of the speech verb. When the
reported speech follows the speech verb and is separated by a colon, the reported speech forms a main clause
that attaches to the preceding main clause with a <a href="">parataxis</a> relation, hence with the speech verb as its head.
However, when the speech verb occurs as a medial or final parenthetical, the relation is reversed and the speech
verb is treated as a <a href="">parataxis</a> of the reported speech. 
This analysis is not uncontroversial but follows many authorities, such as Huddleston and Pullum (2002),
<em>The Cambridge Grammar of the English Language</em> (see chapter 11, section 9).</p>

<pre><code class="language-sdparse">John said that the guy left early in the morning .
ccomp(said, left)
</code></pre>

<pre><code class="language-sdparse">John said the guy left early in the morning .
ccomp(said, left)
</code></pre>

<pre><code class="language-sdparse">John said : â The guy left early in the morning . â
parataxis(said, left)
punct(left, :)
punct(left, â)
punct(left, â)
</code></pre>

<pre><code class="language-sdparse">â The guy left early in the morning â , John said .
parataxis(left, said)
punct(said, ,)
punct(left, â)
punct(left, â)
</code></pre>

<pre><code class="language-sdparse">The guy left early in the morning , John said .
parataxis(left, said)
punct(said, ,)
</code></pre>

<pre><code class="language-sdparse">The guy , he said , left early in the morning .
parataxis(left, said)
punct(said, ,-3)
punct(said, ,-6)
</code></pre>

<p>An argument for this analysis is that in the cases analyzed as embedding, the entire clause
can be further embedded (<em>I was taken aback when John said the guy left early in the morning.</em>),
while this is not possible with medial or final placement of the speech verb 
(<em>*I was taken aback when the guy left early this morning, John said.</em>).</p>

<h3 id="news-article-bylines">News article bylines</h3>

<p>We have used the parataxis relation to connect the parts of a news article byline. 
There does not seem to be a better relation to use.</p>

<pre><code class="language-sdparse">Washington ( CNN ) :
parataxis(Washington, CNN)
punct(CNN, ()
punct(CNN, ))
punct(CNN, :)
</code></pre>

<h3 id="interjected-clauses">Interjected clauses</h3>

<p>Single word or phrase interjections are analyzed as <a href="">discourse</a>, but when a whole clause is interjected, we use the relation parataxis.</p>

<pre><code class="language-sdparse">Calafia has great fries ( they are to die for ! )
parataxis(has, are)
punct(are, ()
punct(are, ))
</code></pre>

<pre><code class="language-sdparse">Just to let you all know Matt has confirmed the booking for 3rd Dec is OK .
parataxis(confirmed, let)
</code></pre>

<p>In the second example, we treat the second half as the head of the dependency
because the first half feels like a whole clause interjection, not like the main clause of the utterance.</p>

<h3 id="tag-questions">Tag questions</h3>

<p>We also use the parataxis relation for tag questions such as <em>isnât it?</em> or <em>havenât you?</em>.</p>

<pre><code class="language-sdparse">It 's not me , is it ?
parataxis(me, is)
punct(is, ,)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/parataxis.md" target="#">edit parataxis</a></p>

<p><a id="al-u-dep/punct" class="al-dest"></a></p>
<h2><code>punct</code>: punctuation</h2>

<p>This is used for any piece of punctuation in a clause, if punctuation
is being retained in the typed dependencies.</p>

<pre><code class="language-sdparse">Go home !
punct(Go, !)
</code></pre>

<p>Tokens with the relation <a href="">u-dep/punct</a> always attach to content words (except in cases of ellipsis) and can never have dependents.
Since <code>punct</code> is not a normal dependency relation, the usual criteria for determining the head word do not apply. 
Instead, we use the following principles:</p>

<ol>
  <li>A punctuation mark separating coordinated units is attached to the following conjunct.</li>
  <li>A punctuation mark preceding or following a dependent unit is attached to that unit.</li>
  <li>Within the relevant unit, a punctuation mark is attached at the highest possible node that preserves projectivity.</li>
  <li>Paired punctuation marks (e.g. quotes and brackets, sometimes also dashes, commas and other) should be attached to the same word unless that would create non-projectivity. This word is usually the head of the phrase enclosed in the paired punctuation.</li>
</ol>

<div id="punct1" class="sd-parse">
We have apples , pears , oranges , and bananas .
obj(have, apples)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(bananas, and)
punct(pears, ,-4)
punct(oranges, ,-6)
punct(bananas, ,-8)
</div>

<div id="punct2" class="sd-parse">
Der Mann , den Sie gestern kennengelernt haben , kam wieder .
punct(kennengelernt, ,-3)
punct(kennengelernt, ,-9)
punct(kam, .)
</div>

<div id="punct3" class="sd-parse">
A.K.A. , AKA , or a\/k\/a may refer to : â Also known as â , used to introduce pseudonyms , aliases , etc. ( Compare f.k.a. for â formerly known as â . )
punct(AKA, ,-2)
punct(a/k/a, ,-4)
punct(refer, :)
punct(known-13, â-11)
punct(known-13, â-15)
punct(used, ,-16)
punct(aliases, ,-21)
punct(etc., ,-23)
punct(Compare, (-25)
punct(Compare, )-35)
punct(known-31, â-29)
punct(known-31, â-33)
punct(Compare, .-34)
</div>

<p>See also examples at <a href="">parataxis</a>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/punct.md" target="#">edit punct</a></p>

<p><a id="al-u-dep/reparandum" class="al-dest"></a></p>
<h2><code>reparandum</code>: overridden disfluency</h2>

<p>We use <code>reparandum</code> to indicate disfluencies overridden in a speech
repair. The disfluency is the dependent of the repair.</p>

<pre><code class="language-sdparse">Go to the righ- to the left .
obl(Go-1, left-7)
reparandum(left-7, righ-)
case(righ-, to-2)
det(righ-, the-3)
case(left-7, to-5)
det(left-7, the-6)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/reparandum.md" target="#">edit reparandum</a></p>

<p><a id="al-u-dep/root" class="al-dest"></a></p>
<h2><code>root</code>: root</h2>

<p>The <code>root</code> grammatical relation points to the root of the sentence. A fake node <code>ROOT</code> is used as the governor. The <code>ROOT</code> node is indexed with 0, since the indexing of real words in the sentence starts at 1. (The <code>ROOT</code> node is not represented
explicitly in CoNLL-U.)</p>

<pre><code class="language-sdparse">ROOT I love French fries .
root(ROOT, love)
</code></pre>

<p><strong>New from v2:</strong> There should be just one node with the <code>root</code> dependency relation in every tree. 
If the main predicate is not present (due to ellipsis) and there are multiple orphaned dependents, 
one of these is promoted to the head (root) position and the other orphans are attached to it.
(This rule has in practice been followed since release v1.2 but was not explicitly stated in the
original v1 guidelines.)</p>

<pre><code class="language-sdparse">ROOT And Robert the fourth place .
root(ROOT, Robert)
cc(Robert, And)
orphan(Robert, place)
punct(Robert, .)
amod(place, fourth)
det(place, the)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/root.md" target="#">edit root</a></p>

<p><a id="al-u-dep/vocative" class="al-dest"></a></p>
<h2><code>vocative</code>: vocative</h2>

<p>The <em>vocative</em> relation is used to mark a dialogue participant addressed in a text (common in conversations, dialogue, emails, newsgroup postings, etc.). The relation links the addresseeâs name to its host sentence. A vocative commonly co-occurs with a null subject, as in the first example below. If the nominal is clearly vocative in intent, the preference is to use the vocative relation.</p>

<pre><code class="language-sdparse">Guys , take it easy!
vocative(take, Guys)
</code></pre>

<pre><code class="language-sdparse">Marie , comment vas - tu ?
vocative(vas, Marie)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/vocative.md" target="#">edit vocative</a></p>

<p><a id="al-u-dep/xcomp" class="al-dest"></a></p>
<h2><code>xcomp</code>: open clausal complement</h2>

<p>An open clausal complement (<code>xcomp</code>) of a verb or an adjective is a
predicative or clausal complement without its own subject. The
reference of the subject is necessarily determined by an argument
external to the xcomp (normally by the object of the next higher
clause, if there is one, or else by the subject of the next higher
clause). This is often referred to as <em>obligatory control</em>. 
These clauses tend to be non-finite in many languages, 
but they can be finite as well. The name <code>xcomp</code> is
borrowed from Lexical-Functional Grammar.</p>

<pre><code class="language-sdparse">He says that you like to swim
ccomp(says, like)
</code></pre>

<pre><code class="language-sdparse">Sue asked George to respond to her offer
xcomp(asked, respond)
obj(asked, George)
</code></pre>

<pre><code class="language-sdparse">You look great
xcomp(look, great)
</code></pre>

<pre><code class="language-sdparse">I started to work there yesterday
xcomp(started, work)
</code></pre>

<pre><code class="language-sdparse">I consider him a fool
xcomp(consider, fool)
</code></pre>

<pre><code class="language-sdparse">I consider him honest
xcomp(consider, honest)
</code></pre>

<pre><code class="language-sdparse">We expect them to change their minds
xcomp(expect, change)
obj(expect, them)
</code></pre>

<p>Note that the above condition âwithout its own subjectâ does not mean that a 
clause is an <code>xcomp</code> just because its subject is not <em>overt.</em> The subject must be necessarily inherited from a fixed position in the higher clause. That is, there should be no available interpretation where the subject of the lower clause may be distinct
from the specified role of the upper clause. In cases where the missing subject may or must be distinct from a fixed role in the higher clause, <code>ccomp</code> should be used instead, as below.  This includes cases of arbitrary subjects and anaphoric control.</p>

<pre><code class="language-sdparse">The boss said to start digging
ccomp(said, start)
</code></pre>

<p>Pro-drop languages have clauses where the subject is not present as a separate word,
yet it is inherently present (and often deducible from the form of the verb)
and it does not depend on arguments from a higher clause.
Thus in neither of the following two Czech examples is there any overt subject,
yet only the second example contains an <code>xcomp</code>.</p>

<pre><code class="language-sdparse">PÃ­Å¡u , protoÅ¾e jsem to slÃ­bil . \n I-write , because I-have it promised .
advcl(PÃ­Å¡u, slÃ­bil)
advcl(I-write, promised)
</code></pre>

<pre><code class="language-sdparse">SlÃ­bil jsem psÃ¡t . \n Promised I-have to-write .
xcomp(SlÃ­bil, psÃ¡t)
xcomp(Promised, to-write)
</code></pre>

<h3 id="secondary-predicates">Secondary Predicates</h3>

<p>The <code>xcomp</code> relation is also used in constructions that are known as <em>secondary predicates</em> or <em>predicatives</em>.
Examples:</p>

<ul>
  <li><em>She declared the cake beautiful.</em></li>
  <li><em>She declared the cake a success.</em></li>
</ul>

<p>We could paraphrase the sentence using a subordinate clause: <em>She declared that the cake was beautiful.</em>
There are two predicates mixed in one clause: 1. she declared something, and 2. the cake was beautiful (according to her opinion).
The secondary predicate will be attached to the main predicate as an <code>xcomp</code>:</p>

<pre><code class="language-sdparse">She declared the cake beautiful .
nsubj(declared, She)
obj(declared, cake)
xcomp(declared, beautiful)
</code></pre>

<p>In the enhanced representation, there is an additional subject link showing the secondary predication:</p>

<pre><code class="language-sdparse">She declared the cake beautiful .
nsubj(declared, She)
obj(declared, cake)
comp(declared, beautiful)
nsubj(beautiful, cake)
</code></pre>

<p>A Czech example:</p>

<pre><code class="language-sdparse">jmenovat nÄkoho generÃ¡lem \n to-appoint someone as-a-general
obj(jmenovat, nÄkoho)
xcomp(jmenovat, generÃ¡lem)
</code></pre>

<p>Remember that <code>xcomp</code> is used for core arguments of clausal predicates
so it will not be used for other instances of secondary predication.
For instance, in <em>She entered the room sad</em> we also have a double predication
(she entered the room; she was sad).
But <em>sad</em> is not a core argument of <em>enter:</em> leaving it out will neither affect grammaticality
nor significantly alter the meaning of the verb.
On the other hand, leaving out <em>beautiful</em> in <em>she declared the cake beautiful</em>
will either render the sentence ungrammatical or lead to a different interpretation of <em>declared.</em></p>

<p>The result is that in <em>She entered the room sad,</em> <em>sad</em> will depend on <em>She</em>
and the relation will be <a href="">acl</a> instead of <code>xcomp</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/xcomp.md" target="#">edit xcomp</a></p>



      </div>

<!-- support for embedded visualizations -->
<script type="text/javascript">
    var root = '../../'; // filled in by jekyll
    head.js(
        // External libraries
        root + 'lib/ext/jquery.min.js',
        root + 'lib/ext/jquery.svg.min.js',
        root + 'lib/ext/jquery.svgdom.min.js',
        root + 'lib/ext/jquery.timeago.js',
        root + 'lib/ext/jquery-ui.min.js',
        root + 'lib/ext/waypoints.min.js',
        root + 'lib/ext/jquery.address.min.js',

        // brat helper modules
        root + 'lib/brat/configuration.js',
        root + 'lib/brat/util.js',
        root + 'lib/brat/annotation_log.js',
        root + 'lib/ext/webfont.js',
        // brat modules
        root + 'lib/brat/dispatcher.js',
        root + 'lib/brat/url_monitor.js',
        root + 'lib/brat/visualizer.js',

        // embedding configuration
        root + 'lib/local/config.js',
        // project-specific collection data
        root + 'lib/local/collections.js',

        // NOTE: non-local libraries
        'https://spyysalo.github.io/annodoc/lib/local/annodoc.js',
        'https://spyysalo.github.io/conllu.js/conllu.js'
    );

    var webFontURLs = [
//        root + 'static/fonts/Astloch-Bold.ttf',
        root + 'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        root + 'static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var setupAccordions = function() {
	// preserve state in URL hash, following in part
	// http://www.boduch.ca/2011/05/remembering-jquery-ui-accordion.html

        // Make subaccordions first, make them active to get height, and then close later
        $(".jquery-ui-subaccordion-closed").accordion({collapsible: true, disabled:false, active:0});

	var accordionChange = function(event, ui) {
	    var context = ui.newHeader ? ui.newHeader.context : null;
	    if (context) {
		var languageCode = context.getAttribute('data-lc');
		if (languageCode !== null) {
		    window.location.hash = languageCode;
		}
	    }
	}
        // jQuery UI "accordion" element initialization
	$(".jquery-ui-accordion").accordion({
	    collapsible: true,
	    active: false,
	    change: accordionChange
	});
	if ($(".jquery-ui-accordion").length) {
	    var matches = window.location.hash.match(/^\#(.*)$/);
	    console.log(matches);
	    if (matches !== null) {
		var languageCode = matches[1];
		var tab = $('[data-lc="'+languageCode+'"]');
		// the following will only work after accordion is initialized
		var index = $('.jquery-ui-accordion div.ui-accordion-header').index(tab);
		if (index !== -1) {
		    $(".jquery-ui-accordion").accordion({ active: index });
		}
	    }
	}
        //now reclose these accordions
        $(".jquery-ui-subaccordion-closed").accordion("option","active",false);
    };

    var setupTimeago = function() {
        jQuery("time.timeago").timeago();
    };

    var setupTabs = function() {
        // standard jQuery UI "tabs" element initialization
        $(".jquery-ui-tabs").tabs({ heightStyle: "auto" });

        // use jQuery address to preserve tab state
        // (see https://github.com/UniversalDependencies/docs/issues/65,
        // http://stackoverflow.com/a/3330919)
        if ($(".jquery-ui-tabs").length > 0) {
            $.address.change(function(event){
	        $(".jquery-ui-tabs").tabs("select", window.location.hash)
	    });
	    $(".jquery-ui-tabs").bind("tabsselect", function(event, ui) { 
	        window.location.hash = ui.tab.hash;
	    });
        }
    };

    head.ready(function() {
        // set up UI tabs on page
        setupTabs();
        setupAccordions();
        setupTimeago();

        // mark current collection (filled in by Jekyll)
        Collections.listing['_current'] = 'u-overview';

	// perform all embedding and support functions
	Annodoc.activate(Config.bratCollData, Collections.listing);
    });
</script>


<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55233688-1', 'auto');
  ga('send', 'pageview');

</script>


      <div id="footer">
	  <p class="footer-text">&copy; 2014 
	    <a href="http://universaldependencies.org/introduction.html#contributors" style="color:gray">Universal Dependencies contributors</a>. 
	    Site powered by <a href="http://spyysalo.github.io/annodoc" style="color:gray">Annodoc</a> and <a href="http://brat.nlplab.org/" style="color:gray">brat</a></p>.
      </div>
    </div>
  </body>
</html>
