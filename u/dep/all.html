<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Universal Dependencies</title>
    <link rel="icon" href="https://universaldependencies.org/logos/logo-ud.png" type="image/png">
    <link rel="root" href=""/> <!-- for JS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="../../css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style-vis.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/hint.css"/>
    <script type="text/javascript" src="../../lib/ext/head.load.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.2.2/anchor.min.js"></script>
    <script>document.addEventListener("DOMContentLoaded", function(event) {anchors.add();});</script>
    <!-- Set up this custom Google search at https://cse.google.com/cse/business/settings?cx=001145188882102106025:dl1mehhcgbo -->
    <!-- DZ 2021-01-22: I am temporarily hiding the search field to find out whether it slows down loading of the title page.
    <script>
      (function() {
        var cx = '001145188882102106025:dl1mehhcgbo';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script> -->
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->


  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
        <table width="100%"><tr><td width="50%">
          <span class="header-text"><a href="http://universaldependencies.org/#language-u">home</a></span>


          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
        </td><td>
          <gcse:search></gcse:search>
        </td></tr></table>
      </div>

      <hr/>

      
      <div class="v2complete">
        This page pertains to UD version 2.
      </div>
      

      <div id="content">
        <noscript>
          <div id="noscript">
            It appears that you have Javascript disabled.
            Please consider enabling Javascript for this page to see the visualizations.
          </div>
        </noscript>

        <!-- The content may include scripts and styles, hence we must load the shared libraries before the content. -->
        <script type="text/javascript">
            console.time('loading libraries');
            var root = '../../'; // filled in by jekyll
            head.js(
                // External libraries
                // DZ: Copied from embedding.html. I don't know which one is needed for what, so I'm currently keeping them all.
                root + 'lib/ext/jquery.min.js',
                root + 'lib/ext/jquery.svg.min.js',
                root + 'lib/ext/jquery.svgdom.min.js',
                root + 'lib/ext/jquery.timeago.js',
                root + 'lib/ext/jquery-ui.min.js',
                root + 'lib/ext/waypoints.min.js',
                root + 'lib/ext/jquery.address.min.js'
            );
        </script>
        <h1 id="universal-dependencies">Universal Dependencies</h1>

<p>The following table lists the 37 universal syntactic relations used in UD v2. It is a revised version of the relations 
originally described in <a href="http://nlp.stanford.edu/pubs/USD_LREC14_paper_camera_ready.pdf"><em>Universal Stanford Dependencies: A cross-linguistic typology</em></a> (de Marneffe <em>et al.</em> 2014).</p>

<p>The upper part of the table follows the main organizing principles of the UD taxonomy:</p>

<ul>
  <li>Rows correspond to functional categories in relation to the head:
    <ul>
      <li>Core arguments of clausal predicates</li>
      <li>Non-core dependents of clausal predicates</li>
      <li>Dependents of nominals</li>
    </ul>
  </li>
  <li>Columns correspond to structural categories of the dependent:
    <ul>
      <li>Nominals</li>
      <li>Clauses</li>
      <li>Modifier words</li>
      <li>Function words</li>
    </ul>
  </li>
</ul>

<p>The lower part of the table lists relations that are not dependency relations in the narrow sense:</p>

<ul>
  <li>Relations used to analyze coordination</li>
  <li>Relations used to analyze multiword expressions (MWE)</li>
  <li>Loose joining relations</li>
  <li>Special relations for ellipsis, disfluencies, and orthographic errors</li>
  <li>Special relations for clausal heads, punctuation and other relations</li>
</ul>

<table class="typeindex" border="1">
  <tr style="background-color:cornflowerblue">
      <td>	
	<table class="category">
	  <tr><td><strong></strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Nominals</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Clauses</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Modifier words</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Function Words</strong></td></tr>
	</table>
      </td>
  </tr>
  <tr>
      <td style="background-color:darkseagreen">
	<table class="category">
	  <tr><td><strong>Core arguments</strong></td></tr>
	</table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>nsubj</a></td>
	  </tr>
	  <tr>
	    <td><a>obj</a></td>
	  </tr>
	  <tr>
	    <td><a>iobj</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>csubj</a></td>
	  </tr>
	  <tr>
	    <td><a>ccomp</a></td>
	  </tr>
	  <tr>
	    <td><a>xcomp</a></td>
	  </tr>
        </table>
      </td>
	  <td></td><td></td>
  </tr>
  <tr>
      <td style="background-color:darkseagreen">
	<table class="category">
	  <tr><td><strong>Non-core dependents</strong></td></tr>
	</table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>obl</a></td>
	  </tr>
	  <tr>
	    <td><a>vocative</a></td>
	  </tr>
	  <tr>
	    <td><a>expl</a></td>
	  </tr>
	  <tr>
	    <td><a>dislocated</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>advcl</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>advmod</a>*</td>
	  </tr>
	  <tr>
	    <td><a>discourse</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>aux</a></td>
	  </tr>
	  <tr>
	    <td><a>cop</a></td>
	  </tr>
	  <tr>
	    <td><a>mark</a></td>
	  </tr>
        </table>
      </td>
  </tr>
  <tr>
      <td style="background-color:darkseagreen">
	<table class="category">
	  <tr><td><strong>Nominal dependents</strong></td></tr>
	</table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>nmod</a></td>
	  </tr>
	  <tr>
	    <td><a>appos</a></td>
	  </tr>
	  <tr>
	    <td><a>nummod</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>acl</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>amod</a></td>
	  </tr>
        </table>
      </td>
      <td>
	<table class="category">
	  <tr>
	    <td><a>det</a></td>
	  </tr>
	  <tr>
	    <td><a>clf</a></td>
	  </tr>
	  <tr>
	    <td><a>case</a></td>
	  </tr>
        </table>
      </td>
  </tr>
  <tr style="background-color:cornflowerblue">	
      <td>	
	<table class="category">
	  <tr><td><strong>Coordination</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Headless</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Loose</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Special</strong></td></tr>
	</table>
      </td>
      <td>	
	<table class="category">
	  <tr><td><strong>Other</strong></td></tr>
	</table>
      </td>
  </tr>
  <tr>
      <td>
        <table class="category">
	  <tr>
	    <td><a>conj</a></td>
	  </tr>
	  <tr>
	    <td><a>cc</a></td>
	  </tr>
        </table>
      </td>
      <td>
        <table class="category">
	<tr>
	  <td><a>fixed</a></td>
	</tr>
	<tr>
	  <td><a>flat</a></td>
	</tr>
      </table>
    </td>
    <td>
      <table class="category">
	<tr>
	  <td><a>list</a></td>
	</tr>
	<tr>
	  <td><a>parataxis</a></td>
	</tr>
      </table>
    </td>
    <td>
      <table class="category">
	<tr>
	  <td><a>compound</a></td>
	</tr>
	<tr>
	  <td><a>orphan</a></td>
	</tr>
	<tr>
	  <td><a>goeswith</a></td>
	</tr>
	<tr>
	  <td><a>reparandum</a></td>
	</tr>
      </table>
    </td>
    <td>
      <table class="category">
	<tr>
	  <td><a>punct</a></td>
	</tr>
	<tr>
	  <td><a>root</a></td>
	</tr>
	<tr>
	  <td><a>dep</a></td>
	</tr>
      </table>

    </td>
  </tr>
</table>

<hr />

<p><a id="al-u-dep/acl" class="al-dest"></a></p>
<h2><code>acl</code>: clausal modifier of noun (adnominal clause)</h2>

<p><code class="language-plaintext highlighter-rouge">acl</code> stands for finite and non-finite clauses that modify a nominal.  The <code class="language-plaintext highlighter-rouge">acl</code> relation 
contrasts with the <a href="">advcl</a> relation, which is used for adverbial clauses
that modify a predicate. The head of the <code class="language-plaintext highlighter-rouge">acl</code> relation is the noun
that is modified, and the dependent is the head of the clause that
modifies the noun.</p>

<pre><code class="language-sdparse">the issues as he sees them
acl(issues, sees)
</code></pre>

<pre><code class="language-sdparse">There are many online sites offering booking facilities .
acl(sites, offering)
</code></pre>

<pre><code class="language-sdparse">I have a parakeet named cookie .
acl(parakeet, named)
</code></pre>

<pre><code class="language-sdparse">A president certain that they are correct is dangerous . 
acl(president, certain)
ccomp(certain, correct)
nsubj(dangerous, president)
</code></pre>

<pre><code class="language-sdparse">I just want a simple way to get my discount .
acl(way, get)
</code></pre>

<pre><code class="language-sdparse">Cette affaire à suivre \n This case to follow 
acl(affaire, suivre)
</code></pre>

<p>A relative clause is an instance of <code class="language-plaintext highlighter-rouge">acl</code>, characterized by finiteness and usually omission of 
the modified noun in the embedded clause. Some languages use a language-particular subtype <code class="language-plaintext highlighter-rouge">acl:relcl</code> for the traditional class of relative clauses.</p>

<pre><code class="language-sdparse">I saw the man you love
acl:relcl(man, love)
</code></pre>

<p>Some languages allow finite clausal complements for nouns with 
a subset of nouns like <em>fact</em> or <em>report</em>. These look roughly like relative clauses, but do not have any omitted role in the dependent clause. This is the class of “content clauses” in Huddleston and Pullum 2002). These are also analyzed as <code class="language-plaintext highlighter-rouge">acl</code>.</p>

<pre><code class="language-sdparse">the fact that nobody cares
acl(fact, cares)
</code></pre>

<p>This relation is no longer used for optional depictives: <a href="">advcl</a> should be used instead.</p>

<!-- Interlanguage links updated So 10. května 2025, 18:14:43 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/acl.md" target="#">edit acl</a></p>

<p><a id="al-u-dep/acl:relcl" class="al-dest"></a></p>
<h2><code>acl:relcl</code>: relative clause modifier</h2>

<p>A relative clause modifier of a nominal is a clause that modifies the nominal,
whereas the nominal is coreferential with a constituent inside the relative
clause (here the constituent may be realized as a relative pronoun, another
relative word, or it may not be overtly realized at all). The <code class="language-plaintext highlighter-rouge">acl:relcl</code>
relation points from the head of the modified nominal to the head of the
relative clause.</p>

<p>Depending on language, it may be required that relative clauses are finite.
For example, English non-finite clauses are traditionally not termed relative;
therefore, <em>the girl <b>that was born today</b></em> is a relative clause because
it is finite, while <em>the girl <b>born today</b></em> is non-finite (the participle
is not accompanied by a finite auxiliary) and it uses the plain <a href="">acl</a>
relation. In other languages however, the distinction between finite and
non-finite clauses may not exist or may not be used as a criterion for relative
clauses.</p>

<pre><code class="language-sdparse">I saw the man you love
acl:relcl(man, love)
</code></pre>

<pre><code class="language-sdparse">I saw the book which you bought
acl:relcl(book, bought)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:14:45 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/acl-relcl.md" target="#">edit acl:relcl</a></p>

<p><a id="al-u-dep/advcl" class="al-dest"></a></p>
<h2><code>advcl</code>: adverbial clause modifier</h2>

<p>An adverbial clause modifier is a clause which modifies a verb or other predicate (adjective, etc.),
as a modifier not as a core complement. This includes things such as a temporal clause, consequence, conditional clause, purpose
clause, etc. The dependent must be clausal (or else it is an <a href="">advmod</a>) and the dependent is the main predicate of the clause.</p>

<pre><code class="language-sdparse">The accident happened as night was falling
advcl(happened, falling)
</code></pre>

<pre><code class="language-sdparse">If you know who did it, you should tell the teacher
advcl(tell, know)
</code></pre>

<pre><code class="language-sdparse">He talked to him in order to secure the account
advcl(talked, secure)
</code></pre>

<pre><code class="language-sdparse">He was upset when I talked to him
advcl(upset, talked)
</code></pre>

<pre><code class="language-sdparse">They heard about you missing classes.
advcl(heard, missing)
</code></pre>

<pre><code class="language-sdparse">With the kids in school , I have plenty of free time
advcl(have, school)
mark(school, With)
nsubj(school, kids)
case(school, in)
</code></pre>

<pre><code class="language-sdparse">She entered the room while sad
advcl(entered, sad)
</code></pre>

<h2 id="modifying-nominal-predicates">Modifying Nominal Predicates</h2>

<p>An <code class="language-plaintext highlighter-rouge">advcl</code> never modifies a nominal as such (then it would be <a href="">acl</a> instead) but it can modify a clausal predicate
that is realized as a nominal, with or without copula. One has to distinguish whether the modifier clause modifies the
whole predication of the matrix clause, or just the entity denoted by the nominal. Hence we have <code class="language-plaintext highlighter-rouge">advcl</code> in</p>

<pre><code class="language-sdparse">He is a teacher , although he no longer teaches .
advcl(teacher, teaches)
</code></pre>

<p>but <a href="">acl:relcl</a> in</p>

<pre><code class="language-sdparse">He is a teacher whom the students really love .
acl:relcl(teacher, love)
</code></pre>

<h2 id="optional-depictives">Optional Depictives</h2>

<p>This relation is also used for optional depictive adjectives, where the adjective is introduced in clause structure independently of the nominal it describes (contrast: <a href="">acl</a> if the adjective is an adnominal predicate). The depictive adjective is treated as an adverbial clause modifier of the higher clause. The adjective also provides a secondary predication, where the nominal predicand may or may not be overt; if it is overt, the secondary predication can be represented with an enhanced dependency. See <a href="">xcomp</a> for further discussion of resultatives and depictives.</p>

<pre><code class="language-sdparse">She entered the room sad
advcl(entered, sad)
</code></pre>

<p><em>Sad</em> describes the person entering the room, not the manner of entering—but is still taken to modify the verb.
Note the similarity to the <em>while sad</em> example above. Omitting the nominal predicand <em>she</em> does not change the basic analysis:</p>

<pre><code class="language-sdparse">Entering the room sad is not recommended
advcl(Entering, sad)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:14:46 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/advcl.md" target="#">edit advcl</a></p>

<p><a id="al-u-dep/advcl:relcl" class="al-dest"></a></p>
<h2><code>advcl:relcl</code>: adverbial relative clause modifier</h2>

<p>This relation applies to a relative clause that modifies a clause (as opposed to typical relative clauses, which are adnominal and use <a href="">acl:relcl</a>).</p>

<p>For example, the antecedent is a clause in:</p>

<pre><code class="language-sdparse">I tried to explain myself – which was a bad idea .
advcl:relcl(tried, idea)
nsubj(idea, which)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:14:51 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/advcl-relcl.md" target="#">edit advcl:relcl</a></p>

<p><a id="al-u-dep/advmod" class="al-dest"></a></p>
<h2><code>advmod</code>: adverbial modifier</h2>

<p>An adverbial modifier of a word is a (non-clausal) <a href="u-pos/ADV">adverb</a>
or adverbial phrase that serves to modify a predicate or a modifier word.</p>

<p>In some situations in some languages, a limited set of adverbs can also
modify nominals (e.g., <em><b>only</b> on Monday</em>). The <code class="language-plaintext highlighter-rouge">advmod</code> relation or
its subtype has to be used in such cases, too (see also <a href="">advmod:emph</a>).
<!-- Issue https://github.com/UniversalDependencies/docs/issues/779 --></p>

<p>Note that in some grammatical traditions, the term <em>adverbial modifier</em> covers
constituents that function like adverbs regardless whether they are realized
by adverbs, adpositional phrases, or nouns in particular morphological
<a href="u-feat/Case">cases</a>.
We differentiate adverbials realized as adverbs <em>(advmod)</em> and
adverbials realized by noun phrases or adpositional phrases
(<a href="">obl</a>). However, we do not differentiate between modifiers of predicates
(adverbials in a narrow sense) and modifiers of other modifier words like
adjectives or adverbs (sometime called qualifiers). These functions are all
subsumed under <code class="language-plaintext highlighter-rouge">advmod</code>.</p>

<pre><code class="language-sdparse">Genetically modified food
advmod(modified, Genetically)
</code></pre>

<pre><code class="language-sdparse">less often
advmod(often, less)
</code></pre>

<pre><code class="language-sdparse">Where/ADV do/AUX you/PRON want/VERB to/ADP go/VERB later/ADV ?/PUNCT
advmod(go, Where)
advmod(go, later)
</code></pre>

<pre><code class="language-sdparse">This is where/ADV I lived when/ADV I was born
nsubj(where, This)
cop(where, is)
advcl:relcl(where, lived)
advcl(lived, born)
advmod(born, when)
</code></pre>

<pre><code class="language-sdparse">About 200 people came to the party
advmod(200, About)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:14:52 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/advmod.md" target="#">edit advmod</a></p>

<p><a id="al-u-dep/advmod:emph" class="al-dest"></a></p>
<h2><code>advmod:emph</code>: emphasizing word, intensifier</h2>

<p>This is a special class of <a href="advmod">adverbial modifiers</a>.
It corresponds to the words that are attached in the analytical layer of PDT with the label <code class="language-plaintext highlighter-rouge">AuxZ</code>.
In the tectogrammatical layer they often get the label (functor) <code class="language-plaintext highlighter-rouge">RHEM</code> (rhematizers).</p>

<p>While other adverbial modifiers usually modify verbs, adjectives or adverbs, these emphasizers often modify noun phrases,
including prepositional phrases.</p>

<pre><code class="language-sdparse">zvlášť v pondělí \n especially on Monday
advmod:emph(pondělí, zvlášť)
advmod:emph(Monday, especially)
</code></pre>

<pre><code class="language-sdparse">jen 15 procent \n only 15 percent
advmod:emph(procent, jen)
advmod:emph(percent, only)
</code></pre>

<p>Other examples:</p>

<ul>
  <li><em>Mohli by obvinit <b>i</b> některého ministra.</em> “They could prosecute <b>also/even</b> a minister.”</li>
  <li><em>Začnou <b>až</b> o měsíc později.</em> lit. <em>They-will-start <b>even</b> by month later.</em> “They will start one month later.” (<em>Až</em> expresses that the speaker or the listener did not expect the thing to happen <b>that</b> late.)</li>
  <li><em><b>Ani</b> vojáci o to nemají zájem.</em> “<b>Not even</b> soldiers are interested in it.”</li>
  <li><em>Hraje <b>už</b> v sobotu.</em> “He will play <b>already</b> on Saturday.”</li>
  <li><em>Chceme se sejít <b>ještě</b> tento týden.</em> lit. <em>We-want to meet <b>still</b> this week.</em> “We want to meet before this week ends.”</li>
  <li><em>u <b>asi</b> 20 titulů</em> “by <b>around/approximately</b> 20 items”</li>
  <li><em>Dá se to dokumentovat <b>právě</b> na početné skupině dětí.</em> “It can be shown <b>just</b> on a large group of children.”
<!-- Interlanguage links updated So 10. května 2025, 18:14:53 CEST --></li>
</ul>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/advmod-emph.md" target="#">edit advmod:emph</a></p>

<p><a id="al-u-dep/advmod:lmod" class="al-dest"></a></p>
<h2><code>advmod:lmod</code>: locative adverbial modifier</h2>

<p>A locative adverbial modifier is a subtype of the <a href="">advmod</a> relation: if the modifier is specifying a location, it is labeled as <code class="language-plaintext highlighter-rouge">lmod</code>.</p>

<p>Danish:</p>

<pre><code class="language-sdparse">Han bøjer sig ned . \n He bends himself down .
advmod:lmod(bøjer, ned)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:14:54 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/advmod-lmod.md" target="#">edit advmod:lmod</a></p>

<p><a id="al-u-dep/amod" class="al-dest"></a></p>
<h2><code>amod</code>: adjectival modifier</h2>

<p>An adjectival modifier of a noun (or pronoun) is any adjectival phrase that serves
to modify the noun (or pronoun). The relation applies whether the meaning of the noun 
is modified in a compositional way (e.g., <em>large house</em>) or an idiomatic way (<em>hot dogs</em>).</p>

<p>An <code class="language-plaintext highlighter-rouge">amod</code> dependent may have its own modifiers (e.g., <em>very large house</em>) but the dependent should not be a clause. If it is a clause, then <code class="language-plaintext highlighter-rouge">acl</code> should be used.</p>

<pre><code class="language-sdparse">Sam eats large hot dogs
amod(dogs, large)
amod(dogs, hot)
</code></pre>

<pre><code class="language-sdparse">There is nothing wrong with it
amod(nothing, wrong)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:14:58 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/amod.md" target="#">edit amod</a></p>

<p><a id="al-u-dep/appos" class="al-dest"></a></p>
<h2><code>appos</code>: appositional modifier</h2>

<p>An appositional modifier of a noun is a nominal immediately following
the first noun that serves to define, modify, name, or describe that noun. It includes
parenthesized examples, as well as defining abbreviations in one of
these structures.</p>

<pre><code class="language-sdparse">Sam , my brother , arrived
appos(Sam-1, brother-4)
</code></pre>

<pre><code class="language-sdparse">Bill ( John 's cousin )
appos(Bill-1, cousin-5)
</code></pre>

<pre><code class="language-sdparse">The Australian Broadcasting Corporation ( ABC )
appos(Corporation-4, ABC-6)
</code></pre>

<p><code class="language-plaintext highlighter-rouge">appos</code> is intended to be used between two nominals. In general, modulo punctuation, the two halves of an apposition can be switched. 
For example, you could also say <em>My brother, Sam, arrived.</em> There are somewhat similar constructions with titles 
where the title is less than a full nominal, such as <em>state senator Paul Mnuchin</em>, where reversal is impossible 
or would require insertion of a determiner to make a 
full nominal. Some grammatical traditions, descending from Latin, call <em>state senator</em> in such cases a “fixed (or close) apposition” and take the name as the head. However, we seem to have only one nominal not two here. For example:</p>

<blockquote>
  <p>President Obama</p>
</blockquote>

<blockquote>
  <p>*Obama President</p>
</blockquote>

<blockquote>
  <p>state senator Paul Mnuchin</p>
</blockquote>

<blockquote>
  <p>*Paul Mnuchin state senator</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">appos</code> should not be used in such cases. However, the examples can usually be rendered in a fuller form, corresponding to “loose (or wide) apposition” in the Latin tradition, where there are two full phrases. Then the relation <code class="language-plaintext highlighter-rouge">appos</code> is appropriate, for example:</p>

<pre><code class="language-sdparse">Paul Mnuchin , the senior Oregon state senator
appos(Mnuchin-2, senator-8)
</code></pre>

<p>As is often the case, there are borderline cases. In formal writing, punctuation is usually a good signal of apposition, 
but there are certainly cases of apposition where no punctuation is used:</p>

<pre><code class="language-sdparse">the leader of the militant Lebanese Shiite group Hassan Nasrallah
appos(leader-2, Hassan-9)
flat(Hassan-9, Nasrallah-10)
</code></pre>

<p>Good tests include to ask whether the two halves are full nominals, whether the two halves can be swapped or not, and whether 
there is case or agreement concord (in a language with rich morphology). So we have:</p>

<pre><code class="language-sdparse">I met the French actor Gaspard Ulliel
nsubj(met-2, I-1)
det(actor-5, the-3)
amod(actor-5, French-4)
obj(met-2, actor-5)
appos(actor-5, Gaspard-6)
flat(Gaspard-6, Ulliel-7)
</code></pre>

<pre><code class="language-sdparse">I met Gaspard Ulliel the French actor 
nsubj(met-2, I-1)
obj(met-2, Gaspard-3)
flat(Gaspard-3, Ulliel-4)
det(actor-7, the-5)
amod(actor-7, French-6)
appos(Gaspard-3, actor-7)
</code></pre>

<pre><code class="language-sdparse">I met Gaspard Ulliel , the French actor 
nsubj(met-2, I-1)
obj(met-2, Gaspard-3)
flat(Gaspard-3, Ulliel-4)
punct(Gaspard-3, ,-5)
det(actor-8, the-6)
amod(actor-8, French-7)
appos(Gaspard-3, actor-8)
</code></pre>

<pre><code class="language-sdparse">I met French actor Gaspard Ulliel
nsubj(met-2, I-1)
amod(actor-4, French-3)
obj(met-2, actor-4)
flat(actor-4, Gaspard-5)
flat(actor-4, Ulliel-6)
</code></pre>

<p>While items like abbreviations are generally reversable, the determiner test suggested above doesn’t quite work there, since the determiner seems to belong with the main item:</p>

<pre><code class="language-sdparse">The ABC ( Australian Broadcasting Corporation )
appos(ABC-2, Corporation-6)
</code></pre>

<p>In the rare cases of more than one appositive nominal, all nouns should be marked as modifying the first noun, rather than being chained:</p>

<pre><code class="language-sdparse">Sam , my brother , John 's cousin , arrived
appos(Sam-1, brother-4)
appos(Sam-1, cousin-8)
</code></pre>

<p>Note however that nested apposition cannot be completely excluded. It may occur in combination with coordination:</p>

<pre><code class="language-sdparse">You can choose between four subjects , language ( German or French ) , economy , technology and art .
appos(subjects, language)
conj(language, economy)
conj(language, technology)
conj(language, art)
cc(art, and)
appos(language, German)
conj(German, French)
cc(French, or)
</code></pre>

<p><code class="language-plaintext highlighter-rouge">appos</code> is also used to link key-value pairs in addresses, signature blocs, etc. (see also the <a href="">list</a> label):</p>

<pre><code class="language-sdparse">Steve Jones Phone: 555-9814 Email: jones@abc.edf
flat:name(Steve-1, Jones-2)
list(Steve-1, Phone:-3)
list(Steve-1, Email:-5)
appos(Phone:-3, 555-9814-4)
appos(Email:-5, jones@abc.edf-6)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:14:59 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/appos.md" target="#">edit appos</a></p>

<p><a id="al-u-dep/aux" class="al-dest"></a></p>
<h2><code>aux</code>: auxiliary</h2>

<p>An <code class="language-plaintext highlighter-rouge">aux</code> (auxiliary) of a clause is a function word associated with a verbal predicate that
expresses categories such as tense, mood, aspect, voice or evidentiality. It is often a verb 
(which may have non-auxiliary uses as well) but many languages have nonverbal TAME markers and these
are also treated as instances of <code class="language-plaintext highlighter-rouge">aux</code>.</p>

<p><strong>New from v2:</strong> Auxiliaries used to construct the passive <a href="u-feat/Voice">voice</a> are now also labeled <code class="language-plaintext highlighter-rouge">aux</code>,
although we strongly encourage the use of the subtype <a href="">aux:pass</a> in languages that have a grammaticalized (periphrastic)
passive.</p>

<pre><code class="language-sdparse">Reagan has died
aux(died-3, has-2)
</code></pre>

<pre><code class="language-sdparse">He should leave
aux(leave-3, should-2)
</code></pre>

<pre><code class="language-sdparse">Do you think that he will have left by the time we come ?
aux(think, Do)
aux(left, will)
aux(left, have)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:00 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/aux_.md" target="#">edit aux</a></p>

<p><a id="al-u-dep/aux:pass" class="al-dest"></a></p>
<h2><code>aux:pass</code>: passive auxiliary</h2>

<p>A passive auxiliary of a clause is a form of the <a href="cs-pos/AUX">auxiliary verb</a> <em>být</em> “to be”
used to construct the periphrastic passive voice (in any tense or in the infinitive).</p>

<pre><code class="language-sdparse">Kennedy byl zabit . \n Kennedy was killed .
aux:pass(zabit, byl)
aux:pass(killed, was)
</code></pre>

<pre><code class="language-sdparse">Kennedy bude zabit . \n Kennedy will-be killed .
aux:pass(zabit, bude)
aux:pass(killed, will-be)
</code></pre>

<pre><code class="language-sdparse">Kennedy netušil , že jeho osudem je být zabit . \n Kennedy did-not-anticipate that his fate is to-be killed .
aux:pass(zabit, být)
aux:pass(killed, to-be)
</code></pre>

<p>Note that the passive participle may be also used as nominal predicate with <a href="cop">copula</a>.
Hence it may be difficult to distinguish a passive construction from a copula construction.
The former focuses on the process while the latter emphasizes the result.</p>

<ul>
  <li>Passive:</li>
</ul>

<pre><code class="language-sdparse">Smlouva byla podepsána v Bílém domě . \n Contract was signed in White House .
aux:pass(podepsána, byla)
aux:pass(signed, was)
</code></pre>

<ul>
  <li>Copula:</li>
</ul>

<pre><code class="language-sdparse">Smlouva byla podepsána červeným inkoustem . \n Contract was signed in-red ink .
cop(podepsána, byla)
cop(signed, was)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:03 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/aux-pass.md" target="#">edit aux:pass</a></p>

<p><a id="al-u-dep/case" class="al-dest"></a></p>
<h2><code>case</code>: case marking</h2>

<p>The <code class="language-plaintext highlighter-rouge">case</code> relation is used for any case-marking element which is treated as a separate syntactic word (including prepositions, postpositions, and clitic case markers). Case-marking elements are treated as dependents of the noun they attach to or introduce. (Thus, contrary to SD, UD abandons treating a preposition as a mediator between a modified word and its object.) The <code class="language-plaintext highlighter-rouge">case</code> relation aims at providing a more uniform analysis of nominal elements, prepositions and case in morphologically rich languages: a nominal in an oblique case will receive the same dependency structure as a nominal introduced by an adposition.</p>

<pre><code class="language-sdparse">the Chair 's office
det(Chair-2, the-1)
nmod(office-4, Chair-2)
case(Chair-2, 's-3)
</code></pre>

<pre><code class="language-sdparse">the office of the Chair
det(office-2, the-1)
nmod(office-2, Chair-5)
case(Chair-5, of-3)
det(Chair-5, the-4)
</code></pre>

<p>French:</p>

<pre><code class="language-sdparse">le bureau de le président \n the office of the Chair
det(bureau, le-1)
nmod(bureau, président)
case(président, de)
det(président, le-4)
</code></pre>

<p>Hebrew:</p>

<pre><code class="language-sdparse">hwa/PRON rah/VERB at/PART[Case=Acc] h/DET klb/NOUN \n he saw ACC the dog  
obj(rah-2, klb-5)
case(klb-5, at-3)
</code></pre>

<p>When case markers are morphemes, they are not divided off the noun as a separate case dependent,
but the noun as a whole is analyzed as <a href="">obl</a> (if dependent on a predicate) or <a href="">nmod</a> (if dependent on noun).
To overtly mark case,
<a href="../pos/index.html">POS tags</a> and
<a href="../feat/index.html">features</a>
are included in the representation as shown below on a Russian example
(put your mouse pointer over the words to see additional morphosyntactic features).</p>

<pre><code class="language-conllu"># I wrote the letter with a quill.
1   Я         ja         PRON   _   Case=Nom|Number=Sing|Person=1|PronType=Prs        2   nsubj   _   I
2   написал   napisat'   VERB   _   Gender=Masc|Number=Sing|VerbForm=Part|Voice=Act   0   root    _   wrote
3   письмо    pis'mo     NOUN   _   Case=Acc|Gender=Neut|Number=Sing                  2   obj    _   the-letter
4   пером     pero       NOUN   _   Case=Ins|Gender=Neut|Number=Sing                  2   obl    _   with-a-quill
</code></pre>

<p>This treatment provides parallelism between different constructions
across and within languages. A good result is that we now have greater
parallelism between prepositional phrases and subordinate clauses,
which are often introduced by a preposition in some languages (but note that 
the relation should be <a href="">mark</a> in those cases):</p>

<pre><code class="language-sdparse">Sue left after the rehearsal
nsubj(left-2, Sue-1)
obl(left-2, rehearsal-5)
det(rehearsal-5, the-4)
case(rehearsal-5, after-3)
</code></pre>

<pre><code class="language-sdparse">Sue left after we did
nsubj(left-2, Sue-1)
advcl(left-2, did-5)
mark(did-5, after-3)
nsubj(did-5, we-4)
</code></pre>

<p>We also obtain parallel constructions for</p>

<ul>
  <li>the possessive alternation</li>
</ul>

<pre><code class="language-sdparse">the Chair 's office
det(Chair-2, the-1)
nmod(office-4, Chair-2)
case(Chair-2, 's-3)
</code></pre>

<pre><code class="language-sdparse">the office of the Chair
det(office-2, the-1)
nmod(office-2, Chair-5)
case(Chair-5, of-3)
det(Chair-5, the-4)
</code></pre>

<ul>
  <li>variant forms with case, a preposition or a
postposition in Finnish</li>
</ul>

<pre><code class="language-sdparse">etsiä ilman johtolankaa \n to_search without clue.PARTITIVE
obl(etsiä, johtolankaa)
case(johtolankaa, ilman)
</code></pre>

<pre><code class="language-sdparse">etsiä taskulampun kanssa \n to_search torch.GENITIVE with
obl(etsiä, taskulampun)
case(taskulampun, kanssa)
</code></pre>

<pre><code class="language-sdparse">etsiä johtolangatta \n to_search clue.ABESSIVE
obl(etsiä, johtolangatta)
</code></pre>

<ul>
  <li>the dative alternation where the prepositional construction gets a similar
analysis to the double object construction</li>
</ul>

<pre><code class="language-sdparse">give the children the toys
obj(give, toys)
iobj(give, children)
</code></pre>

<pre><code class="language-sdparse">give the toys to the children
obj(give, toys)
obl(give, children)
case(children, to)
</code></pre>

<pre><code class="language-conllu"># give the toys to the children
1     donner    donner   VERB   _   VerbForm=Inf               0   root   _   give
2     les       le       DET    _   Definite=Def|Number=Plur   3   det    _   the
3     jouets    jouet    NOUN   _   Gender=Masc|Number=Plur    1   obj   _   toys
4-5   aux       _        _      _   _                          _   _      _   _
4     à         à        ADP    _   _                          6   case   _   to
5     les       le       DET    _   Definite=Def|Number=Plur   6   det    _   the
6     enfants   enfant   NOUN   _   Gender=Masc|Number=Plur    1   obl   _   children
</code></pre>

<p>Another advantage of this new analysis is that it provides a treatment
of prepositional phrases that are predicative complements of “be” that is consistent with the treatment of nominal predicative
complements:</p>

<pre><code class="language-sdparse">Sue is in shape
nsubj(shape-4, Sue-1)
cop(shape-4, is-2)
case(shape-4, in-3)
</code></pre>

<p>When prepositions are stacked (that is, there is a sequence of prepositions), there are two possible analyses. If the sequence is a frozen combination with a specific meaning, then the best analysis is as <code class="language-plaintext highlighter-rouge">fixed</code>. An English example of this is <em>out of</em>:</p>

<pre><code class="language-sdparse">Out of all this , something good will come .
case(this-4, Out-1)
fixed(Out-1, of-2)
det(this-4, all-3)
obl(come, this-4)
</code></pre>

<p>However, if various combinations of prepositions can be used to express different meaning combinations or nuances, then  each preposition is independently analyzed as a case dependent. Examples of this in English include <em>up beside</em> (which can alternate with <em>down beside</em> or <em>up near</em>) or <em>except during</em> which can alternate with <em>as during</em> or <em>except after</em>:</p>

<pre><code class="language-sdparse">The cafe up beside the lookout
det(cafe-2, The-1)
case(lookout-6, up-3)
case(lookout-6, beside-4)
det(lookout-6, the-5)
nmod(cafe-2, lookout-6)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:04 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/case.md" target="#">edit case</a></p>

<p><a id="al-u-dep/cc" class="al-dest"></a></p>
<h2><code>cc</code>: coordinating conjunction</h2>

<!--For more on coordination, see the [conj]() relation.-->
<p>A <code class="language-plaintext highlighter-rouge">cc</code> is the relation between a conjunct and
an associated <a href="../pos/CCONJ">coordinating conjunction</a>.
<!--(Note: different dependency grammars have different treatments of coordination.
We take the first conjunct as the head of the coordination.)--></p>

<pre><code class="language-sdparse">Bill is big and honest
conj(big, honest)
cc(honest, and)
</code></pre>

<div id="punct1" class="sd-parse">
We have apples , pears , oranges , and bananas .
obj(have, apples)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(bananas, and)
punct(pears, ,-4)
punct(oranges, ,-6)
punct(bananas, ,-8)
</div>

<p>A coordinating conjunction may also appear at the beginning of a
sentence. This is also attached as <code class="language-plaintext highlighter-rouge">cc</code>, even though the sentence lacks
multiple conjuncts joined with a <a href="">conj</a> relation.</p>

<pre><code class="language-sdparse">And then we left .
cc(left, And)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:15:07 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/cc.md" target="#">edit cc</a></p>

<p><a id="al-u-dep/cc:preconj" class="al-dest"></a></p>
<h2><code>cc:preconj</code>: preconjunct</h2>

<p>A preconjunct is the relation between the head of coordination and the word that appears at the
beginning of the coordination (which could be seen as the first part of a multi-word coordinating
conjunction). English examples include <em><b>either</b> … or</em>, <em><b>neither</b> … nor</em>,
<em><b>both</b> … and</em>.</p>

<pre><code class="language-sdparse">Both the boys and the girls are here
cc:preconj(boys, Both)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:15:10 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/cc-preconj.md" target="#">edit cc:preconj</a></p>

<p><a id="al-u-dep/ccomp" class="al-dest"></a></p>
<h2><code>ccomp</code>: clausal complement</h2>

<p>A clausal complement of a verb or adjective is a dependent clause 
which is a core argument. That is, it functions like an object of the verb, or
adjective.</p>

<pre><code class="language-sdparse">He says that you like to swim
ccomp(says, like)
mark(like, that)
</code></pre>

<pre><code class="language-sdparse">He says you like to swim
ccomp(says, like)
</code></pre>

<p>Such clausal complements may be finite or nonfinite. However, if the
subject of the clausal complement is controlled (that is, must be the same
as the higher subject or object, with no other possible interpretation)
the appropriate relation is <a href="">xcomp</a>.</p>

<pre><code class="language-sdparse">The boss said to start digging
ccomp(said, start)
mark(start, to)
</code></pre>

<pre><code class="language-sdparse">We started digging
xcomp(started, digging)
</code></pre>

<p>The key difference here is that, while it is possible to interpret the first
sentence to mean that the boss will not be doing any digging, in the second
sentence it is clear that the subject of <strong>digging</strong> can only be <strong>we</strong>. This is
what distinguishes <code class="language-plaintext highlighter-rouge">ccomp</code> and <code class="language-plaintext highlighter-rouge">xcomp</code>.</p>

<p>Adjectives may also license <code class="language-plaintext highlighter-rouge">ccomp</code>:</p>

<pre><code class="language-sdparse">I was afraid/ADJ that this would happen
ccomp(afraid, happen)
</code></pre>

<h3 id="reported-speech">Reported Speech</h3>

<p>With a speech verb like <em>say</em>, the content of reported speech is considered to be part of the verb’s valency. It therefore attaches as <a href="">ccomp</a>—not only when integrated within the clause as an indirect quotation (<em>said that…</em>), but also when set off as a direct quotation, even with inverted order:</p>

<pre><code class="language-sdparse">He said that he knew the muffin man .
ccomp(said, knew)
</code></pre>

<pre><code class="language-sdparse">I asked : " Do you know the muffin man ? "
ccomp(asked, know)
</code></pre>

<pre><code class="language-sdparse">" Do you know the muffin man ? " I asked .
ccomp(asked, know)
</code></pre>

<pre><code class="language-sdparse">" I had hoped to remain anonymous , " said the muffin man , who was tracked down Sunday at his home on Drury Lane .
ccomp(said, hoped)
nsubj(said, man)
</code></pre>

<p>Quoted content is considered to be <a href="">ccomp</a> even if it is a sentence fragment:</p>

<pre><code class="language-sdparse">" Three/NUM muffins/NOUN , " he answered .
nummod(muffins, Three)
ccomp(answered, muffins)
</code></pre>

<p>If the speech verb interrupts the reported speech content, <a href="">parataxis</a> is used instead. The speech verb attaches to the root of the reported speech (<em>all</em> in the following example):</p>

<pre><code class="language-sdparse">" Three muffins , " he answered , " are all that I need today . "
parataxis(all, answered)
nsubj(all, muffins)
</code></pre>

<pre><code class="language-sdparse">Weapons of mass destruction , the report explained , are designed to target civilian populations .
parataxis(designed, explained)
nsubj:pass(designed, Weapons)
</code></pre>

<pre><code class="language-sdparse">the impact that the group 's practices , law enforcement officials say , are having on the most vulnerable within the sect
acl:relcl(impact, having)
nsubj(having, practices)
parataxis(having, say)
</code></pre>

<p><em>Changed:</em></p>
<ul>
  <li>In earlier versions of SD/USD, complement clauses with nouns like <em>fact</em> or <em>report</em> were also analyzed as <code class="language-plaintext highlighter-rouge">ccomp</code>. However, we now analyze them as <a href="">acl</a>. Hence, <code class="language-plaintext highlighter-rouge">ccomp</code> does not appear in nominals. This makes sense, since nominals normally do not take core arguments.</li>
  <li>The policy for copular constructions with a full clause as predicate has been <a href="/changes.html#multiple-subjects">changed</a> to no longer use <code class="language-plaintext highlighter-rouge">ccomp</code> to nest the predicate clause under the copula.</li>
</ul>

<!-- Interlanguage links updated So 10. května 2025, 18:15:08 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/ccomp.md" target="#">edit ccomp</a></p>

<p><a id="al-u-dep/clf" class="al-dest"></a></p>
<h2><code>clf</code>: classifier</h2>

<p>A <code class="language-plaintext highlighter-rouge">clf</code> (classifier) is a word which accompanies a noun in certain grammatical contexts.
The most canonical use is numeral classifiers, where the word is used with a number for counting objects.
A classifier generally reflects some kind of
conceptual classification of nouns, based principally on features of their referents.
Etymologically, classifiers are normally historically nouns, and the words may still also be used as independent nouns,
but in their classifier use they have scant semantics left.
In most cases, the most appropriate UPOS to give classifiers will still be NOUN, though you may wish to give the words a feature
indicating their special status as a classifier. (There is at present no Universal feature for classifiers, but <code class="language-plaintext highlighter-rouge">NounType=Clf</code>
might be apt.)
The <code class="language-plaintext highlighter-rouge">clf</code> function is intended for languages which have highly grammaticalized systems of classifiers.
The greatest density of such languages is in Asia.
As well as core classifiers, there are often also other words, sometimes called “massifiers” that are used in counting with
similar behavior to classifiers. These typically include words for containers (“cup”, “box”) and units (“month”, “inch”),
such as Chinese 袋 ‘bag’ in 一袋米 [one bag rice] ‘a bag of rice’.
In a classifier language, it is usually most appropriate to also analyze these words as classifiers.
Most other languages also count things with units, however, for these languages, such as English, <code class="language-plaintext highlighter-rouge">clf</code> is not used and rather
standard noun phrase relations are still used (despite there also being incipient grammaticalization in many cases, including English).
See the examples for English at the end.</p>

<p>Here are some examples from Mandarin/Putonghua Chinese:</p>

<ul>
  <li>三个学生 (三個學生) sān gè xuéshēng = “three students”, literally “three [human-classifier] student”</li>
  <li>三棵树 (三棵樹) sān kē shù = “three trees”, literally “three [tree-classifier] tree”</li>
  <li>三只鸟 (三隻鳥) sān zhī niǎo = “three birds”, literally “three [bird-classifier] bird”</li>
  <li>三条河 (三條河) sān tiáo hé = “three rivers”, literally “three [long-wavy-classifier] river”</li>
</ul>

<p>Analogous examples from Thai:</p>

<ul>
  <li>นักเรียนสามคน nạkriaːn saːm gʰn = “three students”, literally “student three [human-classifier]”</li>
  <li>ต้นไม้สามต้น tə̂nmạî saːm tə̂n = “three trees”, literally “tree three [tree-classifier]”</li>
  <li>นกสามตัว nk saːm tuaː = “three birds”, literally “bird three [animal-classifier]”</li>
  <li>แม่น้ำสามสาย mæ̀ːnã̂ː saːm saːy = “three rivers”, literally “river three [river-classifier]”</li>
</ul>

<p>Syntactically, the classifier groups with the numeral rather than the noun and we therefore treat
classifiers as functional dependents of numerals (or possessives) using the new <code class="language-plaintext highlighter-rouge">clf</code> relation. (This
is one of Greenberg’s universals and is true in almost all cases.
A couple of exceptions are noted in Aikhenvald (2000: 105) <em>Classifiers</em>, OUP, but it is noticeable that in those languages
the putative head noun is in the genitive case.)</p>

<pre><code class="language-sdparse">三/NUM 个/NOUN 学生/NOUN \n sān gè xuéshēng \n three CLF student
nummod(学生, 三)
clf(三, 个)
nummod(xuéshēng, sān)
clf(sān, gè)
nummod(student, three)
clf(three, CLF)
</code></pre>

<pre><code class="language-sdparse">แมว/NOUN สาม/NUM ตัว/NOUN \n mæːw saːm tuaː \n cat three CLF
nummod(แมว, สาม)
clf(สาม, ตัว)
nummod(mæːw, saːm)
clf(saːm, tuaː)
nummod(cat, three)
clf(three, CLF)
</code></pre>

<p>Sometimes a classifier is inserted between a demonstrative and a noun (instead of numeral and noun) [zh]:</p>

<pre><code class="language-sdparse">乘坐 這 輛 巴士 \n Chéngzuò zhè liàng bāshì \n Take this CLF bus
obj(乘坐, 巴士)
det(巴士, 這)
clf(這, 輛)
obj(Chéngzuò, bāshì)
det(bāshì, zhè)
clf(zhè, liàng)
obj(Take, bus)
det(bus, this)
clf(this, CLF)
</code></pre>

<p>Classifier words also occur in various other constructions, and so it is important to distinguish the word in a particular
language from the universal classifier function proposed in UD. We go here through some further examples with Chinese classifiers.</p>

<p>The number and classifier may appear without the counted noun.
In this case, the classifier takes the role of the missing noun, and we promote the classifier to be the head.
So 我 買 兩 本 “I am buying two” is regarded as “I am buying two [books-CLF]”.</p>

<pre><code class="language-sdparse">我 買 兩 本 \n I buy two CLF
obj(買, 本)
nummod(本, 兩)
</code></pre>

<p>In some languages, including Chinese, a classifier can also appear without a number, and frequently then has some sort of
determinative function. We use the relation <code class="language-plaintext highlighter-rouge">det</code> for such uses of a classifier. For instance, in Cantonese ‘She bought a/the book’:</p>

<pre><code class="language-sdparse">佢 買 咗 本 書 \n keoi maai zo bun syu \n 3sg buy PERF CLF book
obj(買, 書)
det(書, 本)
</code></pre>

<p>For languages without highly grammaticalized classifier systems, standard nominal modification relationships are used
even when things are being counted in groups (with “massifiers”). For example, in English:</p>

<pre><code class="language-sdparse">three cups of rolled oats
nummod(cups, three)
case(oats, of)
amod(oats, rolled)
nmod(cups, oats)
</code></pre>

<pre><code class="language-sdparse">three cups rolled oats
nummod(cups, three)
amod(oats, rolled)
nmod(cups, oats)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:10 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/clf.md" target="#">edit clf</a></p>

<p><a id="al-u-dep/compound" class="al-dest"></a></p>
<h2><code>compound</code>: compound</h2>

<p>The <code class="language-plaintext highlighter-rouge">compound</code> relation is used to analyze compounds, that is, combinations of lexemes that morphosyntactically behave as single words. Commonly occurring cases are:</p>

<ul>
  <li>Nominal compounds written as separate words, for example English <em><b>apple juice</b></em>.</li>
  <li>Particle verbs where the particle is realized as a separate word (which may alternate with affixed particles), for example Swedish <em><b>byta ut</b></em> (‘exchange’; cf. <em><b>utbytt</b></em>, ‘exchanged’). The subtype <a href="">compound:prt</a> is commonly used in this case.</li>
  <li>Serial verbs, for which the subtype <a href="">compound:svc</a> is commonly used, as in this Nupe example <a href="https://doi.org/10.4324/9780429243592">(Tallerman 2014)</a>:</li>
</ul>

<pre><code class="language-sdparse">Musa bé lá èbi \n Musa came took knife \n Musa came to take the knife
nsubj(bé, Musa)
compound:svc(bé, lá)
obj(bé, èbi)
</code></pre>

<p>Each language that uses <code class="language-plaintext highlighter-rouge">compound</code> should develop its own specific criteria based on morphosyntax (rather than lexicalization or semantic idiomaticity), though elsewhere the term “compound” may be used more broadly.</p>

<p><strong>See also:</strong></p>
<ul>
  <li><a href="/workgroups/newdoc/two_nominals.html">Two Nominals working group</a>.</li>
  <li><a href="/u/dep/expl.html#reflexives">Expletive reflexives</a></li>
</ul>

<h2 id="english-examples">English Examples</h2>

<pre><code class="language-sdparse">phone book
compound(book, phone)
</code></pre>

<pre><code class="language-sdparse">ice cream flavors
compound(cream, ice)
compound(flavors, cream)
</code></pre>

<pre><code class="language-sdparse">Sam took out a 3 million dollar loan
compound(loan, dollar)
</code></pre>

<pre><code class="language-sdparse">Sam took out a $ 3 million loan
compound(loan, $)
</code></pre>

<pre><code class="language-sdparse">put up
compound:prt(put, up)
</code></pre>

<h3 id="not-compound">Not <code class="language-plaintext highlighter-rouge">compound</code></h3>

<p>Just because an expression is lexicalized or idiomatic does not mean <code class="language-plaintext highlighter-rouge">compound</code> applies.
In English, adjective-noun combinations, prepositional phrases, and light verb constructions are better described with other relations:</p>

<pre><code class="language-sdparse">hot dog
amod(dog, hot)
</code></pre>

<pre><code class="language-sdparse">the state of play
det(state, the)
nmod(state, play)
case(play, of)
</code></pre>

<pre><code class="language-sdparse">make a decision
obj(make, decision)
det(decision, a)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:15:11 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/compound.md" target="#">edit compound</a></p>

<p><a id="al-u-dep/compound:lvc" class="al-dest"></a></p>
<h2><code>compound:lvc</code>: light verb construction</h2>

<p>This subtype of <a href="">compound</a> covers light verbs.
In a  light-verb construction the verb does not have much semantic content.
The semantics of the construction are determined by the non-head word,
often a noun or adjective.</p>

<pre><code class="language-sdparse">Onlar treni tercih ediyor . \n They prefer the train .
compound:lvc(ediyor, tercih)
obj(ediyor, treni)
subj(ediyor, Onlar)
</code></pre>

<p>Most common verbs that act like as a light verb is <em>et-</em>.
However, many other are possible.</p>

<pre><code class="language-sdparse">Yıllarca çile çektiler . \n They suffered for years .
compound:lvc(çektiler, çile)
</code></pre>

<p>Although the semantically loaded component of a light-verb construction is
generally an adjective or a noun,
it is common to observe verbs in this position particularly in code-switching settings.</p>

<pre><code class="language-sdparse">Partiyi  cancel ettik . \n We canceled the party
compound:lvc(ettik, cancel)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:12 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/compound-lvc.md" target="#">edit compound:lvc</a></p>

<p><a id="al-u-dep/compound:prt" class="al-dest"></a></p>
<h2><code>compound:prt</code>: phrasal verb particle</h2>

<p>The phrasal verb particle relation identifies an idiomatic phrasal verb, and
holds between the verb and its particle (tagged as <a href="">ADP</a>). It is a subtype of the
<a href="">compound</a> relation.</p>

<pre><code class="language-sdparse">They shut down the station
compound:prt(shut, down)
</code></pre>

<pre><code class="language-sdparse">They shut the station down
compound:prt(shut, down)
</code></pre>

<p>This relation excludes literal/directional uses of prepositions/particles, such as <em>up</em>, <em>down</em>, <em>in</em>, <em>out</em>, etc.
These would typically become an ADV with the relation <a href="">advmod</a>:</p>

<pre><code class="language-sdparse">The house was on fire and they ran out screaming.
advmod(ran, out)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:15:14 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/compound-prt.md" target="#">edit compound:prt</a></p>

<p><a id="al-u-dep/compound:redup" class="al-dest"></a></p>
<h2><code>compound:redup</code>: reduplicated compounds</h2>

<p>This subtype of <a href="">compound</a> covers a range of reduplicated forms in Turkish.
Reduplication is a common process especially for <a href="tr-pos/ADV">adverbs</a> and <a href="tr-pos/ADJ">adjectives</a>.
Except for m-reduplication (see below),
the head is the last word.</p>

<p>The reduplication typically involves two identical words,
but some morpho-phonological alternations (as in m-reduplication in example 3 below) are possible.</p>

<pre><code class="language-sdparse">Koca koca adamlar oyun oynuyorlar . \n _Big (+emph)_ men are playing games .
compound:redup(koca-2, Koca-1)
</code></pre>

<pre><code class="language-sdparse">Açık açık söylüyorum . \n I am telling it _clearly_
compound:redup(açık-2, Açık-1)
</code></pre>

<pre><code class="language-sdparse">Araba maraba almışlar . \n They bought (a) car (and things like that)
compound:redup(Araba, maraba)
</code></pre>

<p>For lexicalized multi-word items with repetition where one or more of the words are not free lexemes, (e.g. <em>paldır küldür</em>, <em>ufak tefek</em>), we use <a href="">fixed</a>.
<!-- Interlanguage links updated So 10. května 2025, 18:15:14 CEST --></p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/compound-redup.md" target="#">edit compound:redup</a></p>

<p><a id="al-u-dep/compound:svc" class="al-dest"></a></p>
<h2><code>compound:svc</code>: serial verb compounds</h2>

<p>The relation <code class="language-plaintext highlighter-rouge">compound:svc</code> is used for serial verb constructions. In this type of construction, several verbs are combined to describe the same action.</p>

<pre><code class="language-conllu"># visual-style 2 4 compound:svc	color:blue
# visual-style 4	bgColor:blue
# visual-style 4	fgColor:white
# visual-style 2	bgColor:blue
# visual-style 2	fgColor:white
1	dem	them	PRON	PRON	_	2	nsubj	_
2	enter	enter	VERB	VERB	_	0	root	_	_
3	bus	bus	NOUN	NOUN	_	2	obj	_	_
4	go	go	VERB	VERB	_	2	compound:svc	_	_
5	work	work	NOUN	NOUN	_	4	obj	_	_

1	they	_	_	_	_	0	_	_	_
2	enter	_	_	_	_	0	_	_	_
3	bus	_	_	_	_	0	_	_	_
4	go	_	_	_	_	0	_	_	_
5	work	_	_	_	_	0	_	_	_

1	They	_	_	_	_	0	_	_	_
2	take	_	_	_	_	0	_	_	_
3	the	_	_	_	_	0	_	_	_
4	bus	_	_	_	_	0	_	_	_
5	to	_	_	_	_	0	_	_	_
6	work	_	_	_	_	0	_	_	_
</code></pre>

<p>The verbs in a serial verb construction share the same subject but not necessarily the same object.</p>

<pre><code class="language-conllu"># visual-style 4 7 compound:svc	color:blue
# visual-style 4	bgColor:blue
# visual-style 4	fgColor:white
# visual-style 7	bgColor:blue
# visual-style 7	fgColor:white
# visual-style 13 15 compound:svc	color:blue
# visual-style 13	bgColor:blue
# visual-style 13	fgColor:white
# visual-style 15	bgColor:blue
# visual-style 15	fgColor:white
1	so	so	ADV	SCONJ	_	4	advmod	_	_
2	we	we	PRON	PRON	_	4	nsubj	_	_
3	don	don	AUX	AUX	_	4	aux	_	_
4	carry	carry	VERB	VERB	_	0	root	_	_
5	di	the	DET	DET	_	6	det	_	_
6	matter	matter	NOUN	NOUN	_	4	obj	_	_
7	come	come	VERB	VERB	_	4	compound:svc	_	_
8	again	again	ADV	ADV	_	7	advmod	_	_
9	as	as	SCONJ	ADP	_	13	mark	_	_
10	we	we	PRON	PRON	_	13	nsubj	_	_
11	dey	be	AUX	AUX	_	13	aux	_	_
12	always	always	ADV	ADV	_	13	advmod	_	_
13	carry	carry	VERB	VERB	_	7	advcl	_	_
14	am	he	PRON	PRON	_	13	obj	_	_
15	come	come	VERB	VERB	_	13	compound:svc	_	_

1	so	_	_	_	_	0	_	_	_
2	we	_	_	_	_	0	_	_	_
3	have	_	_	_	_	0	_	_	_
4	carry	_	_	_	_	0	_	_	_
5	the	_	_	_	_	0	_	_	_
6	matter	_	_	_	_	0	_	_	_
7	come	_	_	_	_	0	_	_	_
8	again	_	_	_	_	0	_	_	_
9	as	_	_	_	_	0	_	_	_
10	we	_	_	_	_	0	_	_	_
11	be	_	_	_	_	0	_	_	_
12	always	_	_	_	_	0	_	_	_
13	carry	_	_	_	_	0	_	_	_
14	it	_	_	_	_	0	_	_	_
15	come	_	_	_	_	0	_	_	_

1	so	_	_	_	_	0	_	_	_
2	we	_	_	_	_	0	_	_	_
3	have	_	_	_	_	0	_	_	_
4	brought	_	_	_	_	0	_	_	_
5	the	_	_	_	_	0	_	_	_
6	issue	_	_	_	_	0	_	_	_
7	again	_	_	_	_	0	_	_	_
8	as	_	_	_	_	0	_	_	_
9	we	_	_	_	_	0	_	_	_
10	always	_	_	_	_	0	_	_	_
11	do	_	_	_	_	0	_	_	_
</code></pre>

<p>An adjective may be used in place of a verb in a serial verb construction.</p>

<pre><code class="language-conllu"># visual-style 3 4 compound:svc	color:blue
# visual-style 4	bgColor:blue
# visual-style 4	fgColor:white
# visual-style 3	bgColor:blue
# visual-style 3	fgColor:white
1	di	the	DET	DET	_	2	det	_	_
2	guy	guy	NOUN	NOUN	_	3	nsubj	_	_
3	fine	fine	ADJ	ADJ	_	0	root	_	_
4	reach	arrive	VERB	VERB	_	3	compound:svc	_	_
5	me	I	PRON	PRON	_	4	obj	_	_

1	the	_	_	_	_	0	_	_	_
2	guy	_	_	_	_	0	_	_	_
3	fine	_	_	_	_	0	_	_	_
4	reach	_	_	_	_	0	_	_	_
5	me	_	_	_	_	0	_	_	_

1	Is	_	_	_	_	0	_	_	_
2	the	_	_	_	_	0	_	_	_
3	guy	_	_	_	_	0	_	_	_
4	as	_	_	_	_	0	_	_	_
5	handsome	_	_	_	_	0	_	_	_
6	as	_	_	_	_	0	_	_	_
7	I	_	_	_	_	0	_	_	_
8	am	_	_	_	_	0	_	_	_
</code></pre>

<h3 id="comparatives">Comparatives</h3>

<p>In Naija serial verbs constructions are also used for comparatives. In these constructions the adjective which is being used to draw the comparison is followed by the verb <em>pass</em>.</p>

<pre><code class="language-conllu"># visual-style 2 3 compound:svc	color:blue
# visual-style 3	bgColor:blue
# visual-style 3	fgColor:white
# visual-style 2	bgColor:blue
# visual-style 2	fgColor:white
1	farmer	farmer	NOUN	NOUN	_	2	nsubj	_	_
2	happy	happy	ADJ	ADJ	_	0	root	_	_
3	pass	pass	VERB	VERB	_	2	compound:svc	
4	when	when	ADV	ADV	_	6	mark	_	_
5	rain	rain	NOUN	NOUN	_	6	nsubj	_	_
6	fall	fall	VERB	VERB	_	2	advcl	_	_
7	like	like	ADP	ADP	_	8	case	_	_
8	dis	this	DET	DET	_	6	obl	_	_

1	farmers	_	_	_	_	0	_	_	_
2	happy	_	_	_	_	0	_	_	_
3	exceed	_	_	_	_	0	_	_	_
4	when	_	_	_	_	0	_	_	_
5	rain	_	_	_	_	0	_	_	_
6	fall	_	_	_	_	0	_	_	_
7	like	_	_	_	_	0	_	_	_
8	this	_	_	_	_	0	_	_	_

1	Farmers	_	_	_	_	0	_	_	_
2	become	_	_	_	_	0	_	_	_
3	happier	_	_	_	_	0	_	_	_
4	when	_	_	_	_	0	_	_	_
5	rain	_	_	_	_	0	_	_	_
6	falls	_	_	_	_	0	_	_	_
7	like	_	_	_	_	0	_	_	_
8	this	_	_	_	_	0	_	_	_
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:14 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/compound-svc.md" target="#">edit compound:svc</a></p>

<p><a id="al-u-dep/conj" class="al-dest"></a></p>
<h2><code>conj</code>: conjunct</h2>

<p>A conjunct is the relation between two elements connected by a
coordinating conjunction, such as <em>and, or,</em> etc. Coordinate structures 
are in principle symmetrical, but the first conjunction is by convention 
treated as the parent (or “technical head”) of all subsequent coordinated clauses 
via the <code class="language-plaintext highlighter-rouge">conj</code> relation.</p>

<pre><code class="language-sdparse">Bill is big and honest
conj(big, honest)
</code></pre>

<div id="punct1" class="sd-parse">
We have apples , pears , oranges , and bananas .
obj(have, apples)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(bananas, and)
punct(pears, ,-4)
punct(oranges, ,-6)
punct(bananas, ,-8)
</div>

<p>Coordinated clauses are treated the same way as coordination of other constituent types:</p>

<pre><code class="language-sdparse">He came home , took a shower and immediately went to bed .
conj(came, took)
conj(came, went)
punct(took, ,-4)
cc(went, and)
</code></pre>

<p>Coordination may be <em>asyndetic,</em> which means that the coordinating conjunction is omitted.
Commas or other punctuation symbols will delimit the conjuncts in the typical case.
Asyndetic coordination may be more frequent in some languages, while in others,
conjunction will appear between every two conjuncts <em>(John and Mary and Bill).</em></p>

<pre><code class="language-sdparse">Veni , vidi , vici .
conj(Veni, vidi)
conj(Veni, vici)
punct(vidi, ,-2)
punct(vici, ,-4)
</code></pre>

<p>Unlike elements may be related by <code class="language-plaintext highlighter-rouge">conj</code> as a result of ellipsis.
In the following examples, the first element is a main clause while the second has the form of a modifier.
We understand there to be ellipsis of the main predicate (<em>but [we can visit] only after…</em>):</p>

<pre><code class="language-sdparse">We can visit grandma , but/CCONJ only after taking a nap .
conj(visit, taking)
cc(taking, but)
</code></pre>

<pre><code class="language-sdparse">We can visit grandma , but/CCONJ only after a nap .
conj(visit, nap)
cc(nap, but)
</code></pre>

<h3 id="shared-dependents-and-effective-parents-in-coordination">Shared Dependents and Effective Parents in Coordination</h3>

<p>Note that the current basic annotation scheme cannot distinguish between a dependent of the first conjunct
and a shared dependent of the whole coordination:</p>

<pre><code class="language-sdparse">He met her at the station and kissed her .
conj(met, kissed)
nsubj(met, He)
</code></pre>

<p>vs.</p>

<pre><code class="language-sdparse">He met her at the station and she kissed him .
conj(met, kissed)
nsubj(met, He)
nsubj(kissed, she)
</code></pre>

<p>In contrast, the additional dependencies in the <a href="/u/overview/enhanced-syntax.html">enhanced representation</a>
can be used to encode the fact that in the first case, <em>he</em> is also subject of <em>kissed:</em></p>

<pre><code class="language-sdparse">He met her at the station and kissed her .
conj(met, kissed)
nsubj(met, He)
nsubj(kissed, He)
</code></pre>

<p>Furthermore, the enhanced representation can also capture the relation of each conjunct
to the parent of the coordination. Nevertheless, the effective parents can be found
algorithmically and showing them explicitly is for convenience only, while
the information about shared dependents is otherwise not available.</p>

<pre><code class="language-sdparse">I saw that he met her at the station and kissed her .
conj(met, kissed)
nsubj(met, he)
nsubj(kissed, he)
ccomp(saw, met)
ccomp(saw, kissed)
</code></pre>

<p>If a dependent is shared among conjuncts, the basic representation always links it to the
first conjunct (coordination head), while the enhanced representation shows all dependencies.
In the following example, relations that are only part of the enhanced representation are shown in red.</p>

<pre><code class="language-conllu"># visual-style 6 1 amod color:red
# visual-style 4 3 amod color:red
# visual-style 6 3 amod color:red
1 American   _ _ _ _ 4 amod 6:amod        _
2 and        _ _ _ _ 3 cc   _             _
3 British    _ _ _ _ 1 conj 4:amod|6:amod _
4 professors _ _ _ _ 0 root _             _
5 and        _ _ _ _ 6 cc   _             _
6 students   _ _ _ _ 4 conj 0:root        _
</code></pre>

<h3 id="nested-coordination">Nested Coordination</h3>

<p>Note further that the basic annotation scheme has only a limited capability to capture nested coordination
such as <em>apples and pears or oranges and lemons.</em>
Consider coordinations</p>

<ul>
  <li>A, B, C</li>
  <li>(A, B), C</li>
  <li>A, (B, C)</li>
</ul>

<p>The first two cases, i.e., (A, B, C) and ((A, B), C), lead to the same tree:</p>

<pre><code class="language-sdparse">A B C
conj(A, B)
conj(A, C)
</code></pre>

<p>Only the right-nesting case (A, (B, C)) can be distinguished because its tree is different:</p>

<pre><code class="language-sdparse">A B C
conj(B, C)
conj(A, B)
</code></pre>

<h3 id="etc"><em>Etc.</em></h3>

<p>The item <em>etc.</em>, used as a set-expander—especially in coordinations after at least two other items,
and typically not preceded by a conjunction (though <em>and etc.</em> is attested in English)—is treated
as a <a href="">NOUN</a> and final conjunct. Its distribution is, however, atypical of nouns in that it is
restricted to enumeration contexts, does not permit modification except by reduplication, and may
be post-coordinated with things that are not nominals. Note that this guideline applies to English
and other languages that borrowed the string <em>etc.</em> from Latin. The situation may be different in
languages that have their own equivalent of <em>etc.</em> For example, German <em>usw. (und so weiter)</em> and
Czech <em>atd. (a tak dále)</em>, both meaning literally “and so further”, are <a href="">ADV</a> rather than <code class="language-plaintext highlighter-rouge">NOUN</code>,
because their main element is an adverb; yet they are still attached as <a href="">conj</a> to the head of
the preceding list or coordination.</p>

<div id="etc1" class="sd-parse">
We have apples/NOUN , pears/NOUN , etc./NOUN
nsubj(have, We)
obj(have, apples)
conj(apples, pears)
conj(apples, etc.)
punct(pears, ,-4)
punct(etc., ,-6)
</div>

<div id="usw1" class="sd-parse">
nur ein paar Minuten Fußmarsch zu Fisherman/PROPN 's Wharf , Lombard/PROPN Street , usw/ADV ...
advmod(Minuten, nur)
det(paar, ein)
det(Minuten, paar)
nmod(Minuten, Fußmarsch)
case(Fisherman, zu)
flat(Fisherman, 's)
flat(Fisherman, Wharf)
conj(Fisherman, Lombard)
punct(Lombard, ,-10)
flat(Lombard, Street)
conj(Fisherman, usw)
punct(usw, ,-13)
punct(Minuten, ...)
</div>

<div id="etc2" class="sd-parse">
People were running/VERB , jumping/VERB , dancing/VERB , etc./NOUN all around us .
nsubj(running, People)
aux(running, were)
conj(running, jumping)
conj(running, dancing)
conj(running, etc.)
punct(jumping, ,-4)
punct(dancing, ,-6)
punct(etc., ,-8)
obl(running, us)
case(us, around)
punct(running, .)
</div>

<div id="etc3" class="sd-parse">
They gave Amy an apple , Bob a banana , Carl a carrot , etc./NOUN
nsubj(gave, They)
iobj(gave, Amy)
obj(gave, apple)
conj(gave, banana)
conj(gave, carrot)
conj(gave, etc.)
orphan(banana, Bob)
orphan(carrot, Carl)
det(apple, an)
det(banana, a-8)
det(carrot, a-12)
punct(banana, ,-6)
punct(carrot, ,-10)
</div>

<div id="etc4" class="sd-parse">
It is commonplace to buy flowers etc./NOUN for Valentine 's Day .
conj(flowers, etc.)
</div>

<!-- Interlanguage links updated So 10. května 2025, 18:15:16 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/conj.md" target="#">edit conj</a></p>

<p><a id="al-u-dep/cop" class="al-dest"></a></p>
<h2><code>cop</code>: copula</h2>

<p>A <code class="language-plaintext highlighter-rouge">cop</code> (copula) is the relation of a function word used to link a subject to a <a href="/u/overview/simple-syntax.html#nonverbal-clauses">nonverbal predicate</a>, including the expression of identity predication (e.g. sentences like “Kim is the President”).
It is often a verb but nonverbal (pronominal) copulas are also frequent in the world’s languages.
Verbal copulas are tagged <a href="">AUX</a>, not <code class="language-plaintext highlighter-rouge">VERB</code>. Pronominal copulas are tagged <a href="">PRON</a> or <a href="">DET</a>.</p>

<p>The <code class="language-plaintext highlighter-rouge">cop</code> relation
should only be used for pure copulas that add at most TAME categories to the meaning of the predicate,
which means that most languages have at most one copula, and only when the nonverbal predicate is treated
as the head of the clause.</p>

<p>As a concrete example, in many European languages the equivalent of the English verb <em>to be</em> is the only word that can appear with the <code class="language-plaintext highlighter-rouge">cop</code> relation. In Spanish and related languages, both <em>ser</em> and <em>estar</em> can be copulas. In Czech and related languages, both <em>být</em> and <em>bývat</em> are copulas (because they are morphological variants of the same lexeme, and the reason they have two lemmas is that aspect-related morphology is treated as derivational in these languages). In contrast, the equivalents of <em>to become</em> are not copulas despite the fact that traditional grammar may label them as such. Existential <em>to be</em> can be copula only if it is the same verb as in equivalence clauses <em>(John is a teacher)</em>. If a language uses two different verbs, then the existential one is not a copula. Some more discussion of the topic is archived <a href="https://universaldependencies.org/v2/copula.html#guidelines-for-udv2">here</a>.</p>

<pre><code class="language-sdparse">Bill is honest
nsubj(honest, Bill)
cop(honest, is)
</code></pre>

<pre><code class="language-sdparse">Ivan is the best dancer
nsubj(dancer-5, Ivan-1)
cop(dancer-5, is-2)
det(dancer-5, the-3)
amod(dancer-5, best-4)
</code></pre>

<p>The copula <em>be</em> is not treated as the head of a clause, but rather the nonverbal predicate, as exemplified above.</p>

<p>Such an analysis is motivated by the fact that many languages often or always lack an overt copula in such
constructions, as in the the following Russian and Hebrew examples:</p>

<pre><code class="language-sdparse">Ivan lučšij tancor \n Ivan best dancer
nsubj(tancor, Ivan)
amod(tancor, lučšij)
</code></pre>

<pre><code class="language-sdparse">ani Kim \n I am Kim
nsubj(Kim-2, ani-1)
</code></pre>

<p>In informal English, this may also arise.</p>

<pre><code class="language-sdparse">Email usually free if you have Wifi.
nsubj(free, Email)
</code></pre>

<p>This analysis is adopted also when the predicate is a prepositional phrase, provided that the same copula
(or absence thereof) is used here, in which case the nominal part of the
prepositional phrase is the head of the clause.</p>

<pre><code class="language-sdparse">Sue is in shape
nsubj(shape, Sue)
cop(shape, is)
case(shape, in)
</code></pre>

<!--A parallel can also be drawn to so-called raising-to-object or small clause constructions in English.
Under the basic analysis proposed for SD, the predicate complement is
not linked to its subject argument, but in the enhanced representation
(see below), the linkage is then parallel to the treatment in a zero
copula language:

~~~ sdparse
I judge Ivan the best dancer
nsubj(judge-2, I-1)
obj(judge-2, Ivan-3)
xcomp(judge-2, dancer-6)
det(dancer-6, the-4)
amod(dancer-6, best-5)
nsubj(dancer-6, Ivan-3)
~~~
-->

<p>If the copula is accompanied by other verbal auxiliaries for tense, aspect, etc., then they are also given a flat structure, and taken as dependents of the lexical predicate:</p>

<pre><code class="language-sdparse">Sue has been helpful
nsubj(helpful, Sue)
cop(helpful, been)
aux(helpful, has)
</code></pre>

<p>The motivation for this choice is that this structure is parallel to the flat structure which we give to auxiliary verbs accompanying verbs. In particular, in languages such as English, it is often very difficult to decide whether to regard a participle as a verb or an adjective.  Perhaps the following sentence is such a case:</p>

<pre><code class="language-sdparse">The presence of troops will be destabilizing .
nsubj(destabilizing, presence)
cop/aux(destabilizing, be)
aux(destabilizing, will)
</code></pre>

<p>While a part of speech (and associated deprel: <code class="language-plaintext highlighter-rouge">cop</code> vs. <code class="language-plaintext highlighter-rouge">aux</code>) has to be decided in such cases, it would be unfortunate if the choice of part of speech also changed the dependency structure. Note, however, that the exact distribution of the copula construction is subject to language-specific variation.</p>

<p>Finally, the <code class="language-plaintext highlighter-rouge">cop</code> may mark a <a href="/u/overview/complex-syntax.html#predicate-clauses">predicate clause</a>, i.e., a full clause serving as the predicate within an outer copular clause. 
In such cases, <a href="">nsubj:outer</a> or <a href="">csubj:outer</a> can be used to distinguish the outer subject:</p>

<pre><code class="language-sdparse">-ROOT- The problem is that this has never been tried .
nsubj:outer(tried, problem)
cop(tried, is)
mark(tried, that)
nsubj:pass(tried, this)
aux(tried, has)
advmod(tried, never)
aux:pass(tried, been)
root(-ROOT-, tried)
</code></pre>

<pre><code class="language-sdparse">The important thing is to keep calm .
nsubj:outer(keep, thing)
cop(keep, is)
mark(keep, to)
xcomp(keep, calm)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:15:18 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/cop.md" target="#">edit cop</a></p>

<p><a id="al-u-dep/csubj" class="al-dest"></a></p>
<h2><code>csubj</code>: clausal subject</h2>

<p>A clausal subject is a clausal syntactic subject of a clause, i.e.,
the subject is itself a clause. The governor of this relation might
not always be a verb: when the verb is a copular verb, the root of the
clause is the complement of the copular verb. The dependent is the main lexical verb or other 
predicate of the subject clause.</p>

<pre><code class="language-sdparse">That he lied surprised me .
csubj(surprised, lied)
mark(lied, That)
nsubj(lied, he)
obj(surprised, me)
</code></pre>

<pre><code class="language-sdparse">Whether he lied is unknown .
csubj(unknown, lied)
mark(lied, Whether)
nsubj(lied, he)
cop(unknown, is)
</code></pre>

<p><strong>New from v2:</strong> The <code class="language-plaintext highlighter-rouge">csubj</code> relation is also used for the clausal subject of a passive verb or verb group. For languages
that have a grammaticalized passive transformation, it is strongly recommended to use the subtype <a href="">csubj:pass</a> in 
such cases. If the subject is of a copular clause whose predicate is itself a clause, <a href="">csubj:outer</a> may be used.</p>

<p>See also expletive subject examples under <a href="">expl</a> that use <code class="language-plaintext highlighter-rouge">csubj</code>.</p>

<!-- Interlanguage links updated So 10. května 2025, 18:15:19 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/csubj.md" target="#">edit csubj</a></p>

<p><a id="al-u-dep/csubj:outer" class="al-dest"></a></p>
<h2><code>csubj:outer</code>: outer clause clausal subject</h2>

<p>This relation specifies a clausal subject of a copular clause whose predicate is itself a clause, 
to signal that it is not the subject of the nested clause.
See discussion of <a href="../overview/complex-syntax.html#predicate-clauses">Predicate Clauses</a>.</p>

<pre><code class="language-sdparse">-ROOT- To hike in the mountains is to experience the best of nature .
root(-ROOT-, experience)
csubj:outer(experience, hike)
obl(hike, mountains)
mark(hike, To)
cop(experience, is)
mark(experience, to)
obj(experience, best)
</code></pre>

<pre><code class="language-sdparse">For us to not attempt to solve the problem is for us to acknowledge defeat .
mark(attempt, For)
nsubj(attempt, us-2)
mark(attempt, to-3)
xcomp(attempt, solve)
csubj:outer(acknowledge, attempt)
cop(acknowledge, is)
mark(acknowledge, for)
nsubj(acknowledge, us-12)
obj(acknowledge, defeat)
</code></pre>

<p>The nominal counterpart of this relation is <a href="">nsubj:outer</a>.</p>

<p>The <code class="language-plaintext highlighter-rouge">:outer</code> subtype is <em>not</em> intended for most clausal subjects of copular clauses—only those where the predicate is itself a clause. 
Plain <a href="">csubj</a> (or another subtype) will be appropriate if the copular clause predicate is a nominal, adjective, etc.:</p>

<pre><code class="language-sdparse">It is very important that your students respect you .
expl(important, It)
csubj(important, respect)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:20 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/csubj-outer.md" target="#">edit csubj:outer</a></p>

<p><a id="al-u-dep/csubj:pass" class="al-dest"></a></p>
<h2><code>csubj:pass</code>: clausal passive subject</h2>

<p>A clausal passive subject is a clausal syntactic subject of a passive clause.</p>

<pre><code class="language-sdparse">That she lied was suspected by everyone
csubj:pass(suspected, lied)
</code></pre>

<pre><code class="language-sdparse">Bylo mi doporučeno , abych to velmi dobře zvážil . \n It-has-been to-me recommended , that-I it very well weigh .
csubj:pass(doporučeno, zvážil)
csubj:pass(recommended, weigh)
</code></pre>

<p>Reflexive passive (the meaning is “You are not expected to come before nine o’clock.”)</p>

<pre><code class="language-sdparse">Nepředpokládá se , že přijdete před devátou . \n It-does-not-expect itself , that you-will-come before nine .
csubj:pass(Nepředpokládá, přijdete)
csubj:pass(It-does-not-expect, you-will-come)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:21 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/csubj-pass.md" target="#">edit csubj:pass</a></p>

<p><a id="al-u-dep/dep" class="al-dest"></a></p>
<h2><code>dep</code>: unspecified dependency</h2>

<p>A dependency can be labeled as <code class="language-plaintext highlighter-rouge">dep</code> when it is impossible to determine a more precise relation.
This may be because of a weird grammatical construction, or a limitation in conversion or parsing software.
The use of <code class="language-plaintext highlighter-rouge">dep</code> should be avoided as much as possible.</p>

<pre><code class="language-sdparse">my dad does nt really not that good
nmod(dad, my)
nsubj(does, dad)
advmod(does, nt)
advmod(does, really)
dep(does, good)
advmod(good, not)
advmod(good, that)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:15:22 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/dep.md" target="#">edit dep</a></p>

<p><a id="al-u-dep/det" class="al-dest"></a></p>
<h2><code>det</code>: determiner</h2>

<p>The relation determiner (<code class="language-plaintext highlighter-rouge">det</code>) holds between a nominal head and its
<a href="u-pos/DET">determiner</a>. Most commonly, a word of POS <code class="language-plaintext highlighter-rouge">DET</code> will have the relation <code class="language-plaintext highlighter-rouge">det</code> and vice versa. The known exceptions at present are:</p>

<ul>
  <li>In some of the datasets, a possessive determiner like [en] <em>my</em> is currently given the POS tag <code class="language-plaintext highlighter-rouge">DET</code> but the relation <a href="">nmod</a>, so that it is parallel with other possessive constructions. This is not yet completely parallel across languages; in some languages, it is much more clear than in English how possessive determiners relate to adjectives, and the <code class="language-plaintext highlighter-rouge">nmod</code> relation is out of question.</li>
</ul>

<pre><code class="language-sdparse">The man is here
det(man, The)
</code></pre>

<pre><code class="language-sdparse">Which book do you prefer ?
det(book, Which)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:25 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/det.md" target="#">edit det</a></p>

<p><a id="al-u-dep/det:numgov" class="al-dest"></a></p>
<h2><code>det:numgov</code>: pronominal quantifier governing the case of the noun</h2>

<p>Pronominal quantifiers in Slavic languages are labeled <code class="language-plaintext highlighter-rouge">det:numgov</code> instead of <a href="">det</a>
because they normally do not agree with the quantified noun in case
(unlike non-quantifying determiners).</p>

<p>The quantifier requires the counted noun to be in its genitive form.
The whole phrase (quantifier + noun) is treated as a singular neuter noun phrase
and it can fill roles where nominative, accusative or vocative noun phrases are expected.</p>

<p>To increase parallelism across languages (and also across morphological cases within one language),
the quantifier is not annotated as the head of the nominal. However, the <code class="language-plaintext highlighter-rouge">det:numgov</code> label is used
to preserve the information about case conditions.</p>

<p>Czech:</p>

<pre><code class="language-sdparse">Kolik mužů hrálo karty ? \n How-many men played cards ?
det:numgov(mužů, Kolik)
nsubj(hrálo, mužů)
obj(hrálo, karty)
punct(hrálo, ?-5)
det:numgov(men, How-many)
nsubj(played, men)
obj(played, cards)
punct(played, ?-11)
</code></pre>

<p>See also <a href="">nummod:gov</a> and <a href="">det:nummod</a>.</p>

<!-- Interlanguage links updated So 10. května 2025, 18:15:26 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/det-numgov.md" target="#">edit det:numgov</a></p>

<p><a id="al-u-dep/det:nummod" class="al-dest"></a></p>
<h2><code>det:nummod</code>: pronominal quantifier agreeing in case with the noun</h2>

<p>Pronominal quantifiers in Slavic languages are labeled <code class="language-plaintext highlighter-rouge">det:nummod</code> or <a href="">det:numgov</a> instead of <a href="">det</a>
because they normally do not agree with the quantified noun in case
(unlike non-quantifying determiners).
They do agree only if the whole phrase (quantifier + noun) fills a role where
genitive, dative, locative or instrumental noun phrases are expected.
In these situations they are labeled <code class="language-plaintext highlighter-rouge">det:nummod</code>.</p>

<p>Czech:</p>

<pre><code class="language-sdparse">Nepamatuji si , s kolika muži jsem hrál karty . \n I-do-not-remember myself , with how-many men I-have played cards .
ccomp(Nepamatuji, hrál)
expl:pv(Nepamatuji, si)
punct(hrál, ,-3)
aux(hrál, jsem)
obj(hrál, karty)
iobj(hrál, muži)
case(muži, s)
det:nummod(muži, kolika)
punct(Nepamatuji, .-10)
ccomp(I-do-not-remember, played)
expl:pv(I-do-not-remember, myself)
punct(played, ,-14)
aux(played, I-have)
obj(played, cards)
iobj(played, men)
case(men, with)
det:nummod(men, how-many)
punct(I-do-not-remember, .-21)
</code></pre>

<p>See also <a href="">nummod:gov</a> and <a href="">det:numgov</a>.</p>

<!-- Interlanguage links updated So 10. května 2025, 18:15:26 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/det-nummod.md" target="#">edit det:nummod</a></p>

<p><a id="al-u-dep/det:poss" class="al-dest"></a></p>
<h2><code>det:poss</code>: possessive determiner</h2>

<p>Whenever there is a possessive determiner, <code>det:poss</code> should be used instead of <code>det</code>. All possessive determiners have the feature <code>Possessive</code> defined as <code>Yes</code> and the only instances of the <code>det:poss</code> relation attested in the Italian Treebank appear with those elements.</p>

<pre><code class="language-sdparse">Sarà mia cura verificare . 
det:poss(cura, mia)
</code></pre>
<pre><code class="language-sdparse">Ha da poco annunciato le proprie dimissioni . 
det:poss(dimissioni, proprie)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:26 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/det-poss.md" target="#">edit det:poss</a></p>

<p><a id="al-u-dep/discourse" class="al-dest"></a></p>
<h2><code>discourse</code>: discourse element</h2>

<p>This is used for <a href="u-pos/INTJ">interjections</a> and other discourse <a href="u-pos/PART">particles</a> and
elements (which are not clearly linked to the structure of the
sentence, except in an expressive way). In English, for example, this includes:
interjections (<em>oh</em>, <em>uh-huh</em>, <em>Welcome</em>), fillers (<em>um</em>, <em>ah</em>),
and non-adverbial discourse markers (<em>well</em>, <em>like</em>, but not <em>you know</em> or <em>actually</em>).
We also use <code class="language-plaintext highlighter-rouge">discourse</code> for list enumerators (e.g. <em>1.</em>, <em>(a)</em> marking an item in a sequence).
(Bullets, by contrast, are considered <a href="u-pos/PUNCT">punctuation</a> and attach as <a href="">punct</a>.)</p>

<p>These discourse elements are attached to the head of the most relevant nearby unit, often a clause.</p>

<pre><code class="language-sdparse">I am 21 , well , will be in November .
nsubj(21, I)
cop(21, am)
parataxis(21, be)
discourse(be, well)
aux(be, will)
obl(be, November)
case(November, in)
punct(21, .)
punct(well, ,-4)
punct(well, ,-6)
</code></pre>

<pre><code class="language-sdparse">Iguazu is in Argentina :)
discourse(Argentina-4, :)-5)
</code></pre>

<pre><code class="language-sdparse">5/NUM . Cool for 10 minutes and serve .
discourse(Cool, 5)
punct(5, .-2)
</code></pre>

<pre><code class="language-sdparse">To enter the stadium , you must not have — ( a ) a weapon ; ( b ) any food ; and ( c ) any drink .
discourse(weapon, a-12)
discourse(food, b)
discourse(drink, c)
conj(weapon, food)
conj(weapon, drink)
cc(drink, and)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:15:27 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/discourse.md" target="#">edit discourse</a></p>

<p><a id="al-u-dep/dislocated" class="al-dest"></a></p>
<h2><code>dislocated</code>: dislocated elements</h2>

<p>The <code class="language-plaintext highlighter-rouge">dislocated</code> relation is used for fronted or postposed elements
that do not fulfill the usual core grammatical relations of a
sentence. These elements often appear to be in the periphery of the sentence, and may be separated off with a comma intonation.</p>

<p>It is used for fronted elements that introduce the topic of a sentence, as in the following Japanese and Greek examples. The dislocated element attaches to the head of the clause to which it belongs:</p>

<pre><code class="language-sdparse">象 は 鼻 が 長い \n zoo wa hana ga naga-i \n elephant TOPIC nose SUBJ long-PRES
dislocated(長い-5, 象-1)
</code></pre>

<pre><code class="language-sdparse">to jani ton kserume poli kala \n the John-Acc him know-1pl very well 
dislocated(kserume, jani)
</code></pre>

<p>However, it would not be used for a topic-marked noun that is also the subject of the sentence; this would be an <a href="">nsubj</a>.</p>

<p>It is also used for postposed elements. The dislocated elements attach to the same governor as the dependent that they double for. Right dislocated elements are frequent in spoken languages. French and Greek examples follow.</p>

<pre><code class="language-sdparse">Il faut pas la manger , la plasticine \n It must not it eat , the playdough
obj(manger, la-4)
dislocated(manger, plasticine)
obj(eat, it-13)
dislocated(eat, playdough)
</code></pre>

<pre><code class="language-sdparse">ton kserume oli mas edho poli kala, to jani 
dislocated(kserume, jani)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:29 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/dislocated.md" target="#">edit dislocated</a></p>

<p><a id="al-u-dep/expl" class="al-dest"></a></p>
<h2><code>expl</code>: expletive</h2>

<p>This relation captures expletive or pleonastic nominals. These are nominals that appear in an argument position of a predicate but which do not themselves satisfy any of the semantic roles of the predicate. The main predicate of the clause (the verb or predicate adjective or noun) is the governor. In English, this is the case for some uses of <em>it</em> and <em>there</em>: the existential <em>there</em>, and <em>it</em> when used in extraposition constructions.  (Note that both <em>it</em> and <em>there</em> also have non-expletive uses.)</p>

<pre><code class="language-sdparse">There is a ghost in the room
expl(is, There)
</code></pre>

<pre><code class="language-sdparse">It is clear that we should decline .
expl(clear, It)
</code></pre>

<p>Some languages do not have expletives of the English sort, including most languages with free pro-drop (the ability to use zero anaphora rather than overt pronouns). In languages with expletives of this sort, they can be positioned where normally a core argument appears: the subject and direct object (and even indirect object) slots, as in the examples below. Note that in the analysis of these examples, we treat the postposed subject or clausal argument as a regular core argument, and mark the expletive with <code class="language-plaintext highlighter-rouge">expl</code>.</p>

<pre><code class="language-sdparse">There is a ghost in the room
expl(is, There)
nsubj(is, ghost)
obl(is, room)
</code></pre>

<pre><code class="language-sdparse">I believe there to be a ghost in the room
nsubj(believe, I)
expl(believe, there)
xcomp(believe, be)
nsubj(be, ghost)
obl(be, room)
</code></pre>

<pre><code class="language-sdparse">It is clear that we should decline .
expl(clear, It)
csubj(clear, decline)
</code></pre>

<pre><code class="language-sdparse">That we should decline is clear .
csubj(clear, decline)
</code></pre>

<pre><code class="language-sdparse">I mentioned it to Mary that Sue is leaving
nsubj(mentioned, I)
expl(mentioned, it)
obl(mentioned, Mary)
ccomp(mentioned, leaving)
</code></pre>

<p>A second, related, use of the <code class="language-plaintext highlighter-rouge">expl</code> relation is for cases of true clitic doubling.  For languages in which clitics and lexical nominals are usually in complementary distribution – languages, such as French, which obey “Kayne’s generalization” – then whichever of a clitic or a lexical nominal occurs will get the appropriate role, such as <a href="">obj</a> or <a href="">iobj</a>. In such languages, when doubling does occur, such as in spoken French, the right analysis is to regard the lexical nominal as <a href="">dislocated</a> (see the examples there). As such, the analysis will be the same as when a noun phrase doubles another noun phrase or a regular pronoun that fills a nominal argument position. However, other languages, such as Greek and Bulgarian, standardly allow doubling of a lexical nominal and a pronominal clitic, with the former still appearing in its regular role as an argument of the predicate. In these cases, if only one of the lexical nominal and the clitic appear in a clause, then whichever appears will be given the grammatical role of <a href="">obj</a>, <a href="">iobj</a>, etc. – parallel to the treatment of lexical nominals and pronouns in other languages, modulo the clitic pronoun having a different position in the sentence.  However, if both occur, the lexical nominal will be given the grammatical role of <a href="">obj</a>, <a href="">iobj</a>, etc., and the clitic will be treated as a pronominal copy, which does not receive its own semantic role, and hence will get the role <code class="language-plaintext highlighter-rouge">expl</code>. Modulo the different word order, this is fairly parallel to the treatment of <em>it</em> and <em>there</em> in English mentioned above, where another phrase satisfies the semantic role of the predicate. Examples from Greek and Bulgarian follow:</p>

<pre><code class="language-sdparse">Της τον έδωσε της Καίτης τον αναπτήρα \n PRON.Fem.Gen PRON.Masc.Acc gave ART.Fem.Gen Keti.Gen ART.Masc.Acc lighter.Acc
expl(έδωσε, Της-1)
iobj(έδωσε, Καίτης)
det(Καίτης, της-4)
expl(έδωσε, τον-2)
obj(έδωσε, αναπτήρα)
det(αναπτήρα, τον-6)
</code></pre>

<pre><code class="language-sdparse">Marija mu izprati pismo na rabotnika \n Maria 3.S.M.IO sent letter to the.worker
expl(izprati, mu)
obj(izprati, pismo)
iobj(izprati, rabotnika)
case(rabotnika, na)
</code></pre>

<h2 id="reflexives">Reflexives</h2>

<p>The expletive relation is also used for reflexive pronouns (see the feature <a href="">u-feat/Reflex</a>)
attached to inherently reflexive verbs, i.e. verbs that cannot occur without the reflexive
pronoun and thus the pronoun does not play the role of a normal object
(otherwise it would be possible to substitute it with an irreflexive pronoun or other nominal).</p>

<p>UD recognizes several functions of reflexive pronouns (clitics) that are usually distinguished with the help of subtypes
of the <code class="language-plaintext highlighter-rouge">expl</code> relation (see also the report from the <a href="/workgroups/2015-08-23-uppsala/clitics.html">2015 Uppsala discussion of clitics</a> where
this approach was approved):</p>

<ul>
  <li><a href="">expl:pv</a> for reflexive clitics attached to inherently reflexive verbs (also called pronominal verbs in some grammars)</li>
  <li><a href="">expl:pass</a> for reflexive clitics attached to transitive verbs and acting as a voice marker (passive or mediopassive)</li>
  <li><a href="">expl:impers</a> for impersonal usage (works also with intransitive verbs)</li>
</ul>

<p>A Czech example:</p>

<pre><code class="language-sdparse">Martin se bojí zvířat . \n Martin REFLEX fears animals .
expl:pv(bojí, se)
expl:pv(fears, REFLEX)
</code></pre>

<p>Further general discussion of expletives can be found in Postal, P. M., and G. K. Pullum (1988) “Expletive Noun Phrases in Subcategorized Positions,” <em>Linguistic Inquiry</em> 19(4): 635–670. The status of clitic doubling, and arguments for the lexical nominal being an argument with the clitic a kind of pronominal copy, appear inter alia in Boris Harizanov (2014) <a href="http://stanford.edu/~bharizan/pdfs/Harizanov_2014_NLLT.pdf">Clitic doubling at the syntax-morphology interface: A-movement and morphological merger in Bulgarian</a>. <em>Natural Language and Linguistic Theory</em>.
<!-- Interlanguage links updated So 10. května 2025, 18:15:31 CEST --></p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/expl.md" target="#">edit expl</a></p>

<p><a id="al-u-dep/expl:impers" class="al-dest"></a></p>
<h2><code>expl:impers</code>: impersonal expletive</h2>

<p>The relation <code>expl:impers</code> is a sub-class of <a href="">expl</a>, specific for the impersonal use of the reflexive clitic pronoun.
While the default function of a reflexive pronoun is to signal that the subject applies a transitive action to itself (i.e., the
reflexive pronoun is an object coreferential with the subject), the impersonal construction can be used with any verb, transitive
or intransitive. The clitic is formally identical with a reflexive object but it does not fill the object slot in these constructions
and if the verb is transitive, its real object still occurs in the clause and fills the slot. The reflexive clitic is not a subject
either; in fact there is no subject at all, which is the defining property of impersonal constructions. If the verb must express
subject agreement, it will take a default form (this depends on the language, a typical example would be 3rd person singular).</p>

<p>Impersonal constructions should be distinguished from reflexive passives, in which the reflexive clitic is attached as
<a href="">expl:pass</a>. They are constructed for transitive verbs: The object is promoted to subject, the verb stays in its active form
(although agreement morphemes may have to be adjusted to the new subject), and the object slot is filled by the reflexive pronoun.</p>

<p>[it] <em>Si prevede che viaggerà.</em> “He is expected to travel.”</p>

<pre><code class="language-sdparse">Si prevede che viaggerà . \n REFL expects that will-travel .
expl:impers(prevede, Si)
expl:impers(expects, REFL)
punct(prevede, .-5)
punct(expects, .-11)
ccomp(prevede, viaggerà)
ccomp(expects, will-travel)
mark(viaggerà, che)
mark(will-travel, that)
</code></pre>

<p>In Italian, if there’s a clitic in a construction with a modal or an auxiliary verb, then generally it is an impersonal construction.</p>

<p>[it] <em>Si può procedere a sequestro.</em> “Seizure can be carried out.”</p>

<pre><code class="language-sdparse">Si può procedere a sequestro . \n REFL can proceed to seizure .
expl:impers(procedere, Si)
expl:impers(proceed, REFL)
aux(procedere, può)
aux(proceed, can)
punct(procedere, .-6)
punct(proceed, .-13)
obl(procedere, sequestro)
obl(proceed, seizure)
case(sequestro, a)
case(seizure, to)
</code></pre>

<p>In the following Polish example, <em>wystawę archeologiczną</em> “archaeological exhibition” is in the accusative case, hence it is still
the object and not a subject, hence it is a reflexive impersonal construction and not a reflexive passive.</p>

<p>[pl] <em>Przygotowuje się również wystawę archeologiczną.</em> “An archaeological exhibition is also being prepared.”</p>

<pre><code class="language-sdparse">Przygotowuje się również wystawę archeologiczną . \n Prepares REFL also exhibition archaeological .
punct(Przygotowuje, .-6)
punct(Prepares, .-13)
expl:impers(Przygotowuje, się)
expl:impers(Prepares, REFL)
advmod(Przygotowuje, również)
advmod(Prepares, also)
obj(Przygotowuje, wystawę)
obj(Prepares, exhibition)
amod(wystawę, archeologiczną)
amod(exhibition, archaeological)
</code></pre>

<p>Compare the Polish example with Czech where the archaeological exhibition switched to the nominative, it became the subject and thus
we are dealing with the reflexive passive construction instead.</p>

<p>[cs] <em>Rovněž se připravuje archeologická výstava.</em> “An archaeological exhibition is also being prepared.”</p>

<pre><code class="language-sdparse">Rovněž se připravuje archeologická výstava . \n Also REFL prepares archaeological exhibition .
punct(připravuje, .-6)
punct(prepares, .-13)
expl:pass(připravuje, se)
expl:pass(prepares, REFL)
advmod(připravuje, Rovněž)
advmod(prepares, Also)
nsubj:pass(připravuje, výstava)
nsubj:pass(prepares, exhibition)
amod(výstava, archeologická)
amod(exhibition, archaeological)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:15:31 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/expl-impers.md" target="#">edit expl:impers</a></p>

<p><a id="al-u-dep/expl:pass" class="al-dest"></a></p>
<h2><code>expl:pass</code>: reflexive pronoun used in reflexive passive</h2>

<p>Reflexive pronouns (see the feature <a href="">cs-feat/Reflex</a>) are used in various constructions in Czech,
including so-called <em>reflexive passive.</em>
In PDT, their relation to the verb is labeled <code class="language-plaintext highlighter-rouge">AuxR</code>.
The corresponding label in Czech UD is called <code class="language-plaintext highlighter-rouge">expl:pass</code>
(since UD 2.0; in previous versions it was labeled <code class="language-plaintext highlighter-rouge">auxpass:reflex</code>).</p>

<pre><code class="language-sdparse">To se řekne snadno . \n It is said easily .
expl:pass(řekne, se)
expl:pass(said, is)
</code></pre>

<p>In the following Czech example, <em>archeologická výstava</em> “archaeological exhibition” has switched to the nominative,
it became the subject and thus we are dealing with the reflexive passive and not with an impersonal construction
(<a href="">expl:impers</a>).</p>

<p>[cs] <em>Rovněž se připravuje archeologická výstava.</em> “An archaeological exhibition is also being prepared.”</p>

<pre><code class="language-sdparse">Rovněž se připravuje archeologická výstava . \n Also REFL prepares archaeological exhibition .
punct(připravuje, .-6)
punct(prepares, .-13)
expl:pass(připravuje, se)
expl:pass(prepares, REFL)
advmod(připravuje, Rovněž)
advmod(prepares, Also)
nsubj:pass(připravuje, výstava)
nsubj:pass(prepares, exhibition)
amod(výstava, archeologická)
amod(exhibition, archaeological)
</code></pre>

<p>Compare the Czech example with Polish where <em>wystawę archeologiczną</em> “archaeological exhibition” is in the accusative case,
hence it is still the object and not a subject, hence it is a reflexive impersonal construction and not a reflexive passive.</p>

<p>[pl] <em>Przygotowuje się również wystawę archeologiczną.</em> “An archaeological exhibition is also being prepared.”</p>

<pre><code class="language-sdparse">Przygotowuje się również wystawę archeologiczną . \n Prepares REFL also exhibition archaeological .
punct(Przygotowuje, .-6)
punct(Prepares, .-13)
expl:impers(Przygotowuje, się)
expl:impers(Prepares, REFL)
advmod(Przygotowuje, również)
advmod(Prepares, also)
obj(Przygotowuje, wystawę)
obj(Prepares, exhibition)
amod(wystawę, archeologiczną)
amod(exhibition, archaeological)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:15:31 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/expl-pass.md" target="#">edit expl:pass</a></p>

<p><a id="al-u-dep/expl:pv" class="al-dest"></a></p>
<h2><code>expl:pv</code>: reflexive clitic with an inherently reflexive verb</h2>

<p>Reflexive pronouns (see the feature <a href="">cs-feat/Reflex</a>) usually replace objects of verbs.
However, some verbs are inherently reflexive, i.e. the verb always occurs with a reflexive
prounoun, and the pronoun cannot be replaced by a non-reflexive pronoun.</p>

<p>With these verbs, the reflexive pronoun is attached as <code class="language-plaintext highlighter-rouge">expl:pv</code> instead of <a href="">obj</a>.
(Note that the <code class="language-plaintext highlighter-rouge">expl</code> relation is first used for this purpose in the UD release 1.2,
and it is further subtyped as <code class="language-plaintext highlighter-rouge">expl:pv</code> since UD 2.0,
to increase parallelism with other languages. In the previous releases this usage of
reflexive <em>se/si</em> was labeled <code class="language-plaintext highlighter-rouge">compound:reflex</code>.)</p>

<pre><code class="language-sdparse">Martin se bojí zvířat . \n Martin REFLEX fears animals .
expl:pv(bojí, se)
expl:pv(fears, REFLEX)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:32 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/expl-pv.md" target="#">edit expl:pv</a></p>

<p><a id="al-u-dep/fixed" class="al-dest"></a></p>
<h2><code>fixed</code>: fixed multiword expression</h2>

<p>The <code class="language-plaintext highlighter-rouge">fixed</code> relation is used for certain fixed grammaticized expressions. Such expressions tend to behave like function words. For example, <em><b>in spite of</b></em> is a fixed expression functioning as a preposition in English; <em><b>bien que</b></em> (‘although’, lit. ‘well that’) functions as a subordinating conjunction in French; and <em><b>vare sig</b></em> (‘either’, lit. ‘be itself’) functions as a (pre)conjunction in Swedish.
The scope of <code class="language-plaintext highlighter-rouge">fixed</code> MWEs corresponds roughly to the <em>fixed expressions</em> category of <a href="https://dr.ntu.edu.sg/bitstream/10356/79581/1/2002-cicling-mwe.pdf">Sag et al.</a> and should not be used for multiword expressions that are morphosyntactically flexible.</p>

<h2 id="criteria">Criteria</h2>

<p>Fixed expressions typically do not allow intervening words, except in a few special cases such as clitics that go in a fixed position in the clause and can interrupt even fixed expressions. In addition, there may be inherently discontiguous fixed expressions, such as <em><b>för … sedan</b></em> in Swedish, corresponding to the English <em><b>ago</b></em>, which is syntactically irregular and always encloses a temporal expression, as in <em><b>för</b> 10 år <b>sedan</b></em> [“10 years ago”].</p>

<p>The creation of fixed multiword expressions is the end phase of a process of grammaticalization and there are always going to be cases of multiword expressions that are only somewhat grammaticalized. For practical treebanking, it is recommended to restrict this relation to the most grammaticalized cases and to treat them as a closed class by writing language-specific documentation listing the fixed expressions of the language.</p>

<h2 id="structure">Structure</h2>

<p>Fixed MWEs are annotated in a flat structure, where all subsequent words in the expression 
are attached to the first one using the <code class="language-plaintext highlighter-rouge">fixed</code> label. The assumption is that these expressions
do not have any internal syntactic structure (except from a historical perspective) and that the
structural annotation is in principle arbitrary. In practice, however, it is highly desirable to use
a consistent annotation of all fixed MWEs in all languages.</p>

<p>Fixed MWEs should not have any internal modification. Therefore, if a word attaches as <code class="language-plaintext highlighter-rouge">fixed</code>, 
it should not have any dependents (except perhaps <code class="language-plaintext highlighter-rouge">punct</code>, <code class="language-plaintext highlighter-rouge">goeswith</code>, and <code class="language-plaintext highlighter-rouge">reparandum</code> dependents, 
as these are not true syntactic relations).</p>

<p>The <a href="">ExtPos</a> feature should be specified on the first word of the fixed expression to indicate
the UPOS that the expression would have were it a single word. This indicates what external
dependency relations the expression is compatible with.</p>

<pre><code class="language-sdparse">I like dogs as/[ExtPos=CCONJ] well as cats
fixed(as-4, well-5)
fixed(as-4, as-6)
</code></pre>

<pre><code class="language-sdparse">He cried because/[ExtPos=ADP] of you
fixed(because, of)
</code></pre>

<pre><code class="language-sdparse">Bien/ADV[ExtPos=SCONJ] que/SCONJ malingre quand il était enfant, il devient néanmoins un athlète accompli et un grimpeur de talent. \n Although sickly when he was a child, he nevertheless became an accomplished athlete and a talented climber.
fixed(Bien, que)
</code></pre>

<p><strong>New from v2:</strong> The <code class="language-plaintext highlighter-rouge">fixed</code> relation replaces the old <code class="language-plaintext highlighter-rouge">mwe</code> relation to prevent misunderstanding regarding its scope.
For v2.14, this page has been revised to more clearly articulate the relationship to multiword expressions.
For v2.15, the use of <a href="">ExtPos</a> has been added.</p>

<!-- Interlanguage links updated So 10. května 2025, 18:15:32 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/fixed.md" target="#">edit fixed</a></p>

<p><a id="al-u-dep/flat" class="al-dest"></a></p>
<h2><code>flat</code>: flat expression</h2>

<p>The <code class="language-plaintext highlighter-rouge">flat</code> relation is used to combine the elements of an expression where none of the immediate components can be identified as the sole head using standard substitution tests.
This includes both cases where more than one component passes the head test – as in the name <em><b>John Smith</b></em>, where either <em>John</em> or <em>Smith</em> can replace the whole in most contexts – and cases where no component does – as in <em><b>San Francisco</b></em> (in English).
Note also that the <code class="language-plaintext highlighter-rouge">flat</code> relation is appropriate in such cases only when no more specific relation applies.
For example, in coordination structures annotated with the <a href="">conj</a> relation, any of the conjuncts can usually replace the whole.</p>

<p>Flat expressions are annotated with a flat structure, where all subsequent components in the expression are attached to the 
first one using the <code class="language-plaintext highlighter-rouge">flat</code> label. The assumption is that in these expressions, the <code class="language-plaintext highlighter-rouge">flat</code> relations
are not syntactic head-modifier relations, and that the structural annotation is in principle arbitrary.
The components of a flat expression may have their own dependents, including nested flat structures.
For example, in the name <em><b>Mary Jane Tyler Smith</b></em>, both the first name (<em><b>Mary Jane</b></em>) and the last name
(<em><b>Tyler Smith</b></em>) are flat expressions, which are combined into a larger flat name (the tree appears <a href="#names">below</a>).</p>

<p>The prototypes for flat are: (i) <a href="#names">personal names</a>, (ii) <a href="#foreign-expressions">foreign expressions</a>, (iii) <a href="#iconic-sequences">iconic sequences</a>, and (iv) <a href="#items-separated-for-readability">items separated for readability</a>.
These are illustrated in the sections below.
The application of <code class="language-plaintext highlighter-rouge">flat</code> may extend beyond these prototypes to, e.g., various kinds of name and number expressions.
However, even if an expression is idiosyncratic or follows a specialized pattern, every effort should be made to find a head rather than employing <code class="language-plaintext highlighter-rouge">flat</code>.
If a head can be found but no substantive dependency relation is appropriate, <a href="">dep</a> can be used.</p>

<p>Note that what is considered to be transparent linguistic syntax (as opposed to flat structure) is subject to treebank-specific policies.
(E.g., some treebanks might provide proper grammatical analyses in the presence of code-switching,
or treat mathematical notation as following linguistic strategies like predication.)</p>

<p>Some languages opt to subcategorize usages of <code class="language-plaintext highlighter-rouge">flat</code> <a href="https://universaldependencies.org/ext-dep-index.html#flat">via subtypes</a>.
In particular, many treebanks use the <code class="language-plaintext highlighter-rouge">flat:name</code> and <code class="language-plaintext highlighter-rouge">flat:foreign</code> subtypes converted from the v1 relations <code class="language-plaintext highlighter-rouge">name</code> and <code class="language-plaintext highlighter-rouge">foreign</code>.
The examples on this page simply use plain <code class="language-plaintext highlighter-rouge">flat</code>.</p>

<h2 id="names">Names</h2>

<p>A person’s name (or parts thereof) may lack the hallmarks of general constructions in the language, such that no single word can be identified as the head, in which case a flat structure applies.</p>

<pre><code class="language-sdparse">Hillary Rodham Clinton
flat(Hillary, Rodham)
flat(Hillary, Clinton)
</code></pre>

<p>Nesting is possible:</p>

<pre><code class="language-sdparse">Mary Jane Tyler Smith
flat(Mary, Jane)
flat(Tyler, Smith)
flat(Mary, Tyler)
</code></pre>

<p>On occasion, an expression with no clear head at the top level will have internal syntactic modifiers or punctuation:</p>

<pre><code class="language-sdparse">Dwayne " The Rock " Johnson
flat(Dwayne, Rock)
flat(Dwayne, Johnson)
det(Rock, The)
punct(Rock, "-2)
punct(Rock, "-5)
</code></pre>

<p>The scope of <code class="language-plaintext highlighter-rouge">flat</code> may extend beyond names of persons to names of other kinds of entities that depart from general headed structure.
The expressions under this category must be established by language-specific criteria.</p>

<p>The <a href="">ExtPos</a> feature may be used to signal the external syntactic distribution of the flat expression—e.g., <code class="language-plaintext highlighter-rouge">ExtPos=PROPN</code> for <em>17</em> in:</p>

<pre><code class="language-sdparse">17/NUM[ExtPos=PROPN] Across/ADV is wrong in this crossword .
flat(17, Across)
</code></pre>

<h3 id="flat-vs-non-flat-names">Flat vs. non-flat names</h3>

<!-- NO LONGER (NECESSARILY) FLAT - MISCHIEVOUS NOMINALS:
~~~ sdparse
Carl XVI Gustaf
flat(Carl-1, Gustaf-3)
flat(Carl-1, XVI-2)
~~~

~~~ sdparse
New York
flat(New, York)
~~~

Titles/honorifics are also analyzed using the `flat` relation. Note that some titles are complex
and have their own internal syntactic structure. Such structure is shown with regular relations embedded under `flat`:

~~~ sdparse
Mr. Smith
flat(Mr., Smith)
~~~

~~~ sdparse
President Obama
flat(President, Obama)
~~~

~~~ sdparse
French actor Gaspard Ulliel
amod(actor-2, French-1)
flat(actor-2, Gaspard-3)
flat(actor-2, Ulliel-4)
~~~

~~~ sdparse
Milliardär Ross Perot \n billionaire Ross Perot
flat(Milliardär-1, Ross-2)
flat(Milliardär-1, Perot-3)
~~~

However if the two halves of a descriptive title and a name appear to be two separate nominals, 
then analysis with `flat` is not appropriate, and [u-dep/appos]() is appropriate. These cases are often set off by
punctuation, such as a comma, but no punctuation may appear in more informal text. 
You can generally test for such examples by asking if the two halves can be reversed; if they can, it is probably an `appos`; 
see the examples there.
-->

<p>Names that have a regular syntactic structure, like <em>The Lord of the Rings</em> and <em>Captured By
Aliens</em>, should be annotated with regular syntactic relations rather than flat structures:</p>

<pre><code class="language-sdparse">The Lord of the Rings
det(Lord, The)
nmod(Lord, Rings)
case(Rings, of)
det(Rings, the)
</code></pre>

<pre><code class="language-sdparse">The king of Sweden
det(king-2, The-1)
nmod(king-2, Sweden-4)
case(Sweden-4, of-3)
</code></pre>

<p>For organization names with clear syntactic modification structure, the dependencies should 
also reflect the syntactic modification structure using regular syntactic relations, as in:</p>

<pre><code class="language-sdparse">Natural Resources Conservation Service
amod(Resources-2, Natural-1)
compound(Conservation-3, Resources-2)
compound(Service-4, Conservation-3)
</code></pre>

<p>In addition, regular syntactic relations are used: (i) for a modifying determiner or similar function word and (ii) to connect 
together the words of a description or name which involve embedded prepositional phrases, sentences, etc.,
when these relations are (i) recognized in the language being annotated (i.e., the analyses below are for
French, German, and Spanish, not English) and (ii) deemed not to be grammaticalized to the extent that the original role
of the function words has been lost.</p>

<pre><code class="language-sdparse">Le Japon
det(Japon-2, Le-1)
</code></pre>

<pre><code class="language-sdparse">Ludwig van Beethoven
case(Beethoven, van)
nmod(Ludwig, Beethoven)
</code></pre>

<pre><code class="language-sdparse">Miguel de Cervantes y Saavedra
conj(Cervantes, Saavedra)
cc(Saavedra, y)
case(Cervantes, de)
nmod(Miguel, Cervantes)
</code></pre>

<pre><code class="language-sdparse">Río de la Plata
case(Plata-4, de-2)
det(Plata-4, la-3)
nmod(Río-1, Plata-4)
</code></pre>

<p>A name may combine flat and non-flat structure. In a Portuguese text, the surname <em>Paulo da Silva</em> would be analyzed as follows:</p>

<!-- REMOVED Júnior -->

<pre><code class="language-sdparse">Roberto Paulo da Silva
flat(Roberto, Paulo)
nmod(Paulo, Silva)
case(Silva, da)
</code></pre>

<p>The above analyses of <em>Ludwig van Beethoven</em> and <em>Miguel de Cervantes y Saavedra</em> assume that <em>van</em> resp. <em>de</em> are prepositions.
This is true in the languages of the names’ origin, but it can be expected to change when the name is used in foreign text 
or when sufficient grammaticalization has taken place. For example,
when names like this are annotated in English, the appropriate analysis is as a <code class="language-plaintext highlighter-rouge">flat</code> name:</p>

<pre><code class="language-sdparse">Ludwig van Beethoven was a famous German composer .
flat(Ludwig, van)
flat(Ludwig, Beethoven)
det(composer, a)
amod(composer, famous)
amod(composer, German)
cop(composer, was)
nsubj(composer, Ludwig)
punct(composer, .)
</code></pre>

<pre><code class="language-sdparse">Río de la Plata
flat(Río-1, de-2)
flat(Río-1, la-3)
flat(Río-1, Plata-4)
</code></pre>

<pre><code class="language-sdparse">Al Arabiya is a Saudi-owned news organization
flat(Al-1, Arabiya-2)
nsubj(organization-7, Al-1)
</code></pre>

<p>And in Modern German or French, these prepositions have generally just become a fossilized part of a family name 
and regularly appear without the given name. Again, here, the flat analysis seems correct:</p>

<pre><code class="language-sdparse">Von Hohenlohe gewann das Rennen . \n Von Hohenlohe won the race .
flat(Von-1, Hohenlohe-2)
nsubj(gewann-3, Von-1)
</code></pre>

<!-- TODO: attachment of Jr.
In the case of proper entities named after people, e.g. _Leland Stanford Jr. University_, the `flat` relation 
should only be used inside the person name, with the rest of the construction analyzed compositionally using 
normal syntactic relations:

~~~ sdparse
Leland Stanford Jr. University
compound(University-4, Leland-1)
flat(Leland-1, Stanford-2)
flat(Leland-1, Jr.-3)
~~~
-->

<!-- ALREADY COVERED BY Mary Jane Tyler Smith
A flat structure can even be nested under another flat structure. For example, the words of an embedded nickname would be treated as a nested flat expression:

~~~ sdparse
Denise " Dee Dee " Bridgewater
flat(Denise, Dee-3)
flat(Dee-3, Dee-4)
flat(Denise, Bridgewater)
punct(Dee-3, "-2)
punct(Dee-3, "-5)
~~~
-->

<!-- MISCHIEVOUS NOMINALS - let's not articulate a policy here, at least not yet
### Some further notes on relations for names

_This paragraph briefly records some of the arguments that have been made in the past on relations for name structure. It is an issue over which there has historically been variation and about which there is some continuing debate._ Examples like 
_French actor Gaspard Ulliel:_ Some treebanks have used `nmod` for titles and honorifics like _Mr._ or _French actor_. Most people think this is inappropriate, since an `nmod` dependent should be a full phrase, which will typically take its own case as a modifier in a cased language. In contrast, these titles seem to be part of the same phrase as the name that follows them; they show case agreement concord in a cased language. Some grammatical traditions, descending from Latin, call _French actor_ in such cases a "fixed (or close) apposition" and take the name as the head. UD has restricted the `appos` relation to following appositives (corresponding to "loose (or wide) apposition" in the Latin tradition). The relation `appos` is only used when you have two full nominals, typically joined loosely, and often separated by a punctuation mark like a comma. So `appos` is not correct for these cases. Sometimes the relation `compound` has been used, but this does not seem right. It implies headedness, and titles do not usually behave like compounds: in German, they are not joined to the following words, as compounds are normally joined in German, and they appear at the beginning of names in both German and Hebrew, even though German compounds are head last and Hebrew compounds are head first. So `compound` does not seem appropriate either. Some UDv1 treebanks used `name` for honorifics like _Mr._, although some felt that was wrong and `name` should be restricted to joining the proper nouns of multi-word names. In UDv2, `name` was removed and replaced by `flat`, which allowed a broader notion of a chunk of unheaded material. In the UDv2 guidelines, cases of both titles and honorifics are joined to names with `flat`.


## Dates and Complex Numerals

Date expressions come in many shapes and forms across languages. In some cases, they have a very clear syntactic
structure, as in _the 4th of July_, and should be annotated with regular dependency relations. In other cases, they
have a flat structure with no clearly discernible head, as in _1 December 2016_, in which case the `flat` relation 
should be used. 

~~~ sdparse
the 4th of July
det(4th, the)
nmod(4th, July)
case(July, of)
~~~

~~~ sdparse
1 December 2016
flat(1, December)
flat(1, 2016)
~~~

The `flat` relation can also be used for other numerals and other numerical expressions that lack phrasal structure.

~~~ sdparse
four thousand
flat(four, thousand)
~~~
-->

<h2 id="foreign-expressions">Foreign expressions</h2>

<p>This encompasses expressions that may have been borrowed or quoted, but whose original grammatical structure is not necessarily accessible to speakers of the language(s) being annotated.</p>

<pre><code class="language-sdparse">And then she went : gjiko frac zen .
parataxis(went, gjiko)
flat(gjiko, frac)
flat(gjiko, zen)
</code></pre>

<p>“Foreign” includes not just natural languages but also notational systems that are considered external to natural language proper and are governed by separate rules (e.g., musical chord progressions, software code excerpts).</p>

<pre><code class="language-sdparse">The Vienna Game move order is 1. e4 e5 2. Nc3 .
nsubj(1., order)
cop(1., is)
flat(1., e4)
flat(1., e5)
flat(1., 2.)
flat(1., Nc3)
</code></pre>

<p>See further discussion at <a href="/foreign.html">Foreign Expressions and Code-Switching</a>.</p>

<p><strong>History:</strong> UD v1 had a <code class="language-plaintext highlighter-rouge">foreign</code> relation, but this is no longer part of the relation taxonomy and has been subsumed under <code class="language-plaintext highlighter-rouge">flat</code>.</p>

<h2 id="iconic-sequences">Iconic sequences</h2>

<p>Sequences for which neither head-dependent nor coordination relationships apply include onomatopoeia (<em><b>quack quack quack</b></em>), “filler” words (<em><b>do re mi</b></em>), and gibberish (<em><b>blargety blarg blarg</b></em>).</p>

<pre><code class="language-sdparse">The duck said quack quack quack
obj(said, quack-4)
flat(quack-4, quack-5)
flat(quack-4, quack-6)
</code></pre>

<h2 id="items-separated-for-readability">Items separated for readability</h2>

<p>Here the units separated by spaces or punctuation cannot really be construed as separate lexemes. A common case is <strong>telephone numbers</strong>:</p>

<pre><code class="language-sdparse">Call 0118 999 881 999 119 725 3
obj(Call, 0118)
flat(0118, 999-3)
flat(0118, 881)
flat(0118, 999-5)
flat(0118, 119)
flat(0118, 725)
flat(0118, 3)
</code></pre>

<p><strong>Filenames</strong> are another such case: they may contain spaces, and the components may or may not be recognizable as natural language strings, but in general filenames are not expected to follow regular syntactic structure. <code class="language-plaintext highlighter-rouge">flat</code> signals filenames are a context where regular syntactic rules do not apply (whether the component tokens are analyzed morphologically like words of an art title, or simply tagged as <a href="">X</a>, or a mixture; the precise tokenization and morphological analysis is left to the discretion of treebanks). <code class="language-plaintext highlighter-rouge">ExtPos=PROPN</code> may be specified in the MISC column to signal that the whole filename functions externally as a proper noun. For example, the filename <code class="language-plaintext highlighter-rouge">Mydoc CHQ2 - Wednesday DRAFT (2).txt</code> might be analyzed as follows:</p>

<pre><code class="language-sdparse">Mydoc/X[ExtPos=PROPN] CHQ2/X -/PUNCT Wednesday/PROPN DRAFT/PROPN (/PUNCT 2/NUM )/PUNCT .txt/X
flat(Mydoc, CHQ2)
flat(Mydoc, -)
flat(Mydoc, Wednesday)
flat(Mydoc, DRAFT)
flat(Mydoc, ()
flat(Mydoc, 2)
flat(Mydoc, ))
flat(Mydoc, .txt)
</code></pre>

<p>It is not expected that a language’s tokenization rules will make special exceptions for spaces in telephone numbers or filenames. That is, if spaces trigger token boundaries in general, they should also do so for telephone numbers and filenames; exceptional token-internal spaces will not be permitted.</p>

<p>Not all “unnecessary” spaces warrant <code class="language-plaintext highlighter-rouge">flat</code>, however:</p>
<ul>
  <li>improper spacing within a word should be addressed with <a href="">goeswith</a></li>
  <li>numerals with thousands separator spaces (e.g. <em>1 000 000</em>) <a href="/u/overview/tokenization.html">may be treated as single words</a> in languages where this convention is widespread</li>
</ul>

<!-- Interlanguage links updated So 10. května 2025, 18:15:33 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/flat.md" target="#">edit flat</a></p>

<p><a id="al-u-dep/flat:foreign" class="al-dest"></a></p>
<h2><code>flat:foreign</code>: foreign words</h2>

<p>Some treebanks use <code class="language-plaintext highlighter-rouge">flat:foreign</code> to label sequences of foreign words. These are given
a linear analysis: the head is the first token in the foreign phrase.</p>

<p><code class="language-plaintext highlighter-rouge">flat:foreign</code> does not apply to loanwords or to foreign <a href="flat">names</a>.
It applies to quoted foreign text incorporated in a sentence/discourse
of the host language (unless we want to and know how to annotate the
internal structure according to the syntax of the foreign language).</p>

<pre><code class="language-sdparse">Jarmusch se objevil ve Wangově snímku Modrá ve tváři ( Blue in the Face ) .
flat:foreign(Blue, in)
flat:foreign(Blue, the)
flat:foreign(Blue, Face)
</code></pre>

<p>See the general policy on <a href="/foreign.html">Foreign Expressions and Code-Switching</a>.</p>

<!-- Interlanguage links updated So 10. května 2025, 18:15:34 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/flat-foreign.md" target="#">edit flat:foreign</a></p>

<p><a id="al-u-dep/flat:name" class="al-dest"></a></p>
<h2><code>flat:name</code>: names</h2>

<p>The <code class="language-plaintext highlighter-rouge">flat:name</code> relation is a specialization of <code class="language-plaintext highlighter-rouge">flat</code> used for names.</p>

<pre><code class="language-sdparse">Ecco l'arringa di Tiziana Maiolo . 
name(Tiziana, Maiolo)
</code></pre>

<p>Names are annotated in a flat, head-initial structure, in which all words in the name modify the first one using the <code>flat:name</code> label. This also works for prepositions or determiners and numerals that are part of the names.</p>

<pre><code class="language-sdparse">Formula 1/NUM . 
flat:name(Formula, 1)
</code></pre>
<pre><code class="language-sdparse">Marcello Dell' Utri . 
flat:name(Marcello, Dell')
flat:name(Marcello, Utri)
</code></pre>

<p>Words joined by <code>flat:name</code> should all be part of a minimal noun phrase; otherwise regular syntactic relations should be used. For organization names with clear syntactic modification structure, the dependencies should reflect the syntactic modification structure using regular syntactic relation.</p>

<pre><code class="language-sdparse">L' ordine Mauriziano
det(ordine, L')
amod(ordine, Mauriziano)
</code></pre>
<pre><code class="language-sdparse">Il Ministero di gli Interni 
det(Ministero, Il)
nmod(Ministero, Interni)
det(Interni, gli)
case(Interni, di)
</code></pre>

<p>In addition, regular syntactic relations are used:</p>

<ul>
  <li>for a modifying determiner or</li>
  <li>to connect together the words of a description or name which involve embedded prepositional phrases, sentences, etc.</li>
</ul>

<pre><code class="language-sdparse">Mariatersa Di Lascia
name(Mariatersa, Lascia)
case(Lascia, Di)
</code></pre>
<pre><code class="language-sdparse">Università di Pristina 
name(Università, Pristina)
case(Pristina, di)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:15:35 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/flat-name.md" target="#">edit flat:name</a></p>

<p><a id="al-u-dep/goeswith" class="al-dest"></a></p>
<h2><code>goeswith</code>: goes with</h2>

<p>This relation links two or more parts of a word that are separated in text that is not well edited.
These parts should be written together as one word according to the orthographic rules of a given language.
The head is always the first part, the other parts are attached to it with the <code class="language-plaintext highlighter-rouge">goeswith</code> relation
(for consistency, similarly as in <a href="">flat</a>, <a href="">fixed</a> and <a href="">conj</a>).</p>

<p>The first part of the word is given the part of speech that the word would have been given if written together,
while the later parts of the word are given the POS <code class="language-plaintext highlighter-rouge">X</code>. Similarly, only the first part can have a lemma
and morphological features. And while the annotation of morphological features is optional, if the treebank
does have features, then <a href="">Typo</a><code class="language-plaintext highlighter-rouge">=Yes</code> must be used with the <code class="language-plaintext highlighter-rouge">goeswith</code> head.</p>

<p>Note also that only the last word part may be annotated with <code class="language-plaintext highlighter-rouge">SpaceAfter=No</code>.</p>

<pre><code class="language-sdparse">They come here with/ADP[Typo=Yes] out/X legal permission
goeswith(with-4, out-5)
</code></pre>

<pre><code class="language-sdparse">never/ADV[Typo=Yes] the/X less/X[SpaceAfter=No] ,
goeswith(never, the)
goeswith(never, less)
</code></pre>

<pre><code class="language-sdparse">For/VERB[Mood=Imp|Typo=Yes|VerbForm=Fin] get/X that !
goeswith(For, get)
obj(For, that)
punct(For, !)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:36 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/goeswith.md" target="#">edit goeswith</a></p>

<p><a id="al-u-dep/iobj" class="al-dest"></a></p>
<h2><code>iobj</code>: indirect object</h2>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>WARNING</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>⚠️</td>
      <td>The traditional term “indirect object”, associated with morphosyntactic encoding of certain types of arguments (especially datives/recipients) in a clause, has a wide range of interpretations across languages and linguistic frameworks. In UD, universal-level relations do not distinguish arguments and adjuncts; rather, the distinction is between <a href="/u/overview/syntax.html#core-arguments-vs-oblique-modifiers">core arguments and oblique modifiers</a>. <code class="language-plaintext highlighter-rouge">iobj</code> must only be used for core arguments, never for obliques, as described below. The naming of this relation may be changed in the next major revision of the UD guidelines.</td>
    </tr>
  </tbody>
</table>

<p>In UD, the indirect object of a verb is any nominal phrase that is a core
argument of the verb but is not its subject or (direct) <a href="obj">object</a>.
The prototypical example is the recipient of ditransitive verbs of
exchange:</p>

<pre><code class="language-sdparse">She gave me a raise
iobj(gave, me)
nsubj(gave, She)
</code></pre>

<p>However, many languages allow other semantic roles as additional objects. The most common case is allowing benefactives, but some languages allow other roles. Examples include instruments, such as in the Kinyarwanda example below, or comitatives. At the other extreme, some languages lack all indirect objects.</p>

<pre><code class="language-sdparse">Umukoóbwa a-ra-andik-iish-a íbárúwa íkárámu \n girl 1-PRS-write-APPL-ASP letter pen
obj(a-ra-andik-iish-a, íbárúwa)
iobj(a-ra-andik-iish-a, íkárámu)
</code></pre>

<p>In languages distinguishing morphological <a href="u-feat/Case">cases</a>, the recipient will often be marked by the dative case.
However, the <code class="language-plaintext highlighter-rouge">iobj</code> relation can be used only for a core argument. The morphological dative may signal a core argument
in some languages (such as Basque) but in many others it is just oblique (like the English preposition <em>to</em>). For
instance, in many Indo-European languages, the recipient should be attached as <a href="">obl</a> and not <code class="language-plaintext highlighter-rouge">iobj</code>, regardless
of the traditional grammar which may label it as “indirect object”.</p>

<p>In the following Czech example, the verb takes two objects. Both are nouns in the accusative case, which is rather
unusual—for most other verbs, one of the arguments would be in the dative and would thus be treated as oblique in UD.
However, a bare accusative signals a core object and a verb with one nominative and two accusatives is ditransitive
in UD. One of the accusatives is direct object (patient), the other is indirect (recipient). It is parallel to how
the English translation would be annotated (where there is no morphological case marking) and also to verbs of giving
in English (consider a similar sentence, <em>he gave my daughter a class of maths</em>).</p>

<pre><code class="language-sdparse">On učí mou dceru matematiku . \n He teaches my daughter.Acc maths.Acc .
obj(učí, matematiku)
iobj(učí, dceru)
obj(teaches, maths.Acc)
iobj(teaches, daughter.Acc)
</code></pre>

<p>Predicates in Basque can cross-reference (by morphological agreement on the auxiliary verb) up to three arguments
in different morphological cases: ergative, absolutive, and dative. The morphological cross-reference is a strong
indicator that all three are core arguments. Therefore, if all three are present, we have a double-object situation
and the dative argument will be <code class="language-plaintext highlighter-rouge">iobj</code> (while the ergative argument will be <a href="">nsubj</a> and the absolutive <a href="">obj</a>).
Even if the absolutive argument is omitted for a verb which licenses three arguments, the dative argument is still
<code class="language-plaintext highlighter-rouge">iobj</code>.</p>

<pre><code class="language-sdparse">(Nik)/Case=Erg (zuri)/Case=Dat liburua/Case=Abs eman dizut . \n (I) (you) book given I-have-you-it .
nsubj(eman, (Nik))
iobj(eman, (zuri))
obj(eman, liburua)
aux(eman, dizut)
punct(eman, .-6)
nsubj(given, (I))
iobj(given, (you))
obj(given, book)
aux(given, I-have-you-it)
punct(given, .-13)
</code></pre>

<pre><code class="language-sdparse">Mariari/Case=Dat eman nion liburua/Case=Abs . \n To-Maria given I-have-her-it book .
iobj(eman, Mariari)
obj(eman, liburua)
aux(eman, nion)
punct(eman, .-5)
iobj(given, To-Maria)
obj(given, book)
aux(given, I-have-her-it)
punct(given, .-11)
</code></pre>

<pre><code class="language-sdparse">Mariari/Case=Dat eman nion . \n To-Maria given I-have-her-it .
iobj(eman, Mariari)
aux(eman, nion)
punct(eman, .-4)
iobj(given, To-Maria)
aux(given, I-have-her-it)
punct(given, .-9)
</code></pre>

<pre><code class="language-sdparse">Liburua/Case=Abs eman nion . \n Book given I-have-her-it .
obj(eman, Liburua)
aux(eman, nion)
punct(eman, .-4)
obj(given, Book)
aux(given, I-have-her-it)
punct(given, .-9)
</code></pre>

<p>Nevertheless, Basque has also a class of verbs that license only two core arguments, one ergative and
one dative. Here the ergative has the A function and the dative the P function (Zúñiga and Fernández 2014),
meaning that the dative is <a href="">obj</a> rather than <code class="language-plaintext highlighter-rouge">iobj</code>, as in “The teacher has looked angrily at the students.”</p>

<pre><code class="language-sdparse">Irakasleak/Case=Erg haserre begiratu die ikasleei/Case=Dat . \n Teacher angrily looked he-has-them to-students .
nsubj(begiratu, Irakasleak)
advmod(begiratu, haserre)
aux(begiratu, die)
obj(begiratu, ikasleei)
punct(begiratu, .-6)
nsubj(looked, Teacher)
advmod(looked, angrily)
aux(looked, he-has-them)
obj(looked, to-students)
punct(looked, .-13)
</code></pre>

<p>Another class of transitive verbs in Basque license one dative and one absolutive argument. Here the
dative has the A function and the absolutive the P function, meaning that the dative is <a href="">nsubj</a> and
the absolutive is <a href="">obj</a>, as in “The boy likes the soup very much.”</p>

<pre><code class="language-sdparse">Zopa/Case=Abs izugarri gustatzen zaio mutilari/Case=Dat . \n Soup greatly pleasing it-is-him to-boy .
obj(gustatzen, Zopa)
advmod(gustatzen, izugarri)
aux(gustatzen, zaio)
nsubj(gustatzen, mutilari)
punct(gustatzen, .-6)
obj(pleasing, Soup)
advmod(pleasing, greatly)
aux(pleasing, it-is-him)
nsubj(pleasing, to-boy)
punct(pleasing, .-13)
</code></pre>

<p>In Tagalog, core arguments are marked by the prepositions <em>ang</em> and <em>ng</em> (or by corresponding inflection
of personal pronouns), while oblique dependents are typically marked by the preposition <em>sa</em> (sometimes
glossed as the dative). Giving somebody something is a (mono)transitive predicate.</p>

<ul>
  <li><em>Nagbigay ang lalaki ng libro sa babae.</em> “The man gave a book to the woman.” (agent voice)</li>
</ul>

<pre><code class="language-conllu"># text = Nagbigay ang lalaki ng libro sa babae.
# text_en = The man gave a book to the woman.
1	Nagbigay	bigay	VERB	_	Aspect=Perf|Mood=Ind|VerbForm=Fin|Voice=Act	0	root	_	Gloss=gave
2	ang	ang	ADP	_	Case=Nom	3	case	_	Gloss=the
3	lalaki	lalaki	NOUN	_	_	1	nsubj	_	Gloss=man
4	ng	ng	ADP	_	Case=Gen	5	case	_	_
5	libro	libro	NOUN	_	_	1	obj	_	Gloss=book
6	sa	sa	ADP	_	Case=Dat	7	case	_	Gloss=DIR
7	babae	babae	NOUN	_	_	1	obl	_	Gloss=woman|SpaceAfter=No
8	.	.	PUNCT	_	_	1	punct	_	Gloss=.

</code></pre>

<p>However, locative dependents can be topicalized if the verb morphology signals
the “locative voice”. Then the locative noun phrase switches to nominative,
it becomes a core argument, while the original two core arguments keep core
coding, too. Therefore we have a ditransitive clause with three core arguments,
even for verbs that are not associated with ditransitives in other languages:</p>

<ul>
  <li><em>Aalisan ng babae ng bigas ang sako para sa bata.</em> “A/the woman will take some rice out of the sack for a/the child.” (locative voice)</li>
</ul>

<pre><code class="language-conllu"># sent_id = 3.111c/tl
# text = Aalisan ng babae ng bigas ang sako para sa bata.
# gloss = FUT-take.out-DP ACT woman OBJ rice PIV sack BEN child
# text_en = A/the woman will take some rice out of the sack for a/the child.
# DP = directional pivot; PIV = pivot marker
1	Aalisan	alis	VERB	_	Aspect=Prog|Mood=Ind|VerbForm=Fin|Voice=Lfoc	0	root	_	Gloss=will-take-out|MSeg=a-alis-an|MGloss=FUT-take.out-DP
2	ng	ng	ADP	_	Case=Gen	3	case	_	_
3	babae	babae	NOUN	_	_	1	iobj:agent	_	Gloss=woman
4	ng	ng	ADP	_	Case=Gen	5	case	_	_
5	bigas	bigas	NOUN	_	_	1	obj:patient	_	Gloss=rice
6	ang	ang	ADP	_	Case=Nom	7	case	_	Gloss=the
7	sako	sako	NOUN	_	_	1	nsubj:loc	_	Gloss=sack
8	para	para	ADP	_	_	10	case	_	Gloss=for
9	sa	sa	ADP	_	Case=Dat	10	case	_	Gloss=BEN
10	bata	bata	NOUN	_	_	1	obl	_	Gloss=child|SpaceAfter=No
11	.	.	PUNCT	_	_	1	punct	_	Gloss=.

</code></pre>

<p>In Plains Cree (Wolvengrey 2011), transitive verbs cross-reference subjects and animate objects but not
inanimate objects. With a verb of giving, the theme is typically inanimate while the recipient is
typically animate. Assuming that <a href="">nsubj</a> and <a href="">obj</a> are reserved for the two core arguments
cross-referenced by the verb, the theme has to be <code class="language-plaintext highlighter-rouge">iobj</code> (if it is a core argument at all; otherwise
it would have to be <a href="">obl</a>; but real oblique nominals in Plains Cree take a locative case affix,
which is not present here).</p>

<ul>
  <li><em>Nikī-miyāw anima masinahikan.</em> “I gave him that book.”</li>
</ul>

<pre><code class="language-conllu"># text = Nikī-miyāw anima masinahikan.
# text_en = I gave him/her that book.
1	Nikī-miyāw	miy	VERB	_	Animacy=Anim|Mood=Ind|Number[high]=Sing|Number[low]=Sing|Person[high]=1|Person[low]=3|Tense=Past|Voice=Dir	0	root	_	Gloss=I-gave-him/her|MSeg=ni-kī-miy-ā-w|MGloss=1-PAST-give.to-DIR-3SG
2	anima	anima	DET	_	Animacy=Inan|Number=Sing|PronType=Dem	3	det	_	Gloss=that|MGloss=DEM.0's
3	masinahikan	masinahikan	NOUN	_	Animacy=Inan|Number=Sing	1	iobj	_	Gloss=book|SpaceAfter=No
4	.	.	PUNCT	_	_	1	punct	_	Gloss=.

</code></pre>

<p>In the above example, the verb stem used is for animate objects, while
<em>masinahikan</em> “book” is inanimate. That is a proof that the 3rd person singular
cross-reference on the verb does not refer to the book but to an animate
recipient that is not overtly represented in the sentence.</p>

<p>If the language has a prototypical <code class="language-plaintext highlighter-rouge">iobj</code> (occurring in a double object construction with <a href="">obj</a>),
then morphosyntactic criteria need to be established for when a sole object is <a href="">obj</a> and when it is <code class="language-plaintext highlighter-rouge">iobj</code>.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup>
Depending on the language, potential reasons to consider a sole object in a clause as an <code class="language-plaintext highlighter-rouge">iobj</code> include:</p>
<ul>
  <li>It has case marking distinct from that of a prototypical <a href="">obj</a>, e.g. dative rather than accusative</li>
  <li>Another, more patient-like object may be inserted into the clause without affecting the morphosyntax of the object in question</li>
  <li>The verb licenses the object in combination with a <a href="">ccomp</a> (the <a href="">ccomp</a> may be analyzed as taking the place of an <a href="">obj</a>)</li>
</ul>

<p>For example, in English, the verb <em>teach</em> may occur with <a href="">obj</a>, <a href="">iobj</a>, or both:</p>

<pre><code class="language-sdparse">She teaches the students introductory logic .
iobj(teaches, students)
obj(teaches, logic)
</code></pre>

<pre><code class="language-sdparse">She teaches introductory logic .
obj(teaches, logic)
</code></pre>

<pre><code class="language-sdparse">She teaches the first-year students .
iobj(teaches, students)
</code></pre>

<pre><code class="language-sdparse">She teaches her students that good writing is important .
iobj(teaches, students)
ccomp(teaches, important)
</code></pre>

<pre><code class="language-sdparse">She teaches her students to write well .
iobj(teaches, students)
xcomp(teaches, write)
</code></pre>

<p>However, not all verbs license two objects (or an object plus <a href="">ccomp</a>), in which case the sole object should be plain <a href="">obj</a> even if it has recipient-like semantics:</p>

<pre><code class="language-sdparse">She questions her students about their interests .
obj(questions, students)
obl(questions, interests)
</code></pre>

<pre><code class="language-sdparse">She helps her students to succeed .
obj(helps, students)
xcomp(helps, succeed)
</code></pre>

<h2 id="references">References</h2>

<ul>
  <li>Fernando Zúñiga, Beatriz Fernández (draft 26.6.2014): <a href="http://basdisyn.net/pdf/Zuniga%20&amp;%20Fernandez%202014%20Basque%20GRs%20270614.pdf">Grammatical relations in Basque</a></li>
  <li>Arok Elessar Wolvengrey (2011):
<a href="https://dare.uva.nl/search?identifier=153f3405-f029-4046-8d95-9f2a087b4123">Semantic and pragmatic functions in Plains Cree syntax</a>
(PhD thesis). Utrecht: LOT. ISBN 978-94-6093-051-5.</li>
</ul>

<!-- Interlanguage links updated So 10. května 2025, 18:15:37 CEST -->
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>This is an amended policy as described <a href="/changes.html#sole-iobj">on the changes page</a>. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/iobj.md" target="#">edit iobj</a></p>

<p><a id="al-u-dep/list" class="al-dest"></a></p>
<h2><code>list</code>: list</h2>

<p>The <code class="language-plaintext highlighter-rouge">list</code> relation is used for chains of comparable items. In lists with more than two items, all
items of the list should modify the first one. If a list is something like a list of paragraphs
(for example, describing items in a catalogue), then each item will be one or more sentences and
no list relations appear, as we do not have relations between sentences.
However, informal and web text often contains passages which are meant to be interpreted as lists
but are parsed as single sentences. For example, email signatures often contain these structures,
in the form of contact information: the different contact information items are labeled as <code class="language-plaintext highlighter-rouge">list</code>.</p>

<pre><code class="language-sdparse">Steve Jones sj@abc.xyz University of Arizona
flat:name(Steve, Jones)
list(Steve, sj@abc.xyz)
list(Steve, University)
nmod(University, Arizona)
case(Arizona, of)
</code></pre>

<p>If the fields in the list are explicit and have a key-value structure,
the key-value pair relations are labeled as <a href="">appos</a>.</p>

<pre><code class="language-sdparse">Steve Jones Phone: 555-9814 Email: jones@abc.edf
flat:name(Steve-1, Jones-2)
list(Steve-1, Phone:-3)
list(Steve-1, Email:-5)
appos(Phone:-3, 555-9814-4)
appos(Email:-5, jones@abc.edf-6)
</code></pre>

<p>Another place where <code class="language-plaintext highlighter-rouge">list</code> has been used is for a sequence of attributes or descriptive terms used as the title line of a review (such as product or restaurant reviews, etc.):</p>

<pre><code class="language-sdparse">Long Lines , Silly Rules , Rude Staff , Ok Food
list(Lines, Rules)
list(Lines, Staff)
list(Lines, Food)
amod(Lines, Long)
amod(Rules, Silly)
amod(Staff, Rude)
amod(Food, Ok)
punct(Rules, ,-3)
punct(Staff, ,-6)
punct(Food, ,-9)
</code></pre>

<p>However, <code class="language-plaintext highlighter-rouge">list</code> should not be over-used. If a construction can easily be analyzed using the grammatical relations of standard sentences, typically as a coordinated structure, then it should be analyzed with these more standard relations, even if it is laid out as a list typographically.  In particular, when the list is written as a single sentence, with commas and overt coordination, then it should be analyzed as a coordinated structure.</p>

<!--
For list items, the de facto decision taken in [issue 156](https://github.com/UniversalDependencies/docs/issues/156) is that, for enumerated lists, regardless of whether the items are numbered with arabic, roman, or other numerals, or are given letters, we will regard the item contents as the head, and the item enumerator will be a `nummod` of it and given the part of speech `NUM`. Any punctuation with the list item will be a `punct` dependent of the item enumerator. For itemized lists with bullet, dash or similar markers, the current standard is to give the marker a `PUNCT` part of speech and then to give it the dependency relation `punct` to the head of the item content.
-->
<p>For list item markers, see <a href="">discourse</a>.</p>

<!-- Interlanguage links updated So 10. května 2025, 18:15:38 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/list.md" target="#">edit list</a></p>

<p><a id="al-u-dep/mark" class="al-dest"></a></p>
<h2><code>mark</code>: marker</h2>

<p>A marker is the word marking a clause as subordinate to
another clause. For a <a href="ccomp">complement clause</a>, this is words like [en] <em>that</em>
or <em>whether.</em> For an <a href="advcl">adverbial clause</a>, the marker is typically a
<a href="../pos/SCONJ">subordinating conjunction</a> like [en] <em>while</em> or <em>although.</em> The marker is a dependent of the
subordinate clause head. In a <a href="../overview/complex-syntax.html">relative clause</a>, it is a normally uninflected word, which simply introduces a relative clause, such as [he] <em>še</em>. (In this last use, one needs to distinguish between relative clause markers, which are <code class="language-plaintext highlighter-rouge">mark</code>, from relative pronouns such as [en] <em>who</em> or <em>that</em>, which fill a regular verbal argument or modifier grammatical relation.)</p>

<pre><code class="language-sdparse">Forces engaged in fighting after insurgents attacked
mark(attacked, after)
</code></pre>

<pre><code class="language-sdparse">He says that you like to swim
mark(like, that)
</code></pre>

<p>Infinitive markers (e.g. English <em>to,</em> German <em>zu</em>) in infinitival clauses are also attached as <code class="language-plaintext highlighter-rouge">mark</code>:</p>

<pre><code class="language-sdparse">Er kam wieder , um das Werk zu Ende zu bringen \n He came again , so-that the work to end to bring
mark(bringen, um)
mark(bringen, zu-10)
mark(bring, so-that)
mark(bring, to-22)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:39 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/mark.md" target="#">edit mark</a></p>

<p><a id="al-u-dep/nmod" class="al-dest"></a></p>
<h2><code>nmod</code>: nominal modifier</h2>

<p>The <code class="language-plaintext highlighter-rouge">nmod</code> relation is used for nominal dependents of another noun or noun phrase and functionally corresponds to
an attribute, or genitive complement.</p>

<p><strong>New from v2:</strong> The <code class="language-plaintext highlighter-rouge">nmod</code> relation was previously used also for nominal dependents of verbs, adjectives, and adverbs. These are now covered by the new <a href="">obl</a> relation.</p>

<p>In conjunction with the <a href="">case</a> relation, <code class="language-plaintext highlighter-rouge">nmod</code> provides a uniform analysis for the possessive alternation (with the option of a subtype like <code class="language-plaintext highlighter-rouge">nmod:poss</code> to distinguish non-adpositional case):</p>

<pre><code class="language-sdparse">the office of the Chair
det(office-2, the-1)
nmod(office-2, Chair-5)
case(Chair-5, of-3)
det(Chair-5, the-4)
</code></pre>

<pre><code class="language-sdparse">the Chair 's office
det(Chair-2, the-1)
nmod:poss(office-4, Chair-2)
case(Chair-2, 's-3)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:41 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/nmod.md" target="#">edit nmod</a></p>

<p><a id="al-u-dep/nmod:poss" class="al-dest"></a></p>
<h2><code>nmod:poss</code>: possessive nominal modifier</h2>

<p><code class="language-plaintext highlighter-rouge">nmod:poss</code> is used for a possessive nominal modifier. In English, for example, it is marked with the genitive <code class="language-plaintext highlighter-rouge">case</code> clitic <em>‘s</em> or one of its variant forms.</p>

<pre><code class="language-sdparse">Marie 's book
nmod:poss(book, Marie)
case(Marie, 's)
</code></pre>

<p><code class="language-plaintext highlighter-rouge">nmod:poss</code> must not be confused with the <a href="https://universaldependencies.org/en/feat/Poss.html">feature</a> <code class="language-plaintext highlighter-rouge">Poss=Yes</code> used for possessive pronouns. 
<code class="language-plaintext highlighter-rouge">nmod:poss</code> is only relevant for languages that have a particular construction, such as the possessive construction of English (also called Saxon genitive), that we want to distinguish from other <code class="language-plaintext highlighter-rouge">nmod</code> constructions.</p>

<!-- Interlanguage links updated So 10. května 2025, 18:15:45 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/nmod-poss.md" target="#">edit nmod:poss</a></p>

<p><a id="al-u-dep/nmod:tmod" class="al-dest"></a></p>
<h2><code>nmod:tmod</code>: temporal modifier</h2>

<p>A temporal nominal modifier of another nominal is a subtype of the <a href="">nmod</a> relation:
if the modifier is specifying a time, it is labeled as <code class="language-plaintext highlighter-rouge">tmod</code>.</p>

<pre><code class="language-sdparse">Are you free for lunch some day this week ?
nmod:tmod(day, week)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:15:46 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/nmod-tmod.md" target="#">edit nmod:tmod</a></p>

<p><a id="al-u-dep/nsubj" class="al-dest"></a></p>
<h2><code>nsubj</code>: nominal subject</h2>

<p>A nominal subject (<code class="language-plaintext highlighter-rouge">nsubj</code>) is a nominal which is the syntactic subject and the proto-agent of a clause.
That is, it is in the position that passes typical grammatical test for subjecthood, and this argument is the more agentive,
the do-er, or the proto-agent of the clause. This nominal may be headed by a noun, 
or it may be a pronoun or relative pronoun or, in ellipsis contexts, other things such as an adjective.</p>

<p><strong>New from v2:</strong> The <code class="language-plaintext highlighter-rouge">nsubj</code> relation is also used for the nominal subject of a passive verb or verb group, even
though the subject is then not typically the proto-agent argument due to valency changing operations. For languages
that have a grammaticalized passive transformation, it is strongly recommended to use the subtype <a href="">nsubj:pass</a> in 
such cases. If the subject is of a copular clause whose predicate is itself a clause, <a href="">nsubj:outer</a> may be used.</p>

<p>The governor of the <code class="language-plaintext highlighter-rouge">nsubj</code> relation might not always be a verb: when
the verb is a copular verb, the root of the clause is the complement
of the copular verb, which can be an adjective or noun, including a noun marked by a preposition,
as in the examples below.</p>

<p>The <code class="language-plaintext highlighter-rouge">nsubj</code> role is only applied to semantic arguments of a predicate.
When there is an empty argument in a grammatical subject position (sometimes called a pleonastic or expletive),
it is labeled as <a href="">expl</a>. If there is then a displaced subject
in the clause, as in the English existential <em>there</em> construction, it will be labeled as <code class="language-plaintext highlighter-rouge">nsubj</code>.)</p>

<pre><code class="language-sdparse">Clinton defeated Dole
nsubj(defeated, Clinton)
</code></pre>

<pre><code class="language-sdparse">Dole was defeated by Clinton
nsubj:pass(defeated, Dole)
</code></pre>

<pre><code class="language-sdparse">The car is red .
nsubj(red, car)
</code></pre>

<pre><code class="language-sdparse">Sue is a true patriot .
nsubj(patriot, Sue)
</code></pre>

<pre><code class="language-sdparse">We are in the barn .
nsubj(barn, We)
</code></pre>

<pre><code class="language-sdparse">Agatha is in trouble .
nsubj(trouble, Agatha)
</code></pre>

<pre><code class="language-sdparse">There is a ghost in the room .
expl(is, There)
nsubj(is, ghost)
</code></pre>

<pre><code class="language-sdparse">These links present the many viewpoints that existed .
acl:relcl(viewpoints, existed)
nsubj(existed, that)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:15:47 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/nsubj.md" target="#">edit nsubj</a></p>

<p><a id="al-u-dep/nsubj:outer" class="al-dest"></a></p>
<h2><code>nsubj:outer</code>: outer clause nominal subject</h2>

<p>This relation specifies a nominal subject of a copular clause whose predicate is itself a clause, 
to signal that it is not the subject of the nested clause.
See discussion of <a href="../overview/complex-syntax.html#predicate-clauses">Predicate Clauses</a>.</p>

<pre><code class="language-sdparse">-ROOT- The problem is that this has never been tried .
nsubj:outer(tried, problem)
cop(tried, is)
mark(tried, that)
nsubj:pass(tried, this)
aux(tried, has)
advmod(tried, never)
aux:pass(tried, been)
root(-ROOT-, tried)
</code></pre>

<pre><code class="language-sdparse">The title is Some Like It Hot .
nsubj:outer(Like, title)
cop(Like, is)
nsubj(Like, Some)
obj(Like, It)
xcomp(Like, Hot)
</code></pre>

<p>There may be an outer subject with no inner subject:</p>

<pre><code class="language-sdparse">The important thing is to keep calm .
nsubj:outer(keep, thing)
cop(keep, is)
mark(keep, to)
xcomp(keep, calm)
</code></pre>

<p>The clausal counterpart of this relation is <a href="">csubj:outer</a>.</p>

<p>Only subjects are required to be distinguished in this way. There may, for example, be inner and outer copulas, both attaching as <a href="">cop</a>:</p>

<pre><code class="language-sdparse">The important thing is to be calm .
nsubj:outer(calm, thing)
cop(calm, is)
mark(calm, to)
cop(calm, be)
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">:outer</code> subtype is <em>not</em> intended for most nominal subjects of copular clauses—only those where the predicate is itself a clause. 
Plain <a href="">nsubj</a> (or another subtype) will be appropriate if the copular clause predicate is a nominal, adjective, etc.:</p>

<pre><code class="language-sdparse">That book is very good .
nsubj(good, book)
</code></pre>

<pre><code class="language-sdparse">The title is Green Eggs and Ham .
nsubj(Eggs, title)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:50 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/nsubj-outer.md" target="#">edit nsubj:outer</a></p>

<p><a id="al-u-dep/nsubj:pass" class="al-dest"></a></p>
<h2><code>nsubj:pass</code>: passive nominal subject</h2>

<p>A passive nominal subject is a noun phrase which is the syntactic
subject of a passive clause.</p>

<pre><code class="language-sdparse">Schwarzenberg byl poražen Zemanem . \n Schwarzenberg was defeated by-Zeman .
nsubj:pass(poražen, Schwarzenberg-1)
nsubj:pass(defeated, Schwarzenberg-7)
</code></pre>

<p>Reflexive passive (the meaning is “This will be solved tomorrow.”)</p>

<pre><code class="language-sdparse">Tohle se bude řešit zítra . \n This itself will solve tomorrow .
nsubj:pass(řešit, Tohle)
nsubj:pass(solve, This)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:50 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/nsubj-pass.md" target="#">edit nsubj:pass</a></p>

<p><a id="al-u-dep/nummod" class="al-dest"></a></p>
<h2><code>nummod</code>: numeric modifier</h2>

<p>A numeric modifier of a noun is any <a href="u-pos/NUM">number</a> phrase
that serves to modify the meaning of the noun with a quantity.</p>

<pre><code class="language-sdparse">Sam ate 3 sheep
nummod(sheep, 3)
</code></pre>

<pre><code class="language-sdparse">Sam spent forty dollars
nummod(dollars, forty)
</code></pre>

<pre><code class="language-sdparse">Sam spent $ 40
nummod($, 40)
</code></pre>

<p>Note that indefinite quantifiers such as <em>few, many</em> are tagged
<a href="">u-pos/DET</a> rather than <a href="">u-pos/NUM</a>. 
Therefore their relation to the quantified noun is not <code class="language-plaintext highlighter-rouge">nummod</code> but
<a href="">det</a>:</p>

<pre><code class="language-sdparse">Sam ate many sheep
det(sheep, many)
</code></pre>

<p>Furthermore, a number that serves as a label for an entity rather than denoting quantity
is not <code class="language-plaintext highlighter-rouge">nummod</code>. For example, in <em>The meeting will be in room 4</em>, the number is the name
of a particular room, it is different from the expression <em>4 rooms</em>. Note that the label
of the room could also be non-numeric, as in <em>The meeting will be in room A</em>. UD analyzes
the number as a nominal (even if keeping the UPOS tag <a href="">NUM</a> for it). Hence the number
is attached as <a href="">nmod</a> to the noun it modifies, unless there is clear morphosyntactic
evidence in the language for the opposite direction. See also §3.6.3 of
<a href="https://doi.org/10.1162/coli_a_00402">de Marneffe et al. (2021)</a>.</p>

<pre><code class="language-sdparse">The meeting will be in room 4
det(meeting, The)
nsubj(room, meeting)
aux(room, will)
cop(room, be)
case(room, in)
nmod(room, 4)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:15:52 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/nummod.md" target="#">edit nummod</a></p>

<p><a id="al-u-dep/nummod:gov" class="al-dest"></a></p>
<h2><code>nummod:gov</code>: numeric modifier governing the case of the noun</h2>

<p><code class="language-plaintext highlighter-rouge">nummod:gov</code> differs from <a href="">nummod</a>
in that the numeral requires the counted noun to be in its genitive form.
The whole phrase (numeral + noun) is treated as a singular neuter noun phrase
and it can fill roles where nominative, accusative or vocative noun phrases are expected.
This construction occurs in many Slavic languages.</p>

<p>To increase parallelism across languages (and also across morphological cases within one language),
the numeral is not annotated as the head of the nominal. However, the <code class="language-plaintext highlighter-rouge">nummod:gov</code> label is used
to preserve the information about case conditions.</p>

<p>Czech:</p>

<pre><code class="language-sdparse">Pět mužů hrálo karty . \n Five men played cards .
nummod:gov(mužů, Pět)
nsubj(hrálo, mužů)
obj(hrálo, karty)
punct(hrálo, .-5)
nummod:gov(men, Five)
nsubj(played, men)
obj(played, cards)
punct(played, .-11)
</code></pre>

<p>See also <a href="">det:numgov</a> and <a href="">det:nummod</a>.</p>

<!-- Interlanguage links updated So 10. května 2025, 18:15:53 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/nummod-gov.md" target="#">edit nummod:gov</a></p>

<p><a id="al-u-dep/obj" class="al-dest"></a></p>
<h2><code>obj</code>: object</h2>

<p>The object of a verb is the second most core argument of a verb after the subject.
Typically, it is the noun phrase that denotes the entity acted upon or which undergoes a change of state or motion (the proto-patient).</p>

<pre><code class="language-sdparse">She gave me a raise
obj(gave, raise)
</code></pre>

<p>In languages distinguishing morphological <a href="u-feat/Case">cases</a>, the
object will often be marked by the accusative case. If a verb dictates
another case (dative, genitive…), the fundamental question is whether
such cases qualify as core in the given language. Often these cases
are oblique, regardless of the presence or absence of an adposition.
Consequently they cannot use the <code class="language-plaintext highlighter-rouge">obj</code> relation and must use <a href="">obl</a>,
even if the traditional grammar calls such dependents “objects”.</p>

<p>If there are two or more objects, one of them should be <code class="language-plaintext highlighter-rouge">obj</code> and the
others should be <a href="">iobj</a>. In such cases it is necessary to decide what
is the most directly affected object <em>(patient).</em>
If there is just one object, it should likely be <code class="language-plaintext highlighter-rouge">obj</code> 
unless it is morphosyntactically more similar to clear cases 
of <a href="">iobj</a> in the language than it is to prototypical patient arguments.</p>

<!--In general, if there is just one (core) object, it should be labeled `obj`,
regardless of the morphological case or semantic role that it bears.-->

<!--The one exception is when there is a clausal complement.
Then the clausal complement is regarded as a “clausal object” and an object nominal will be an [iobj]().-->

<p>There is further discussion of the two kinds of object at <a href="">iobj</a>.
If possible, language-specific documentation should be available to help identify the primary (or direct) object.
<!-- Interlanguage links updated So 10. května 2025, 18:15:53 CEST --></p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/obj.md" target="#">edit obj</a></p>

<p><a id="al-u-dep/obl" class="al-dest"></a></p>
<h2><code>obl</code>: oblique nominal</h2>

<p>The <code class="language-plaintext highlighter-rouge">obl</code> relation is used for a nominal (noun, pronoun, noun phrase) functioning as a non-core (oblique) argument or 
adjunct. This means that it functionally corresponds to an adverbial attaching to a verb, adjective or other adverb.</p>

<p>The <code class="language-plaintext highlighter-rouge">obl</code> relation can be further specified by the case. In conjunction with the <a href="">case</a> relation, it provides a uniform
analysis for:</p>

<ul>
  <li>variant forms with case, a preposition or a postposition, as in Finnish for example:</li>
</ul>

<pre><code class="language-sdparse">etsiä ilman johtolankaa \n to_search without clue.PARTITIVE
obl(etsiä, johtolankaa)
case(johtolankaa, ilman)
</code></pre>

<pre><code class="language-sdparse">etsiä taskulampun kanssa \n to_search torch.GENITIVE with
obl(etsiä, taskulampun)
case(taskulampun, kanssa)
</code></pre>

<pre><code class="language-sdparse">etsiä johtolangatta \n to_search clue.ABESSIVE
obl(etsiä, johtolangatta)
</code></pre>

<ul>
  <li>the dative alternation where the prepositional construction gets a similar analysis to the double object construction:</li>
</ul>

<pre><code class="language-sdparse">give the children the toys
obj(give, toys)
iobj(give, children)
</code></pre>

<pre><code class="language-sdparse">give the toys to the children
obj(give, toys)
obl(give, children)
case(children, to)
</code></pre>

<pre><code class="language-conllu"># give the toys to the children
1     donner    donner   VERB   _   VerbForm=Inf               0   root   _   give
2     les       le       DET    _   Definite=Def|Number=Plur   3   det    _   the
3     jouets    jouet    NOUN   _   Gender=Masc|Number=Plur    1   obj   _   toys
4-5   aux       _        _      _   _                          _   _      _   _
4     à         à        ADP    _   _                          6   case   _   to
5     les       le       DET    _   Definite=Def|Number=Plur   6   det    _   the
6     enfants   enfant   NOUN   _   Gender=Masc|Number=Plur    1   obl   _   children
</code></pre>

<p><code class="language-plaintext highlighter-rouge">obl</code> is also used for temporal and locational nominal modifiers:</p>

<pre><code class="language-sdparse">Last night , I swam in the pool
obl(swam, night)
obl(swam, pool)
</code></pre>

<p>and for the agent of a passive verb (with the subtype <a href="">obl:agent</a>):</p>

<pre><code class="language-sdparse">the cat was chased by the dog
nsubj:pass(chased, cat)
obl:agent(chased, dog)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:56 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/obl.md" target="#">edit obl</a></p>

<p><a id="al-u-dep/obl:agent" class="al-dest"></a></p>
<h2><code>obl:agent</code>: oblique agent in passive construction</h2>

<p>The relation <code class="language-plaintext highlighter-rouge">obl:agent</code> is used for agents of passive verbs. It is a subtype of <a href="">obl</a>, which covers all oblique nominals.
<code class="language-plaintext highlighter-rouge">obl:agent</code> is a <a href="/u/dep/">semi-mandatory subtype</a>, i.e. it should be used if the language has passives with oblique agents.</p>

<p>In English, the agent is marked by the preposition <em>by</em>:</p>

<pre><code class="language-sdparse">The cat was chased by the dog
nsubj:pass(chased, cat)
obl:agent(chased, dog)
case(dog, by)
</code></pre>

<p>In Czech, the agent is a nominal in the instrumental <a href="">Case</a>:</p>

<pre><code class="language-sdparse">Cena byla udělena děkanem fakulty . \n Prize was awarded by-dean of-faculty .
obl:agent(udělena, děkanem)
obl:agent(awarded, by-dean)
</code></pre>

<p>Typical agents are animate but it is not a rule.
Inanimate agents may be sometimes difficult to distinguish from instruments,
which are also coded by the instrumental case.
Instruments are attached using the simple relation <a href="">obl</a>.
Consider the following two examples, the first one is active and the second is passive.</p>

<pre><code class="language-sdparse">Praštil psa klackem . \n He-hit dog with-a-stick .
obl(Praštil, klackem)
obl(He-hit, with-a-stick)
</code></pre>

<pre><code class="language-sdparse">Pes byl praštěn klackem . \n Dog was hit with-a-stick .
obl(praštěn, klackem)
obl(hit, with-a-stick)
</code></pre>

<p>However, in passive sentences like <em>Byl přejet autem</em> “He was run over by a car,”
the car could be analyzed as an inanimate agent, but also as an instrument,
which is supported by the plausibility of the active counterpart,
<em>Přejeli ho autem</em> “They ran over him with a car.”
<!-- Interlanguage links updated So 10. května 2025, 18:15:58 CEST --></p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/obl-agent.md" target="#">edit obl:agent</a></p>

<p><a id="al-u-dep/obl:arg" class="al-dest"></a></p>
<h2><code>obl:arg</code>: oblique argument</h2>

<p>The relation <code class="language-plaintext highlighter-rouge">obl:arg</code> is used for oblique arguments and distinguishes them from
adjuncts, which use the plain <a href="">obl</a> relation. It is thus possible to preserve
the notion of <em>object</em> as it is defined in the traditional grammar of some
languages, where it essentially follows the distinction between arguments and
adjuncts (which is otherwise not reflected in the main UD relation types — see the
discussion <a href="../../u/overview/syntax.html#avoiding-an-argumentadjunct-distinction">here</a>).
A Czech example:</p>

<pre><code class="language-sdparse">Spoléhám se na jeho instinkt . \n I-rely REFL on his instinct .
obl:arg(Spoléhám, instinkt)
obl:arg(I-rely, instinct)
case(instinkt, na)
case(instinct, on)
</code></pre>

<p>Arguments are selected by the predicate. Their coding (preposition and
morphological case) is determined by the predicate; within the set of
arguments of this predicate, the coding maps the argument to a particular
semantic role.
In contrast, the semantics of an adjunct is relatively independent of the
predicate, and typical adjuncts (such as specifications of time, location,
manner or instrument) can combine with a large number of different predicates.</p>

<p>Hence in the above example, the preposition <em>na</em> “on” and the accusative case of
the noun <em>instinkt</em> “instinct” are selected by the verb <em>spoléhat</em> “to rely”.
Other verbs may also select the same preposition and case but the meaning will
be different: for instance, <em>myslet na někoho</em> “to think of someone.”
Finally, the preposition <em>na</em> itself has an adessive or allative meaning
(see the corresponding values of the <a href="../../u/feat/Case.html">Case</a> feature).
This meaning is suppressed when the preposition is selected by a predicate but
it is more recognizable in adjuncts. In the following example, the preposition
combines with a noun phrase in the locative case and marks a locational modifier:</p>

<pre><code class="language-sdparse">Konference se koná na Slovensku . \n Conference REFL takes-place in Slovakia .
obl(koná, Slovensku)
obl(takes-place, Slovakia)
case(Slovensku, na)
case(Slovakia, in)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:15:58 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/obl-arg.md" target="#">edit obl:arg</a></p>

<p><a id="al-u-dep/obl:lmod" class="al-dest"></a></p>
<h2><code>obl:lmod</code>: locative modifier</h2>

<p>A locative modifier is a subtype of the <a href="">obl</a> relation: if the modifier is specifying a location, it is labeled as <code class="language-plaintext highlighter-rouge">lmod</code>.</p>

<p>Danish: Drive the road you are told.</p>

<pre><code class="language-sdparse">Kør den vej , du får besked på . \n Drive the road , you get order to .
obl:lmod(Kør, vej)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:16:01 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/obl-lmod.md" target="#">edit obl:lmod</a></p>

<p><a id="al-u-dep/obl:tmod" class="al-dest"></a></p>
<h2><code>obl:tmod</code>: temporal modifier</h2>

<p>A temporal modifier is a subtype of the <a href="">obl</a> relation: if the modifier is specifying a time, it is labeled as <code class="language-plaintext highlighter-rouge">tmod</code>.</p>

<p><strong>⚠️ Beginning with the version 2.15 release, most English corpora use the new <a href="">obl:unmarked</a> relation instead.
So the examples below do not reflect current practice for English. ⚠️</strong></p>

<pre><code class="language-sdparse">Last night , I swam in the pool
obl:tmod(swam, night)
</code></pre>

<pre><code class="language-sdparse">You need to turn in your homework by next week
obl:tmod(turn, week)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:16:04 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/obl-tmod.md" target="#">edit obl:tmod</a></p>

<p><a id="al-u-dep/orphan" class="al-dest"></a></p>
<h2><code>orphan</code>: orphan</h2>

<p>The ‘orphan’ relation is used in cases of head <a href="http://universaldependencies.org/u/overview/specific-syntax.html#ellipsis">ellipsis</a> where simple promotion would result in an unnatural 
and misleading dependency relation. The typical case is predicate ellipsis where one of the core arguments
has to be promoted to clausal head.</p>

<pre><code class="language-sdparse">Marie won gold and Peter bronze
nsubj(won, Marie)
obj(won, gold)
conj(won, Peter)
cc(Peter, and)
orphan(Peter, bronze)
</code></pre>

<p>In this example, the subject <em>Peter</em> is promoted to the head position in the second conjunct. Attaching
the object <em>bronze</em> to the subject is necessary to preserve the integrity of the clause, but using the
standard relation <a href="">obj</a> would be misleading because <em>bronze</em> is not the object of <em>Peter</em>. Therefore,
the <code class="language-plaintext highlighter-rouge">orphan</code> relation is used to indicate that this is a non-standard attachment. By contrast, the coordinating
conjunction <em>and</em> performs essentially the same function as in the non-elliptical case and therefore retains
its normal relation <code class="language-plaintext highlighter-rouge">cc</code>.</p>

<p>See further discussion of <a href="http://universaldependencies.org/u/overview/specific-syntax.html#ellipsis">ellipsis</a>.
<!-- Interlanguage links updated So 10. května 2025, 18:16:05 CEST --></p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/orphan.md" target="#">edit orphan</a></p>

<p><a id="al-u-dep/parataxis" class="al-dest"></a></p>
<h2><code>parataxis</code>: parataxis</h2>

<p>The parataxis relation (from Greek for “place side by side”) is a
relation between a word (often the main predicate of a sentence) and other
elements, such as a sentential parenthetical or a clause after a “:” or
a “;”, placed side by side without any explicit
coordination, subordination, or argument relation with the head word. Parataxis is a discourse-like equivalent of coordination, and so usually obeys an iconic ordering. Hence it is normal for the first part of a sentence to be the head and the second part to be the parataxis dependent, regardless of the headedness properties of the language.  But things do get more complicated, such as cases of parentheticals, which appear medially.</p>

<pre><code class="language-sdparse">Let 's face it we 're annoyed
parataxis(Let, annoyed)
</code></pre>

<pre><code class="language-sdparse">The guy , John said , left early in the morning
parataxis(left, said)
punct(said, ,-3)
punct(said, ,-6)
</code></pre>

<h2 id="an-inventory-of-constructions-to-which-parataxis-has-been-applied">An inventory of constructions to which parataxis has been applied</h2>

<p><em>The following material is duplicated in the <a href="/u/overview/specific-syntax.html#paratactic-constructions">syntax overview</a>.</em></p>

<h3 id="side-by-side-sentences-run-on-sentences">Side-by-side sentences (“run-on sentences”)</h3>

<p>The parataxis relation is used for a pair of what could have been standalone sentences, 
but which are being treated together as a single sentence. This may happen because sentence
segmentation of the sentence was done primarily following the presence of sentence-final punctuation,
and these clauses are joined by punctuation such as a colon or comma, or not delimited by punctuation
at all. In a spoken corpus, it may happen because what is labeled as a sentence is more
commonly an utterance turn. Even if the treebanker is doing the sentence division, it may
happen because there seems to be a clear discourse relation linking two clauses. 
Sometimes there are more than two sentences joined in this way. In this case we make all the later sentences
dependents of the first one, to maximize similarity to the analysis used for conjunction.</p>

<pre><code class="language-sdparse">Bearded dragons are sight hunters , they need to see the food to move .
parataxis(hunters, need)
punct(need, ,)
</code></pre>

<p>This relation may happen with units that are smaller than sentences:</p>

<pre><code class="language-sdparse">Divided world the CIA
amod(world, Divided)
parataxis(world, CIA)
det(CIA, the)
</code></pre>

<h3 id="paired-clauses-with-non-conjunction-connective-x-so-y-etc">Paired clauses with non-conjunction connective (“X so Y” etc.)</h3>

<p>The relation is also used for clauses connected by a word like <em>so</em>, <em>then</em>, <em>therefore</em>, or <em>however</em> 
if neither clause is interpreted as modifying the other, and there is no coordinating conjunction:</p>

<pre><code class="language-sdparse">He claimed to be a wizard ; however/ADV , he turned out to be a humbug .
parataxis(claimed, turned)
advmod(turned, however)
</code></pre>

<pre><code class="language-sdparse">I 'm hungry , so/ADV I 'm getting a bagel .
parataxis(hungry, getting)
advmod(getting, so)
</code></pre>

<p>The following, by contrast, are <a href="">advcl</a> modifiers:</p>

<pre><code class="language-sdparse">Eat now so/ADV you wo n't be hungry later .
advcl(Eat, hungry)
advmod(hungry, so)
</code></pre>

<pre><code class="language-sdparse">If/SCONJ you build it , then/ADV they will come .
advcl(come, build)
mark(build, If)
advmod(come, then)
</code></pre>

<p>Note that <em>if</em>-clauses should almost always be analyzed as subordinate, even when <em>then</em> is present.</p>

<h3 id="reported-speech">Reported speech</h3>

<p>When a speech verb interrupts reported speech content, the interruption is treated as a parenthetical parataxis:</p>

<pre><code class="language-sdparse">The guy , John said , left early in the morning
parataxis(left, said)
punct(said, ,-3)
punct(said, ,-6)
</code></pre>

<p>See further discussion of reported speech at <a href="ccomp.html#reported-speech">ccomp</a>.</p>

<h3 id="news-article-bylines">News article bylines</h3>

<p>We have used the parataxis relation to connect the parts of a news article byline. 
There does not seem to be a better relation to use.</p>

<pre><code class="language-sdparse">Washington ( CNN ) :
parataxis(Washington, CNN)
punct(CNN, ()
punct(CNN, ))
punct(CNN, :)
</code></pre>

<h3 id="interjected-clauses">Interjected clauses</h3>

<p>Single word or phrase interjections are analyzed as <a href="">discourse</a>, but when a whole clause is interjected, we use the relation parataxis.</p>

<pre><code class="language-sdparse">Calafia has great fries ( they are to die for ! )
parataxis(has, are)
punct(are, ()
punct(are, ))
</code></pre>

<pre><code class="language-sdparse">Just to let you all know Matt has confirmed the booking for 3rd Dec is OK .
parataxis(confirmed, let)
</code></pre>

<p>In the second example, we treat the second half as the head of the dependency
because the first half feels like a whole clause interjection, not like the main clause of the utterance.</p>

<h3 id="tag-questions">Tag questions</h3>

<p>We also use the parataxis relation for tag questions such as <em>isn’t it?</em> or <em>haven’t you?</em>.</p>

<pre><code class="language-sdparse">It 's not me , is it ?
parataxis(me, is)
punct(is, ,)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:16:07 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/parataxis.md" target="#">edit parataxis</a></p>

<p><a id="al-u-dep/punct" class="al-dest"></a></p>
<h2><code>punct</code>: punctuation</h2>

<p>This is used for any piece of <a href="/u/pos/PUNCT.html">punctuation</a> in a clause, if punctuation
is being retained in the typed dependencies. Note that symbols tagged <a href="/u/pos/SYM.html">SYM</a>
are not punctuation and cannot be attached via the <code class="language-plaintext highlighter-rouge">punct</code> relation.</p>

<pre><code class="language-sdparse">Go home !
punct(Go, !)
</code></pre>

<p>Tokens with the relation <a href="">u-dep/punct</a> always attach to content words (except in cases of ellipsis) and can never have dependents.
Since <code class="language-plaintext highlighter-rouge">punct</code> is not a normal dependency relation, the usual criteria for determining the head word do not apply. 
Instead, we use the following principles:</p>

<ol>
  <li>A punctuation mark separating coordinated units is attached to the following conjunct.</li>
  <li>A punctuation mark preceding or following a dependent unit is attached to that unit.</li>
  <li>Within the relevant unit, a punctuation mark is attached at the highest possible node that preserves projectivity.</li>
  <li>Paired punctuation marks (e.g. quotes and brackets, sometimes also dashes, commas and other) should be attached to the same word unless that would create non-projectivity. This word is usually the head of the phrase enclosed in the paired punctuation.</li>
</ol>

<div id="punct1" class="sd-parse">
We have apples , pears , oranges , and bananas .
obj(have, apples)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(bananas, and)
punct(pears, ,-4)
punct(oranges, ,-6)
punct(bananas, ,-8)
</div>

<div id="punct2" class="sd-parse">
Der Mann , den Sie gestern kennengelernt haben , kam wieder .
punct(kennengelernt, ,-3)
punct(kennengelernt, ,-9)
punct(kam, .)
</div>

<div id="punct3" class="sd-parse">
A.K.A. , AKA , or a\/k\/a may refer to : “ Also known as ” , used to introduce pseudonyms , aliases , etc. ( Compare f.k.a. for “ formerly known as ” . )
punct(AKA, ,-2)
punct(a/k/a, ,-4)
punct(refer, :)
punct(known-13, “-11)
punct(known-13, ”-15)
punct(used, ,-16)
punct(aliases, ,-21)
punct(etc., ,-23)
punct(Compare, (-25)
punct(Compare, )-35)
punct(known-31, “-29)
punct(known-31, ”-33)
punct(Compare, .-34)
</div>

<p>See also examples at <a href="">parataxis</a>.
<!-- Interlanguage links updated So 10. května 2025, 18:16:11 CEST --></p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/punct.md" target="#">edit punct</a></p>

<p><a id="al-u-dep/reparandum" class="al-dest"></a></p>
<h2><code>reparandum</code>: overridden disfluency</h2>

<p>We use <code class="language-plaintext highlighter-rouge">reparandum</code> to indicate disfluencies overridden in a speech
repair. The disfluency is the dependent of the repair.</p>

<pre><code class="language-sdparse">Go to the righ- to the left .
obl(Go-1, left-7)
reparandum(left-7, righ-)
case(righ-, to-2)
det(righ-, the-3)
case(left-7, to-5)
det(left-7, the-6)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:16:11 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/reparandum.md" target="#">edit reparandum</a></p>

<p><a id="al-u-dep/root" class="al-dest"></a></p>
<h2><code>root</code>: root</h2>

<p>The <code class="language-plaintext highlighter-rouge">root</code> grammatical relation points to the root of the sentence. A fake node <code class="language-plaintext highlighter-rouge">ROOT</code> is used as the governor. The <code class="language-plaintext highlighter-rouge">ROOT</code> node is indexed with 0, since the indexing of real words in the sentence starts at 1. (The <code class="language-plaintext highlighter-rouge">ROOT</code> node is not represented
explicitly in CoNLL-U.)</p>

<pre><code class="language-sdparse">ROOT I love French fries .
root(ROOT, love)
</code></pre>

<p><strong>New from v2:</strong> There should be just one node with the <code class="language-plaintext highlighter-rouge">root</code> dependency relation in every tree. 
If the main predicate is not present (due to ellipsis) and there are multiple orphaned dependents, 
one of these is promoted to the head (root) position and the other orphans are attached to it.
(This rule has in practice been followed since release v1.2 but was not explicitly stated in the
original v1 guidelines.)</p>

<pre><code class="language-sdparse">ROOT And Robert the fourth place .
root(ROOT, Robert)
cc(Robert, And)
orphan(Robert, place)
punct(Robert, .)
amod(place, fourth)
det(place, the)
</code></pre>
<!-- Interlanguage links updated So 10. května 2025, 18:16:12 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/root.md" target="#">edit root</a></p>

<p><a id="al-u-dep/vocative" class="al-dest"></a></p>
<h2><code>vocative</code>: vocative</h2>

<p>The <em>vocative</em> relation is used to mark a dialogue participant addressed in a text (common in conversations, dialogue, emails, newsgroup postings, etc.). The relation links the addressee’s name to its host sentence. A vocative commonly co-occurs with a null subject, as in the first example below. If the nominal is clearly vocative in intent, the preference is to use the vocative relation.</p>

<pre><code class="language-sdparse">Guys , take it easy!
vocative(take, Guys)
</code></pre>

<pre><code class="language-sdparse">Marie , comment vas - tu ?
vocative(vas, Marie)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:16:13 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/vocative.md" target="#">edit vocative</a></p>

<p><a id="al-u-dep/xcomp" class="al-dest"></a></p>
<h2><code>xcomp</code>: open clausal complement</h2>

<p>An open clausal complement (<code class="language-plaintext highlighter-rouge">xcomp</code>) of a verb or an adjective is (i) a core argument of the verb, (ii) which is without its own subject and (iii) for which the 
reference of the subject is necessarily determined by an argument
external to the <code class="language-plaintext highlighter-rouge">xcomp</code>. The third requirement is often referred to as <em>obligatory control</em>.
An <code class="language-plaintext highlighter-rouge">xcomp</code> can also be described as a predicative complement. The subject of the <code class="language-plaintext highlighter-rouge">xcomp</code> is normally, but not always, controlled by the object of the next higher
clause, if there is one, or else by the subject of the next higher
clause.
These clauses tend to be non-finite in many languages,
but they can be finite as well. The name <code class="language-plaintext highlighter-rouge">xcomp</code> is
borrowed from Lexical-Functional Grammar (see Joan Bresnan, 2001, <em>Lexical-Functional Syntax</em>, chapter on “Predication Relations”).</p>

<pre><code class="language-sdparse">We expect them to change their minds
xcomp(expect, change)
obj(expect, them)
</code></pre>

<pre><code class="language-sdparse">Sue asked George to respond to her offer
xcomp(asked, respond)
iobj(asked, George)
</code></pre>

<pre><code class="language-sdparse">I started to work there yesterday
xcomp(started, work)
</code></pre>

<pre><code class="language-sdparse">You look great
xcomp(look, great)
</code></pre>

<pre><code class="language-sdparse">I consider him a fool
obj(consider, him)
xcomp(consider, fool)
</code></pre>

<pre><code class="language-sdparse">Louise struck me as a fool
obj(struck, me)
case(fool, as)
xcomp(struck, fool)
</code></pre>

<pre><code class="language-sdparse">I consider her honest
obj(consider, her)
xcomp(consider, honest)
</code></pre>

<pre><code class="language-sdparse">I regard her as honest
obj(regard, her)
mark(honest, as)
xcomp(regard, honest)
</code></pre>

<pre><code class="language-sdparse">We got COVID-19 under control
obj(got, COVID-19)
case(control, under)
xcomp(got, control)
</code></pre>

<pre><code class="language-sdparse">Susan is liable to be arrested
cop(liable, is)
xcomp(liable, arrested)
</code></pre>

<p>The predicative complement can be headed by various parts of speech, including a VERB, ADJ, or NOUN. A nominal predicative complement can be marked by a preposition (in English, often but not always by <em>as</em>). The <code class="language-plaintext highlighter-rouge">xcomp</code>-taking predicate of the higher clause can be a VERB or ADJ.</p>

<p>Contrast <code class="language-plaintext highlighter-rouge">xcomp</code> with other complement clauses where there is an overt subject or no obligatory control, which use <a href="">ccomp</a>:</p>

<pre><code class="language-sdparse">He says that you like to swim
ccomp(says, like)
</code></pre>

<pre><code class="language-sdparse">I suggest eating now before the food gets cold
ccomp(suggest, eating)
</code></pre>

<h3 id="the-inherited-subject-criterion">The Inherited Subject Criterion</h3>

<p>In examples like “I consider her honest”, the UD analysis corresponds to traditional grammar and what was termed “raising to object” in early generative grammar: the nominal “her” in these constructions is treated as the object of the higher clause (as its accusative morphology and ability to passivize suggests).</p>

<p>Note that the above condition “without its own subject” does not mean that a
clause is an <code class="language-plaintext highlighter-rouge">xcomp</code> just because its subject is not <em>overt.</em> The subject must be necessarily inherited from a fixed position in the higher clause. That is, there should be no available interpretation where the subject of the lower clause may be distinct
from the specified role of the upper clause. In cases where the missing subject may or must be distinct from a fixed role in the higher clause, <code class="language-plaintext highlighter-rouge">ccomp</code> should be used instead, as below.  This includes cases of arbitrary subjects and anaphoric control. In the following example, the subject of <em>start</em> or <em>starting</em> does not have to be the boss, it is any contextually relevant person or group of people. In addition, in these cases, the complement clause can often be replaced by a pronoun like <em>it</em> or <em>that</em> and it can sometimes be passivized (<em>Starting the project was recommended by the boss</em>).</p>

<pre><code class="language-sdparse">The boss said to start the project
ccomp(said, start)
</code></pre>

<pre><code class="language-sdparse">The boss recommended starting the project
ccomp(recommended, starting)
</code></pre>

<p>Pro-drop languages have clauses where the subject is not present as a separate word,
yet it is inherently present (and often deducible from the form of the verb).
The relation between clauses with pro-drop may or may not be <code class="language-plaintext highlighter-rouge">xcomp</code>.
The implicit subjects of a subordinate clause and a higher clause may be coincidentally coreferent, warranting <a href="">ccomp</a> or <a href="">advcl</a>:</p>

<pre><code class="language-sdparse">Píšu , protože jsem to slíbil . \n I-write , because I-have it promised .
advcl(Píšu, slíbil)
advcl(I-write, promised)
aux(slíbil, jsem)
aux(promised, I-have)
obj(slíbil, to)
obj(promised, it)
mark(slíbil, protože)
mark(promised, because)
</code></pre>

<pre><code class="language-sdparse">Slíbil jsem , že budu psát . \n Promised I-have , that I-will write .
ccomp(Slíbil, psát)
ccomp(Promised, write)
aux(Slíbil, jsem)
aux(Promised, I-have)
aux(psát, budu)
aux(write, I-will)
mark(psát, že)
mark(write, that)
</code></pre>

<p>It is only <code class="language-plaintext highlighter-rouge">xcomp</code> if the implicit subject depends on an argument from a higher clause (one cannot be varied without the other):</p>

<pre><code class="language-sdparse">Slíbil jsem psát . \n Promised I-have to-write .
xcomp(Slíbil, psát)
xcomp(Promised, to-write)
aux(Slíbil, jsem)
aux(Promised, I-have)
</code></pre>

<h3 id="secondary-predicates">Secondary Predicates</h3>

<p><em>The following is excerpted from <a href="../overview/complex-syntax.html#secondary-predicates">a more detailed discussion of secondary predicates</a>.</em></p>

<p>The <code class="language-plaintext highlighter-rouge">xcomp</code> relation is also used in constructions that are known as <em>secondary predicates</em> or <em>predicatives</em>.
Examples:</p>

<ul>
  <li><em>She declared the cake beautiful.</em></li>
  <li><em>She declared the cake a success.</em></li>
</ul>

<p>We could paraphrase the sentence using a subordinate clause: <em>She declared that the cake was beautiful.</em>
There are two predicates mixed in one clause: 1. she declared something, and 2. the cake was beautiful (according to her opinion).
The secondary predicate will be attached to the main predicate as an <code class="language-plaintext highlighter-rouge">xcomp</code>:</p>

<pre><code class="language-sdparse">She declared the cake beautiful .
nsubj(declared, She)
obj(declared, cake)
xcomp(declared, beautiful)
</code></pre>

<p>The subject of “declared” is again obligatorily controlled by a role in the higher clause. In the enhanced representation, there is an additional subject link showing the secondary predication:</p>

<pre><code class="language-sdparse">She declared the cake beautiful .
nsubj(declared, She)
obj(declared, cake)
xcomp(declared, beautiful)
nsubj(beautiful, cake)
</code></pre>

<p>A Czech example:</p>

<pre><code class="language-sdparse">jmenovat někoho generálem \n to-appoint someone as-a-general
obj(jmenovat, někoho)
xcomp(jmenovat, generálem)
</code></pre>

<p>Remember that <code class="language-plaintext highlighter-rouge">xcomp</code> is used for core arguments of predicates
so it will not be used for non-core instances of secondary predication.
For instance, in <em>She entered the room sad</em> we also have a double predication
(she entered the room; she was sad).
But <em>sad</em> is not a core argument of <em>enter:</em> leaving it out will neither affect grammaticality
nor significantly alter the meaning of the verb.
On the other hand, leaving out <em>beautiful</em> in <em>she declared the cake beautiful</em>
will either render the sentence ungrammatical or lead to a different interpretation of <em>declared.</em></p>

<p>The result is that in <em>She entered the room sad</em>, <em>sad</em> is considered a modifier (not complement) of the verb,
with the relation <a href="">advcl</a> instead of <code class="language-plaintext highlighter-rouge">xcomp</code>.
(This was <a href="/changes.html#optional-depictives">changed</a> from the previous approach which analyzed the secondary predication directly with <a href="">acl</a>,
because the nominal predicand is not always overt, and even when it is, the adjective does not really belong to the same nominal phrase.)</p>

<pre><code class="language-sdparse">She entered the room sad .
nsubj(entered, She)
det(room, the)
obj(entered, room)
advcl(entered, sad)
punct(entered, .)
</code></pre>

<pre><code class="language-sdparse">Entering the room sad is not recommended .
csubj(recommended, Entering)
det(room, the)
obj(Entering, room)
advcl(Entering, sad)
cop(recommended, is)
advmod(recommended, not)
punct(recommended, .)
</code></pre>

<p>Notice that <em>while</em> can be inserted before <em>sad</em>, clearly marking it as a clause.</p>

<p>A Czech example:</p>

<pre><code class="language-sdparse">Vstoupila do místnosti smutná . \n She-entered to room sad .
advcl(Vstoupila, smutná)
advcl(She-entered, sad)
</code></pre>

<p>There is no need to decide whether an example like the following is a depictive or a manner adverbial:</p>

<pre><code class="language-sdparse">Linda found the money walking our dog .
nsubj(found, Linda)
det(money, the)
obj(found, money)
advcl(found, walking)
det(dog, our)
obj(walking, dog)
punct(found, .)
</code></pre>

<p>The optional secondary predication or controlled adjunct subject relation can be represented with an enhanced dependency edge
in addition to the <a href="">advcl</a> relation.</p>

<p>Some other cases that <em>could</em> be regarded as secondary predicates are just treated as obliques. In particular, locative arguments of verbs are always treated as obliques:</p>

<pre><code class="language-sdparse">She put a book on the table .
nsubj(put, She)
det(book, a)
obj(put, book)
case(table, on)
det(table, the)
obl(put, table)
punct(put, .)
</code></pre>

<!-- Interlanguage links updated So 10. května 2025, 18:16:14 CEST -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-dep/xcomp.md" target="#">edit xcomp</a></p>


      </div>

<!-- support for embedded visualizations -->
<script type="text/javascript">
    var root = '../../'; // filled in by jekyll
    head.js(
        // We assume that external libraries such as jquery.min.js have already been loaded outside!
        // (See _layouts/base.html.)

        // brat helper modules
        root + 'lib/brat/configuration.js',
        root + 'lib/brat/util.js',
        root + 'lib/brat/annotation_log.js',
        root + 'lib/ext/webfont.js',
        // brat modules
        root + 'lib/brat/dispatcher.js',
        root + 'lib/brat/url_monitor.js',
        root + 'lib/brat/visualizer.js',

        // embedding configuration
        root + 'lib/local/config.js',
        // project-specific collection data
        root + 'lib/local/collections.js',

        // Annodoc
        root + 'lib/annodoc/annodoc.js',

        // NOTE: non-local libraries
        'https://spyysalo.github.io/conllu.js/conllu.js'
    );

    var webFontURLs = [
//        root + 'static/fonts/Astloch-Bold.ttf',
        root + 'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        root + 'static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var setupTimeago = function() {
        jQuery("time.timeago").timeago();
    };

    head.ready(function() {
        setupTimeago();

        // mark current collection (filled in by Jekyll)
        Collections.listing['_current'] = 'u-overview';

	// perform all embedding and support functions
	Annodoc.activate(Config.bratCollData, Collections.listing);
    });
</script>


<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55233688-1', 'auto');
  ga('send', 'pageview');

</script>


      <div id="footer">
          <p class="footer-text">&copy; 2014–2024
            <a href="http://universaldependencies.org/introduction.html#contributors" style="color:gray">Universal Dependencies contributors</a>.
            Site powered by <a href="http://spyysalo.github.io/annodoc" style="color:gray">Annodoc</a> and <a href="http://brat.nlplab.org/" style="color:gray">brat</a></p>.
      </div>
    </div>
  </body>
</html>
