<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Simple Clauses</title>
    <link rel="root" href=""/> <!-- for JS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="../../css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style-vis.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/hint.css"/>
    <script type="text/javascript" src="../../lib/ext/head.load.min.js"></script>
    <script type="text/javascript" src="../../lib/ext/jquery.timeago.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.2.2/anchor.min.js"></script>
    <script>document.addEventListener("DOMContentLoaded", function(event) {anchors.add();});</script>
    <!-- Set up this custom Google search at https://cse.google.com/cse/business/settings?cx=001145188882102106025:dl1mehhcgbo -->
    <script>
      (function() {
        var cx = '001145188882102106025:dl1mehhcgbo';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->


  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
        <table width="100%"><tr><td width="50%">
          <span class="header-text"><a href="http://universaldependencies.org/#language-u">home</a></span>

          <span class="header-text"><a href="https://github.com/universaldependencies/docs/edit/pages-source/_u-overview/simple-syntax.md" target="#">edit page</a></span>
          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
        </td><td>
          <gcse:search></gcse:search>
        </td></tr></table>
      </div>

      <hr/>

      
      <div class="v2complete">
	This page pertains to UD version 2.
      </div>
      
      
      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          <h1 id="simple-clauses">Simple Clauses</h1>

<p>The UD annotation assumes the clause as one of the basic structures that we expect to find in all languages. A simple clause minimally consists of a predicate together with its core argument dependents, but may be extended with oblique modifiers. Core arguments are typically nominals, while oblique modifiers are either (oblique) nominals or adverbial modifiers. (In <a href="complex-syntax.html">complex clauses</a>, both core arguments and oblique modifiers can also be realized as subordinate clauses.) Finally, the predicate may be associated with function words that express different types of grammatical information such as tense, mood, aspect, voice, evidentiality, or type of subordination.</p>

<ul>
  <li><a href="#intransitive-and-transitive-clauses">Intransitive and transitive clauses</a></li>
  <li><a href="#nonverbal-clauses">Nonverbal clauses</a></li>
  <li><a href="#non-core-dependents">Non-core dependents</a></li>
  <li><a href="#function-word-dependents">Function word dependents</a></li>
</ul>

<h2 id="intransitive-and-transitive-clauses">Intransitive and Transitive Clauses</h2>

<p>In most clauses, the predicate takes the form of a verb, which may be intransitive or transitive.</p>

<pre><code class="language-sdparse">she left
nsubj(left, she)
</code></pre>
<pre><code class="language-sdparse">she left a note
nsubj(left, she)
obj(left, note)
</code></pre>

<p>An intransitive verb takes a single argument (usually referred to as S in the literature on linguistic typology) with the <a href="">u-dep/nsubj</a> relation. A transitive verb in addition takes an argument with the <a href="">u-dep/obj</a> relation. When deciding which relation to use with which argument in a transitive clause, the <a href="">u-dep/nsubj</a> relation should be used with the argument that most resembles the proto-agent (often called A in linguistic typology) and that satisfies additional language-internal criteria for subjecthood based on case-marking, agreement and/or linear position with respect to the predicate. The <a href="">u-dep/obj</a> relation should be used for the argument that most resembles the proto-patient (often called O or P in linguistic typology) and that satisfies relevant language-internal criteria. Note that, while case-marking (whether morphological or analytic) can provide important evidence in specific languages, case alignment should not be used to decide the assignment of core argument roles. Thus, in ergative languages, the patient-like argument of a transitive verb (O/P) will take the the <a href="">u-dep/obj</a> relation despite the fact that it carries the same case marking as the <a href="">u-dep/nsubj</a> argument (S) of an intranstive verb.</p>

<p>Some languages allow extended transitive clauses, where more than two dependents are realized as core arguments. The additional core arguments then receive the <a href="">u-dep/iobj</a> relation (for “indirect object”), while the <a href="">u-dep/obj</a> relation 
is reserved for the argument most patient-like non-subject argument. The criterion for deciding whether an additional dependent is a core argument is whether it has the typical encoding of a core argument with respect to case-marking, agreement and word order. For example, the English double object construction qualifies as an extended transitive clause because all three nominals appear without prepositions:</p>

<pre><code class="language-sdparse">she left him a note
nsubj(left, she)
obj(left, note)
iobj(left, him)
</code></pre>

<p>By contrast, the alternative construction where the recipient role is realized by a prepositional phrase is <em>not</em> an extended transitive by our criteria, and the third participant should therefore be annotated as oblique in this case.</p>

<pre><code class="language-sdparse">she left a note to him
nsubj(left, she)
obj(left, note)
obl(left, him)
</code></pre>

<p>It follows that the semantic role cannot (by itself) be used to determine whether a dependent is core or not, nor can its status as an obligatory dependent. UD does not make a distinction between (obligatory) arguments and (optional) adjuncts, and oblique dependents can be either arguments or adjuncts.</p>

<p>Note, finally, that not all languages allow extended transitives (and some do only in connection with special valency-changing operationssuch as applicatives). Hence, the <a href="">u-dep/iobj</a> relation will not be used in all languages.</p>

<h3 id="valency-changing-operations">Valency-Changing Operations</h3>

<p>If passivization involves the promotion of an argument to subject position, then this argument can be 
annotated with a special subtype <code>nsubj:pass</code> to indicate that promotion has taken place. The subtype
<code>obl:agent</code> can be used to annotated the demoted subject (if present).</p>

<pre><code class="language-sdparse">she left a note on the table
nsubj(left, she)
obj(left, note)
obl(left, table)
</code></pre>
<pre><code class="language-sdparse">a note was left on the table
nsubj:pass(left, note)
obl(left, table)
</code></pre>
<pre><code class="language-sdparse">a note was left by her on the table
nsubj:pass(left, note)
obl:agent(left, her)
obl(left, table)
</code></pre>

<p>Similar subtyping can be used for other valency-changing operations. With causatives, for example, subtypes
like <code>obj:caus</code> and <code>iobj:caus</code> can be used to indicate that an object is a demoted subject in relation to the non-causative form of the verb.</p>

<pre><code class="language-sdparse">Hasan koştu \n Hasan ran
nsubj(koştu, Hasan)
</code></pre>
<pre><code class="language-sdparse">(ben) Hasanı koşturdum \n I Hasan made-run
obj:caus(koşturdum, Hasanı)
</code></pre>
<pre><code class="language-sdparse">Hasan kitabı okudu \n Hasan book read
obj(okudu, kitabı)
</code></pre>
<pre><code class="language-sdparse">(ben) Hasana kitabı okuttum \n I I Hasan book made-read
obj(okuttum, kitabı)
iobj:caus(okuttum, Hasana)
</code></pre>

<h2 id="nonverbal-clauses">Nonverbal Clauses</h2>

<p>A nonverbal predicate (nominal or adjective) takes a single argument with the <a href="">u-dep/nsubj</a> relation.
The core argument relation is the same regardless of whether there is an overt copula linking the predicate
to the subject or not.</p>

<pre><code class="language-sdparse">she is my mother
nsubj(mother, she)
</code></pre>
<pre><code class="language-sdparse">она моя мать \n she my mother
nsubj(мать, она)
nsubj(mother, she)
</code></pre>
<pre><code class="language-sdparse">she is nice
nsubj(nice, she)
</code></pre>
<pre><code class="language-sdparse">она милая \n she nice
nsubj(милая, она)
nsubj(nice, she)
</code></pre>

<p>In order to achieve a consistent treatment of nonverbal predication in v2, we first define six categories of nonverbal predication that can be found cross-linguistically (with or without a copula):</p>

<ol>
  <li>Equation (aka identification): “she is my mother”</li>
  <li>Attribution: “she is nice”</li>
  <li>Location: “she is in the bathroom”</li>
  <li>Possession: “the book is hers”</li>
  <li>Benefaction: “the book is for her”</li>
  <li>Existence: “there is food (in the kitchen)”</li>
</ol>

<p>We then give the following guidelines for the analysis of these constructions:</p>

<ul>
  <li>If there is no overt linking word (or if such a word can be omitted at least in some persons or tenses), then the predicative nominal is treated as the head of the clause regardless of which of the six categories it falls in. In languages with fixed SVO order (like English), the final nominal is the predicate and the first nominal is the subject. In free-word-order languages it is possible that the first nominal is the predicate, and distinguishing the subject from the predicate is based on language-specific criteria.</li>
  <li>If there is an overt linking word used in equational constructions (category 1), then that word is treated as a copula and marked with the <a href="">u-dep/cop</a> dependency, and is not the head of the clause. <strong>Exception:</strong> If the predicative element in the equation is a clause, then the copula verb is treated as the head of the clause, with the following clause as a <a href="">u-dep/ccomp</a> (to prevent that the head of the smaller clause gets two subjects). Note that in some languages it may be instead possible to analyze the clause as the subject (<a href="">u-dep/csubj</a>), retaining the <a href="">u-dep/cop</a> relation for the copula verb.</li>
  <li>If there is an overt word used in existential constructions (category 6), which is different from the copula in equational constructions (either a different lemma or with different syntax), then it should be regarded as the head of existential clauses, taking a subject (and often a locative <a href="">u-dep/obl</a>).</li>
  <li>All other cases of putative copula constructions (categories 2-5) should be assimilated to the equational and existential cases as seems to make most sense according to the inherent logic of the language concerned.</li>
  <li>A language should normally have at most one copula, but exceptions can be made in case of defective paradigms or if there are two verbs alternating in categories 1-5 (but not in 6) and where any meaning difference reflect at most TAME categories.</li>
</ul>

<p>To illustrate how these guidelines apply to different languages, we now given parallel examples from English, Irish, Swedish, Czech, Russian and Turkish.</p>

<h3 id="english">English</h3>

<p>In English, the verb “to be” is used in all of (1-6), and a copula analysis is therefore used consistently, except for equated clauses (1b) and existentials (6), where the verb must be treated as the head of the clause.</p>

<p>(1a)</p>

<pre><code class="language-sdparse">she is my mother
nsubj(mother, she)
cop(mother, is)
</code></pre>

<p>(1b)</p>

<pre><code class="language-sdparse">the fact is that she is my mother
nsubj(is-3, fact)
ccomp(is-3, mother)
nsubj(mother, she)
cop(mother, is-6)
</code></pre>

<p>(2)</p>

<pre><code class="language-sdparse">she is nice
nsubj(nice, she)
cop(nice, is)
</code></pre>

<p>(3)</p>

<pre><code class="language-sdparse">she is in the kitchen
nsubj(kitchen, she)
cop(kitchen, is)
case(kitchen, in)
</code></pre>

<p>(4)</p>

<pre><code class="language-sdparse">it is hers
nsubj(hers, it)
cop(hers, is)
</code></pre>

<p>(5)</p>

<pre><code class="language-sdparse">it is for her
nsubj(her, it)
cop(her, is)
case(her, for)
</code></pre>

<p>(6a)</p>

<pre><code class="language-sdparse">there is food
expl(is, there)
nsubj(is, food)
</code></pre>

<p>(6b)</p>

<pre><code class="language-sdparse">there is food in the kitchen
expl(is, there)
nsubj(is, food)
obl(is, kitchen)
case(kitchen, in)
</code></pre>

<h3 id="irish">Irish</h3>

<p>Irish uses a copula verb in categories 1, 4 and 5, and a different verb in categories 2, 3 and 6. Not only the verb but also the word order is different.</p>

<p>(1)</p>

<pre><code class="language-sdparse">is ise mo mháthair \n COP her my mother
nsubj(mháthair, ise)
cop(mháthair, is)
</code></pre>

<p>(2)</p>

<pre><code class="language-sdparse">tá sí deas \n is she nice
nsubj(tá, sí)
xcomp(tá, deas)
</code></pre>

<p>(3)</p>

<pre><code class="language-sdparse">tá sí sa seomra folctha \n is she in room bath
nsubj(tá, sí)
xcomp(tá, seomra)
</code></pre>

<p>(4)</p>

<pre><code class="language-sdparse">is lei an leabhar \n COP with her the book
nsubj(leabhar, lei)
cop(leabhar, is)
</code></pre>

<p>(5)</p>

<pre><code class="language-sdparse">is di an leabhar \n COP with her the book
nsubj(leabhar, di)
cop(leabhar, is)
</code></pre>

<p>(6)</p>

<pre><code class="language-sdparse">tá bia ann
nsubj(tá, bia)
</code></pre>

<h3 id="czech">Czech</h3>

<p>The Czech verb <em>být</em> is used in all categories (1-6) and can be analyzed as copula everywhere except for pure existentials (without location) where no predicate other than the verb is available. Czech word order is free and it is not guaranteed that all constructions will come out as subject-copula-predicate. Reversed order (predicate-copula-subject) is less common but possible, even in the “equation” category (1). Czech is a pro-drop language which means that pronominal subjects are optional.</p>

<p>(1a)</p>

<pre><code class="language-sdparse">(ona) je moje matka \n she is my mother
nsubj(matka, (ona))
nsubj(mother, she)
cop(matka, je)
cop(mother, is)
</code></pre>

<p>(1b)</p>

<pre><code class="language-sdparse">faktem je , že ona je moje matka \n fact is , that she is my mother
cop(faktem, je-2)
cop(fact, is-11)
csubj(faktem, matka)
csubj(fact, mother)
nsubj(matka, ona)
nsubj(mother, she)
cop(matka, je-6)
cop(mother, is-15)
</code></pre>

<p>(2)</p>

<pre><code class="language-sdparse">(ona) je milá \n she is nice
nsubj(milá, (ona))
nsubj(nice, she)
cop(milá, je)
cop(nice, is)
</code></pre>

<p>(3)</p>

<pre><code class="language-sdparse">(ona) je v kuchyni \n she is in kitchen
nsubj(kuchyni, (ona))
nsubj(kitchen, she)
cop(kuchyni, je)
cop(kitchen, is)
case(kuchyni, v)
case(kitchen, in)
</code></pre>

<p>(4)</p>

<pre><code class="language-sdparse">to je její \n it is hers
nsubj(její, to)
nsubj(hers, it)
cop(její, je)
cop(hers, is)
</code></pre>

<p>(5)</p>

<pre><code class="language-sdparse">to je pro ni \n it is for her
nsubj(ni, to)
nsubj(her, it)
cop(ni, je)
cop(her, is)
case(ni, pro)
case(her, for)
</code></pre>

<p>(6a)</p>

<pre><code class="language-sdparse">jídlo je \n food is
nsubj(je, jídlo)
nsubj(is, food)
</code></pre>

<p>(6b)</p>

<pre><code class="language-sdparse">v kuchyni je jídlo \n in kitchen is food
nsubj(kuchyni, jídlo)
nsubj(kitchen, food)
cop(kuchyni, je)
cop(kitchen, is)
case(kuchyni, v)
case(kitchen, in)
</code></pre>

<h3 id="russian">Russian</h3>

<p>In Russian, there is no copula verb in the present tense. In the future and past tenses, the verb <em>быть</em> “be” is used.
The same analysis applies to categories (1-5).</p>

<p>(1a)</p>

<pre><code class="language-sdparse">она моя мать \n she my mother
nsubj(мать, она)
nsubj(mother, she)
</code></pre>

<p>(1b)</p>

<p>When the second part is a clause, the demonstrative pronoun <em>то</em> must be inserted. As a result, we have a different syntactic structure with different analysis: the clause formally modifies a nominal represented by the demonstrative.</p>

<pre><code class="language-sdparse">дело в том , что она моя мать \n fact in that , that she my mother
nsubj(том, дело)
nsubj(that-12, fact)
acl(том, мать)
acl(that-12, mother)
nsubj(мать, она)
nsubj(mother, she)
</code></pre>

<p>(2)</p>

<pre><code class="language-sdparse">она милая \n she nice
nsubj(милая, она)
nsubj(nice, she)
</code></pre>

<p>(3)</p>

<pre><code class="language-sdparse">она на кухне \n she in kitchen
nsubj(кухне, она)
nsubj(kitchen, she)
case(кухне, на)
case(kitchen, in)
</code></pre>

<p>(4)</p>

<pre><code class="language-sdparse">это ее \n it hers
nsubj(ее, это)
nsubj(hers, it)
</code></pre>

<p>(5)</p>

<pre><code class="language-sdparse">это для нее \n it for her
nsubj(нее, это)
nsubj(her, it)
case(нее, для)
case(her, for)
</code></pre>

<p>(6a)</p>

<p>The form <em>есть</em> is originally the 3rd person singular present indicative of the verb <em>быть</em> (which also functions as copula). However, in Modern Russian this form is used only in existential statements, in both numbers and all persons. Past and future existential statements still use normal forms of <em>быть.</em></p>

<pre><code class="language-sdparse">есть еда \n is food
nsubj(есть, еда)
nsubj(is, food)
</code></pre>

<p>(6b)</p>

<pre><code class="language-sdparse">есть еда на кухне \n is food in kitchen
nsubj(есть, еда)
nsubj(is, food)
obl(есть, кухне)
obl(is, kitchen)
case(кухне, на)
case(kitchen, in)
</code></pre>

<h3 id="turkish">Turkish</h3>

<p>In Turkish, there are two copula verbs, <em>i-</em> and <em>ol-</em>. The “true” copula is <em>i-</em> which is defective, only having a limited number of tense forms (aorist and past), and cliticising. When a copula is needed in another tense, <em>ol-</em> is employed. However, if there is a form of <em>i-</em> then the equivalent form of <em>ol-</em> takes on the meaning “become”.</p>

<p>In the present tense, third person singular aorist non-formal then there is no overt suffix for third person singular. Unlike Russian, where the copula verb does not appear in any part of the present tense paradigm, in Turkish it appears in all persons except third person (compare 1a and 1b). This means that it is more like the nominative case in the paradigm (which also has a -Ø suffix, than like the Russian copula).</p>

<p>In Turkish (and indeed in most Turkic languages), existence is a syntactically different (see 6a and 6b), using an adjective <em>var</em> “existent”, and so gets a different structure.</p>

<p>(1a)</p>

<pre><code class="language-sdparse">O benim annem . \n she my mother
nsubj(annem, O)
nsubj(mother, she)
</code></pre>

<p>(1a)</p>

<pre><code class="language-sdparse">Ben senin baban -ım . \n I your father am
nsubj(baban, Ben)
cop(baban, -ım)
nsubj(father, I)
</code></pre>

<p>(1c)</p>

<pre><code class="language-sdparse">O benim annem -di . \n she my mother was
nsubj(annem, O)
cop(annem, -di)
nsubj(mother, she)
</code></pre>

<p>(2)</p>

<pre><code class="language-sdparse">O hoş . \n She nice
nsubj(hoş, O)
nsubj(nice, She)
</code></pre>

<p>(3)</p>

<pre><code class="language-sdparse">O mutfakta . \n She kitchen-in .
nsubj(mutfakta, O)
nsubj(kitchen-in, She)
</code></pre>

<p>(4)</p>

<pre><code class="language-sdparse">Bu onun . \n It hers .
nsubj(onun, Bu)
nsubj(hers, It)
</code></pre>

<p>(5)</p>

<pre><code class="language-sdparse">Bu onun için . \n It hers for .
nsubj(onun, Bu)
case(onun, için)
nsubj(hers, It)
case(hers, for)
</code></pre>

<p>(6a</p>

<pre><code class="language-sdparse">Yemek var . \n Food existing .
nsubj(var, Yemek)
nsubj(existing, Food)
</code></pre>

<p>(6b)</p>

<pre><code class="language-sdparse">Mutfakta yemek var . \n Kitchen-in food existing .
nsubj(var, yemek)
obl(var, Mutfakta)
nsubj(existing, food)
obl(existing, Kitchen-in)
</code></pre>

<h2 id="non-core-dependents">Non-Core Dependents</h2>

<p>In addition to the core arguments, a predicate may have additional dependents whose grammatical encoding differs 
from that of core arguments with respect to case marking, agreement and/or linear position in the clause. All such
dependents are said to be oblique, regardless of whether they can be considered as arguments in the semantic sense. 
The <a href="">obl</a> relation is used for oblique nominals, and the <a href="">advmod</a> relation is used for adverbial modifiers.</p>

<pre><code class="language-sdparse">she left a note on the table
nsubj(left, she)
obj(left, note)
obl(left, table)
</code></pre>
<pre><code class="language-sdparse">she left a note in the morning
nsubj(left, she)
obj(left, note)
obl(left, morning)
</code></pre>
<pre><code class="language-sdparse">she left from home
nsubj(left, she)
obl(left, home)
</code></pre>
<pre><code class="language-sdparse">she left suddenly
nsubj(left, she)
advmod(left, suddenly)
</code></pre>

<p>In addition to the general <a href="">u-dep/obl</a> relation, there are three special relations that are used for non-core dependents of a predicate: <a href="">u-dep/expl</a>, <a href="">u-dep/dislocated</a>, and <a href="">u-dep/vocative</a>.</p>

<h3 id="expletives">Expletives</h3>

<p>The <a href="">u-dep/expl</a> relation captures expletive or pleonastic nominals. These are nominals that appear in an argument position of a predicate but which do not themselves satisfy any of the semantic roles of the predicate. The main predicate of the clause (the verb or predicate adjective or noun) is the governor. In English, this is the case for some uses of <em>it</em> and <em>there</em>: the existential <em>there</em>, and <em>it</em> when used in extraposition constructions.  (Note that both <em>it</em> and <em>there</em> also have non-expletive uses.)</p>

<pre><code class="language-sdparse">There is a ghost in the room
expl(is, There)
</code></pre>

<pre><code class="language-sdparse">It is clear that we should decline .
expl(clear, It)
</code></pre>

<p>Some languages do not have expletives of the English sort, including most languages with free pro-drop (the ability to use zero anaphora rather than overt pronouns). In languages with expletives of this sort, they can be positioned where normally a core argument appears: the subject and direct object (and even indirect object) slots, as in the examples below. Note that in the analysis of these examples, we treat the postposed subject or clausal argument as a regular core argument, and mark the expletive with <a href="">u-dep/expl</a>.</p>

<pre><code class="language-sdparse">There is a ghost in the room
expl(is, There)
nsubj(is, ghost)
obl(is, room)
</code></pre>

<pre><code class="language-sdparse">I believe there to be a ghost in the room
nsubj(believe, I)
expl(believe, there)
xcomp(believe, be)
nsubj(be, ghost)
obl(be, room)
</code></pre>

<pre><code class="language-sdparse">It is clear that we should decline .
expl(clear, It)
csubj(clear, decline)
</code></pre>

<pre><code class="language-sdparse">That we should decline is clear .
csubj(clear, decline)
</code></pre>

<pre><code class="language-sdparse">I mentioned it to Mary that Sue is leaving
nsubj(mentioned, I)
expl(mentioned, it)
obl(mentioned, Mary)
ccomp(mentioned, leaving)
</code></pre>

<p>A second, related, use of the <a href="">u-dep/expl</a> relation is for cases of true clitic doubling.  For languages in which clitics and lexical nominals are ususally in complementary distribution – languages, such as French, which obey “Kayne’s generalization” – then whichever of a clitic or a lexical nominal occurs will get the appropriate role, such as <a href="">u-dep/obj</a> or <a href="">u-dep/iobj</a>. In such languages, when doubling does occur, such as in spoken French, the right analysis is to regard the lexical nominal as <a href="">dislocated</a> (see the examples there). As such, the analysis will be the same as when a noun phrase doubles another noun phrase or a regular pronoun that fills a nominal argument position. However, other languages, such as Greek and Bulgarian, standardly allow doubling of a lexical nominal and a pronominal clitic, with the former still appearing in its regular role as an argument of the predicate. In these cases, if only one of the lexical nominal and the clitic appear in a clause, then whichever appears will be given the grammatical role of <a href="">u-dep/obj</a>, <a href="">u-dep/iobj</a>, etc. – parallel to the treatment of lexical nominals and pronouns in other languages, modulo the clitic pronoun having a different position in the sentence.  However, if both occur, the lexical nominal will be given the grammatical role of <a href="">u-dep/obj</a>, <a href="">u-dep/iobj</a>, etc., and the clitic will be treated as a pronominal copy, which does not receive its own semantic role, and hence will get the role <a href="">u-dep/expl</a>. Modulo the different word order, this is fairly parallel to the treatment of <em>it</em> and <em>there</em> in English mentioned above, where another phrase satisfies the semantic role of the predicate. Examples from Greek and Bulgarian follow:</p>

<pre><code class="language-sdparse">Της τον έδωσε της Καίτης τον αναπτήρα \n PRON.Fem.Gen PRON.Masc.Acc gave ART.Fem.Gen Keti.Gen ART.Masc.Acc lighter.Acc
expl(έδωσε, Της-1)
iobj(έδωσε, Καίτης)
det(Καίτης, της-4)
expl(έδωσε, τον-2)
obj(έδωσε, αναπτήρα)
det(αναπτήρα, τον-6)
</code></pre>

<pre><code class="language-sdparse">Marija mu izprati pismo na rabotnika \n Maria 3.S.M.IO sent letter to the.worker
expl(izprati, mu)
obj(izprati, pismo)
iobj(izprati, rabotnika)
case(rabotnika, na)
</code></pre>

<p>The expletive relation is also used for reflexive pronouns (see the feature <a href="">u-feat/Reflex</a>)
attached to inherently reflexive verbs, i.e. verbs that cannot occur without the reflexive
pronoun and thus the pronoun does not play the role of a normal object
(otherwise it would be possible to substitute it with an irreflexive pronoun or other nominal).
A Czech example:</p>

<pre><code class="language-sdparse">Martin se bojí zvířat . \n Martin REFLEX fears animals .
expl(bojí, se)
expl(fears, REFLEX)
</code></pre>

<p>Further general discussion of expletives can be found in Postal, P. M., and G. K. Pullum (1988) “Expletive Noun Phrases in Subcategorized Positions,” <em>Linguistic Inquiry</em> 19(4): 635–670. The status of clitic doubling, and arguments for the lexical nominal being an argument with the clitic a kind of pronominal copy, appear inter alia in Boris Harizanov (2014) <a href="http://stanford.edu/~bharizan/pdfs/Harizanov_2014_NLLT.pdf">Clitic doubling at the syntax-morphology interface: A-movement and morphological merger in Bulgarian</a>. <em>Natural Language and Linguistic Theory</em>.</p>

<h3 id="dislocated">Dislocated</h3>

<p>The <a href="">u-dep/dislocated</a> relation is used for fronted or postposed elements
that do not fulfill the usual core grammatical relations of a
sentence. These elements often appear to be in the periphery of the sentence, and may be separated off with a comma intonation.</p>

<p>It is used for fronted elements that introduce the topic of a sentence, as in the following Japanese and Greek examples. The dislocated element attaches to the head of the clause to which it belongs:</p>

<pre><code class="language-sdparse">象 は 鼻 が 長い \n zoo wa hana ga naga-i \n elephant TOPIC nose SUBJ long-PRES
dislocated(長い-5, 象-1)
</code></pre>

<pre><code class="language-sdparse">to jani ton kserume poli kala \n the John-Acc him know-1pl very well 
dislocated(kserume, jani)
</code></pre>

<p>However, it would not be used for a topic-marked noun that is also the subject of the sentence; this would be an <a href="">nsubj</a>.</p>

<p>It is also used for postposed elements. The dislocated elements attach to the same governor as the dependent that they double for. Right dislocated elements are frequent in spoken languages. French and Greek examples follow.</p>

<pre><code class="language-sdparse">Il faut pas la manger , la plasticine \n It must not it eat , the playdough
obj(manger, la-4)
dislocated(manger, plasticine)
obj(eat, it-13)
dislocated(eat, playdough)
</code></pre>

<pre><code class="language-sdparse">ton kserume oli mas edho poli kala, to jani 
dislocated(kserume, jani)
</code></pre>

<h3 id="vocatives">Vocatives</h3>

<p>The <a href="">u-dep/vocative</a> relation is used to mark a dialogue participant addressed in a text (common in conversations, dialogue, emails, newsgroup postings, etc.). The relation links the addressee’s name to its host sentence. A vocative commonly co-occurs with a null subject, as in the first example below. If the nominal is clearly vocative in intent, the preference is to use the <a href="">u-dep/vocative</a> relation.</p>

<pre><code class="language-sdparse">Guys , take it easy!
vocative(take, Guys)
</code></pre>

<pre><code class="language-sdparse">Marie , comment vas - tu ?
vocative(vas, Marie)
</code></pre>

<h2 id="function-word-dependents">Function Word Dependents</h2>

<p>In addition to core and non-core dependents, the predicate of a clause may be modified by function words:</p>

<ol>
  <li>An <code>aux</code> modifies a verbal predicate by adding information relating to tense, aspect, mood, voice, or evidentiality.</li>
  <li>A <code>cop</code> links a nonverbal predicate to its subject and may add information relating to tense, aspect, mood, voice, or evidentiality.</li>
  <li>A <code>mark</code> indicates that the predicate heads a (specific type of) subordinate clause.</li>
</ol>

<pre><code class="language-sdparse">she has left
nsubj(left, she)
aux(left, has)
</code></pre>
<pre><code class="language-sdparse">she is happy
nsubj(happy, she)
cop(happy, is)
</code></pre>
<pre><code class="language-sdparse">she has been happy
nsubj(happy, she)
cop(happy, been)
aux(happy, has)
</code></pre>
<pre><code class="language-sdparse">( she knows ) that it is raining
ccomp(knows, raining)
mark(raining, that)
</code></pre>
<pre><code class="language-sdparse">( she left ) because it was raining
advcl(left, raining)
mark(raining, because)
</code></pre>



      </div>

<!-- support for embedded visualizations -->
<script type="text/javascript">
    var root = '../../'; // filled in by jekyll
    head.js(
        // External libraries
        root + 'lib/ext/jquery.min.js',
        root + 'lib/ext/jquery.svg.min.js',
        root + 'lib/ext/jquery.svgdom.min.js',
        root + 'lib/ext/jquery.timeago.js',
        root + 'lib/ext/jquery-ui.min.js',
        root + 'lib/ext/waypoints.min.js',
        root + 'lib/ext/jquery.address.min.js',

        // brat helper modules
        root + 'lib/brat/configuration.js',
        root + 'lib/brat/util.js',
        root + 'lib/brat/annotation_log.js',
        root + 'lib/ext/webfont.js',
        // brat modules
        root + 'lib/brat/dispatcher.js',
        root + 'lib/brat/url_monitor.js',
        root + 'lib/brat/visualizer.js',

        // embedding configuration
        root + 'lib/local/config.js',
        // project-specific collection data
        root + 'lib/local/collections.js',

        // NOTE: non-local libraries
        'https://spyysalo.github.io/annodoc/lib/local/annodoc.js',
        'https://spyysalo.github.io/conllu.js/conllu.js'
    );

    var webFontURLs = [
//        root + 'static/fonts/Astloch-Bold.ttf',
        root + 'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        root + 'static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var setupAccordions = function() {
	// preserve state in URL hash, following in part
	// http://www.boduch.ca/2011/05/remembering-jquery-ui-accordion.html

        // Make subaccordions first, make them active to get height, and then close later
        $(".jquery-ui-subaccordion-closed").accordion({collapsible: true, disabled:false, active:0});

	var accordionChange = function(event, ui) {
	    var context = ui.newHeader ? ui.newHeader.context : null;
	    if (context) {
		var languageCode = context.getAttribute('data-lc');
		if (languageCode !== null) {
		    window.location.hash = languageCode;
		}
	    }
	}
        // jQuery UI "accordion" element initialization
	$(".jquery-ui-accordion").accordion({
	    collapsible: true,
	    active: false,
	    change: accordionChange
	});
	if ($(".jquery-ui-accordion").length) {
	    var matches = window.location.hash.match(/^\#(.*)$/);
	    console.log(matches);
	    if (matches !== null) {
		var languageCode = matches[1];
		var tab = $('[data-lc="'+languageCode+'"]');
		// the following will only work after accordion is initialized
		var index = $('.jquery-ui-accordion div.ui-accordion-header').index(tab);
		if (index !== -1) {
		    $(".jquery-ui-accordion").accordion({ active: index });
		}
	    }
	}
        //now reclose these accordions
        $(".jquery-ui-subaccordion-closed").accordion("option","active",false);
    };

    var setupTimeago = function() {
        jQuery("time.timeago").timeago();
    };

    var setupTabs = function() {
        // standard jQuery UI "tabs" element initialization
        $(".jquery-ui-tabs").tabs({ heightStyle: "auto" });

        // use jQuery address to preserve tab state
        // (see https://github.com/UniversalDependencies/docs/issues/65,
        // http://stackoverflow.com/a/3330919)
        if ($(".jquery-ui-tabs").length > 0) {
            $.address.change(function(event){
	        $(".jquery-ui-tabs").tabs("select", window.location.hash)
	    });
	    $(".jquery-ui-tabs").bind("tabsselect", function(event, ui) { 
	        window.location.hash = ui.tab.hash;
	    });
        }
    };

    head.ready(function() {
        // set up UI tabs on page
        setupTabs();
        setupAccordions();
        setupTimeago();

        // mark current collection (filled in by Jekyll)
        Collections.listing['_current'] = 'u-overview';

	// perform all embedding and support functions
	Annodoc.activate(Config.bratCollData, Collections.listing);
    });
</script>


<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55233688-1', 'auto');
  ga('send', 'pageview');

</script>


      <div id="footer">
	  <p class="footer-text">&copy; 2014 
	    <a href="http://universaldependencies.org/introduction.html#contributors" style="color:gray">Universal Dependencies contributors</a>. 
	    Site powered by <a href="http://spyysalo.github.io/annodoc" style="color:gray">Annodoc</a> and <a href="http://brat.nlplab.org/" style="color:gray">brat</a></p>.
      </div>
    </div>
  </body>
</html>
