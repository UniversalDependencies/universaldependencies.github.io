#!/usr/bin/env perl
# Generates index to Universal Features from possibly all alternative names of features and their
# values (listed directly in the source code below). The output must be manually pasted to the
# appropriate place in the file ../_includes/u-feat-table.html.
# Copyright Â© 2016-2023 Dan Zeman <zeman@ufal.mff.cuni.cz>
# License: GNU GPL

use utf8;
use open ':utf8';
binmode(STDIN, ':utf8');
binmode(STDOUT, ':utf8');
binmode(STDERR, ':utf8');

sub usage
{
    print STDERR ("cd docs/gen_index\n");
    print STDERR ("perl ./generate_feature_index.pl > feature_index.html\n");
    print STDERR ("\# Launch an editor, open ../_includes/u-feat-table.html, locate the line saying <!-- The index was generated... -->, replace the text from that line to the line before the next </td> with the contents of feature_index.html.\n");
}

my $source = <<EOF
Abbr: abbreviation
Animacy: animate, inanimate, human, non-human
Aspect: aspect, imperfective aspect, perfective aspect, prospective, progressive, habitual, iterative, frequentative
Case: case, nominative, direct case, accusative, oblique case, absolutive, ergative, dative, genitive, vocative, locative, instrumental, instructive, partitive, distributive case, essive, prolative, translative, factive, comitative, associative, abessive, caritive, privative, inessive, illative, inlative, elative, inelative, additive, adessive, allative, adlative, ablative, adelative, superessive, superlative case, delative, superelative, subessive, sublative, subelative, lative, directional allative, perlative, temporal, terminative, terminal allative, causative case, motivative, purposive case, benefactive, destinative, considerative, comparative case, equative case
Clusivity: clusivity, inclusive, exclusive
Definite: definiteness, indefinite, non-specific indefinite, specific indefinite, definite, construct state, reduced definiteness, complex definiteness
Degree: degree of comparison, positive degree, equative degree, comparative degree, superlative degree, absolute superlative, diminutive, augmentative
Deixis: deixis, proximate, medial, distal, remote, not visible, above, even, below
DeixisRef: deixis reference person
Evident: evidentiality, firsthand, non-firsthand, narrative
Foreign: foreign word
Gender: gender, masculine, feminine, neuter, uter, common gender
Mood: mood, modality, indicative, imperative, injunctive, interrogative mood, conditional, potential, subjunctive, conjunctive, jussive, purposive mood, quotative, optative, desiderative, necessitative, realis, irrealis, admirative
NounClass: noun class, bantu noun class
Number: number, singular, plural, dual, trial, paucal, greater paucal, greater plural, inverse number, count plural, counting form, quantitative plural, plurale tantum, collective noun, mass noun, singulare tantum
NumType: numeral type, quantifier, cardinal, ordinal, multiplicative numeral, fraction, set numeral, collective numeral, distributive numeral, range numeral
Person: person, first person, second person, third person, fourth person, zero person
Polarity: polarity, affirmative, positive polarity, negative polarity
Polite: politeness, register, informal, formal, elevated referent, humbled speaker
Poss: possessive
PronType: pronominal type, personal, reciprocal pronominal, article, interrogative pronominal, relative, demonstrative, total, collective pronominal, negative pronominal, indefinite pronominal, emphatic, exclamative
Reflex: reflexive
Tense: tense, past, preterite, aorist, non-past, present, future, imperfect tense, pluperfect, past perfect
Typo: typo
VerbForm: verb form, finite verb, non-finite verb, infinitive, supine, participle, verbal adjective, converb, transgressive, adverbial participle, verbal adverb, gerundive, gerund, verbal noun, masdar
Voice: voice, active, actor-focus voice, middle voice, passive, patient-focus voice, antipassive, location-focus voice, beneficiary-focus voice, direct voice, inverse voice, reciprocal voice, causative voice
EOF
;

my @source = split(/\n/, $source);
my %hash;
foreach my $line (@source)
{
    my ($feature, $keywords) = split(/\s*:\s*/, $line);
    my @keywords = split(/\s*,\s*/, $keywords);
    foreach my $keyword (@keywords)
    {
        die("Ambiguous keyword $keyword") if(exists($hash{$keyword}));
        $hash{$keyword} = $feature;
    }
}
my @keys = sort(keys(%hash));
my @index;
my $last_letter = '';
foreach my $key (@keys)
{
    my $letter = uc(substr($key, 0, 1));
    my $feature = $hash{$key};
    my $entry = "<a href=\"$feature.html\">$key</a>";
    $entry = "<strong>$letter</strong>&nbsp;".$entry if($letter ne $last_letter);
    $last_letter = $letter;
    push(@index, $entry);
}
print("<!-- The index was generated by the script gen_index/generate_feature_index.pl from the following source:\n\n$source\n-->\n\n");
print("<strong>Index: </strong>", join(', ', @index), "\n");
