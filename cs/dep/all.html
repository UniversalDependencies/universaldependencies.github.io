<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Dependencies</title>
    <link rel="root" href=""/> <!-- for JS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="../../css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style-vis.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/hint.css"/>
    <script type="text/javascript" src="../../lib/ext/head.load.min.js"></script>
    <script type="text/javascript" src="../../lib/ext/jquery.timeago.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.2.2/anchor.min.js"></script>
    <script>document.addEventListener("DOMContentLoaded", function(event) {anchors.add();});</script>
    <!-- Set up this custom Google search at https://cse.google.com/cse/business/settings?cx=001145188882102106025:dl1mehhcgbo -->
    <script>
      (function() {
        var cx = '001145188882102106025:dl1mehhcgbo';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->


  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
        <table width="100%"><tr><td width="50%">
          <span class="header-text"><a href="http://universaldependencies.org/#language-cs">home</a></span>


          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
        </td><td>
          <gcse:search></gcse:search>
        </td></tr></table>
      </div>

      <hr/>

      
      <div class="v2complete">
	This page pertains to UD version 2.
      </div>
      
      
      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          <h1 id="dependencies">Dependencies</h1>

<p>Note: <i>punct</i> appears in two places.</p>

<table class="typeindex">
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	</tr>
	<tr>
	  <td><a>nsubj</a></td>
	  <td><a>csubj</a></td>
	</tr>
	<tr>
	  <td>↳<a>nsubj:pass</a></td>
	  <td>↳<a>csubj:pass</a></td>
	</tr>
	<tr>
	  <td><a>obj</a></td>
	  <td><a>ccomp</a></td>
	  <td><a>xcomp</a></td>
	</tr>
	<tr>
	  <td><a>iobj</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Non-core dependents of clausal predicates</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a>obl</a></td>
	  <td><a>advcl</a></td>
	  <td><a>advmod</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Special clausal dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Auxiliary</i></td>
	  <td><i>Other</i></td>
	</tr>
	<tr>
	  <td><tt>expl</tt></td>
	  <td><a>aux</a></td>
	  <td><a>mark</a></td>
	</tr>
	<tr>
	  <td>↳<a>expl:pass</a></td>
	  <td>↳<a>aux:pass</a></td>
	  <td><a>punct</a></td>
	</tr>
	<tr>
	  <td>↳<a>expl:pv</a></td>
	  <td><a>cop</a></td>
	</tr>
	<tr>
	  <td><a>vocative</a></td>
	</tr>
	<tr>
	  <td><a>discourse</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Noun dependents</strong></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a>nmod</a></td>
	  <td><a>acl</a></td>
	  <td><a>amod</a></td>
	</tr>
	<tr>
	  <td><a>appos</a></td>
	  <td>&nbsp;</td>
	  <td>↳<a>advmod:emph</a></td>
	</tr>
	<tr>
	  <td><strike>clf</strike></td>
	  <td>&nbsp;</td>
	  <td><a>det</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td>↳<a>det:numgov</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td>↳<a>det:nummod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td><a>nummod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td>&nbsp;</td>
	  <td>↳<a>nummod:gov</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Compounding and unanalyzed</strong></td></tr>
	<tr>
	  <td><a>compound</a></td>
	  <td><a>fixed</a></td>
	  <td><a>goeswith</a></td>
	</tr>
	<tr>
	  <td><a>flat</a></td>
	</tr>
	<tr>
	  <td>↳<a>flat:foreign</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Coordination</strong></td></tr>
	<tr>
	  <td><a>conj</a></td>
	  <td><a>cc</a></td>
	  <td><a>punct</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Case-marking and prepositions</strong></td></tr>
	<tr>
	  <td><a>case</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Loose joining relations</strong></td></tr>
	<tr>
	  <td><a>list</a></td>
	  <td><a>parataxis</a></td>
	  <td><a>orphan</a></td>
	</tr>
	<tr>
	  <td><strike>dislocated</strike></td>
	  <td></td><td><a>reparandum</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><strong>Other</strong></td></tr>
	<tr>
	  <td><i>Sentence head</i></td>
	  <td colspan="2"><i>Unspecified dependency</i></td>
	</tr>
	<tr>
	  <td><a>root</a></td>
	  <td><a>dep</a></td>
	</tr>
      </table>

    </td>
  </tr>
</table>

<hr />

<p><a id="al-cs-dep/acl" class="al-dest"></a></p>
<h2><code>acl</code>: clausal modifier of noun</h2>

<p><code>acl</code> stands for finite and non-finite clauses that modify a nominal.  The <code>acl</code> relation 
contrasts with the <a href="">advcl</a> relation, which is used for adverbial clauses
that modify a predicate. The head of the <code>acl</code> relation is the noun
that is modified, and the dependent is the head of the clause that
modifies the noun.</p>

<pre><code class="language-sdparse">muž , o kterém jsem mluvil \n man , about whom I-have talked
acl(muž, mluvil)
acl(man, talked)
</code></pre>

<p>This relation is also used for optional depictives.
The adjective is taken to modify the nominal of which it provides a secondary predication.
See <a href="">u-dep/xcomp</a> for further discussion of resultatives and depictives.</p>

<pre><code class="language-sdparse">Alena vstoupila do místnosti smutná . \n Alena entered to room sad .
acl(Alena-1, smutná)
acl(Alena-8, sad)
</code></pre>

<pre><code class="language-sdparse">Namaloval svou ženu nahou . \n He-painted his wife naked .
acl(ženu, nahou)
acl(wife, naked)
</code></pre>

<p>Czech also allows finite clausal complements for nouns with 
a subset of nouns like <em>fact</em> or <em>report</em>.
These look roughly like relative clauses, but do not have any omitted role in the dependent clause.
These are also analyzed as <code>acl</code>.</p>

<pre><code class="language-sdparse">Příčinou není fakt , že by kina navštívilo víc diváků . \n Cause is-not the-fact , that would cinemas visit more filmgoers .
acl(fakt, navštívilo)
acl(the-fact, visit)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/acl.md" target="#">edit acl</a></p>

<p><a id="al-cs-dep/advcl" class="al-dest"></a></p>
<h2><code>advcl</code>: adverbial clause modifier</h2>

<p>An adverbial clause modifier is a clause which modifies a verb or other predicate (adjective, etc.),
as a modifier not as a core complement. This includes things such as a temporal clause, consequence, conditional clause, purpose
clause, etc. The dependent must be clausal (or else it is an <a href="">advmod</a>) and the dependent is the main predicate of the clause.</p>

<pre><code class="language-sdparse">K nehodě došlo , když přicházela noc . \n To accident it-came , when was-falling night .
advcl(došlo, přicházela)
advcl(it-came, was-falling)
</code></pre>

<pre><code class="language-sdparse">Jestliže víš , kdo to udělal , měl bys to říct učiteli . \n If you-know , who it did , should you it tell teacher .
advcl(měl, víš)
advcl(should, you-know)
</code></pre>

<pre><code class="language-sdparse">Spěchal , aby přišel včas . \n He-rushed , in-order-to come in-time .
advcl(Spěchal, přišel)
advcl(He-rushed, come)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/advcl.md" target="#">edit advcl</a></p>

<p><a id="al-cs-dep/advmod" class="al-dest"></a></p>
<h2><code>advmod</code>: adverbial modifier</h2>

<p>An adverbial modifier of a word is a (non-clausal) <a href="cs-pos/ADV">adverb</a>
or adverbial phrase that serves to modify the meaning of the word.</p>

<p>Note that in the Czech grammatical tradition, the term <em>adverbial modifier</em> covers
constituents that function like adverbs regardless whether they are realized
by adverbs, adpositional phrases, or nouns in particular morphological 
<a href="cs-feat/Case">cases</a>.
We differentiate adverbials realized as adverbs (<code>advmod</code>) and
adverbials realized by noun phrases or adpositional phrases
(<a href="">obl</a>).</p>

<pre><code class="language-sdparse">geneticky upravené potraviny \n genetically modified food
advmod(upravené, geneticky)
advmod(modified, genetically)
</code></pre>

<pre><code class="language-sdparse">méně často \n less often
advmod(často, méně)
advmod(often, less)
</code></pre>

<pre><code class="language-sdparse">Kam/ADV chcete/VERB jít/VERB zítra/ADV ?/PUNCT \n Where do-you-want to-go tomorrow ?
advmod(jít, Kam)
advmod(jít, zítra)
advmod(to-go, Where)
advmod(to-go, tomorrow)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/advmod.md" target="#">edit advmod</a></p>

<p><a id="al-cs-dep/advmod:emph" class="al-dest"></a></p>
<h2><code>advmod:emph</code>: emphasizing word, intensifier</h2>

<p>This is a special class of <a href="advmod">adverbial modifiers</a>.
It corresponds to the words that are attached in the analytical layer of PDT with the label <code>AuxZ</code>.
In the tectogrammatical layer they often get the label (functor) <code>RHEM</code> (rhematizers).</p>

<p>While other adverbial modifiers usually modify verbs, adjectives or adverbs, these emphasizers often modify noun phrases,
including prepositional phrases.</p>

<pre><code class="language-sdparse">zvlášť v pondělí \n especially on Monday
advmod:emph(pondělí, zvlášť)
advmod:emph(Monday, especially)
</code></pre>

<pre><code class="language-sdparse">jen 15 procent \n only 15 percent
advmod:emph(procent, jen)
advmod:emph(percent, only)
</code></pre>

<p>Other examples:</p>

<ul>
  <li><em>Mohli by obvinit <b>i</b> některého ministra.</em> “They could prosecute <b>also/even</b> a minister.”</li>
  <li><em>Začnou <b>až</b> o měsíc později.</em> lit. <em>They-will-start <b>even</b> by month later.</em> “They will start one month later.” (<em>Až</em> expresses that the speaker or the listener did not expect the thing to happen <b>that</b> late.)</li>
  <li><em><b>Ani</b> vojáci o to nemají zájem.</em> “<b>Not even</b> soldiers are interested in it.”</li>
  <li><em>Hraje <b>už</b> v sobotu.</em> “He will play <b>already</b> on Saturday.”</li>
  <li><em>Chceme se sejít <b>ještě</b> tento týden.</em> lit. <em>We-want to meet <b>still</b> this week.</em> “We want to meet before this week ends.”</li>
  <li><em>u <b>asi</b> 20 titulů</em> “by <b>around/approximately</b> 20 items”</li>
  <li><em>Dá se to dokumentovat <b>právě</b> na početné skupině dětí.</em> “It can be shown <b>just</b> on a large group of children.”</li>
</ul>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/advmod-emph.md" target="#">edit advmod:emph</a></p>

<p><a id="al-cs-dep/amod" class="al-dest"></a></p>
<h2><code>amod</code>: adjectival modifier</h2>

<p>An adjectival modifier of a noun is any adjectival phrase that serves
to modify the meaning of the noun.</p>

<p>Exception: if the modifying adjectival word is pronominal (i.e. tagged <a href="">cs-pos/DET</a>),
the relation is <a href="">det</a> instead of <code>amod</code>.</p>

<pre><code class="language-sdparse">Václav jí vepřové maso . \n Václav eats pork meat .
amod(maso, vepřové)
amod(meat, pork)
</code></pre>

<pre><code class="language-sdparse">Václav si vzal třímiliónovou půjčku . \n Václav himself took-out three-million loan .
amod(půjčku, třímiliónovou)
amod(loan, three-million)
</code></pre>

<pre><code class="language-sdparse">První závodník byl rychlý . \n First racer was fast .
amod(závodník, První)
amod(racer, First)
nsubj(rychlý, závodník)
nsubj(fast, racer)
</code></pre>

<pre><code class="language-sdparse">Rychlý závodník byl první . \n Fast racer was first .
amod(závodník, Rychlý)
amod(racer, Fast)
nsubj(první, závodník)
nsubj(first, racer)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/amod.md" target="#">edit amod</a></p>

<p><a id="al-cs-dep/appos" class="al-dest"></a></p>
<h2><code>appos</code>: appositional modifier</h2>

<p>An appositional modifier of a noun is a nominal immediately following
the first noun that serves to define or modify that noun. It includes
parenthesized examples, as well as defining abbreviations in one of
these structures.</p>

<pre><code class="language-sdparse">Karel IV . , římský císař a český král , vládl ve 14 . století . \n Charles IV . , Roman Emperor and Czech king , ruled in 14 th century .
appos(Karel, císař)
appos(Charles, Emperor)
conj(císař, král)
conj(Emperor, king)
</code></pre>

<pre><code class="language-sdparse">Občanská demokratická strana ( ODS ) \n Civic Democratic Party ( ODS )
appos(strana, ODS-5)
appos(Party, ODS-12)
</code></pre>

<p>There is a slight deviation from the <a href="u-dep/appos">universal</a> standard in case of more than one appositive nominal.
Instead of attaching them all to the first noun, all the appositive modifiers are put together in coordination,
then attached as <code>appos</code> to the modified noun.
This is done regardless whether the appositives are joined by a coordinating conjunction or just a comma.</p>

<pre><code class="language-sdparse">Přijel Michal , můj bratr a Davidův bratranec . \n Came Michal , my brother and David's cousin .
appos(Michal-2, bratr)
appos(Michal-12, brother)
conj(bratr, bratranec)
conj(brother, cousin)
</code></pre>

<pre><code class="language-sdparse">Michal , můj bratr , Davidův bratranec , přijede zítra . \n Michal , my brother , David's cousin , will-come tomorrow .
appos(Michal-1, bratr)
appos(Michal-13, brother)
conj(bratr, bratranec)
conj(brother, cousin)
</code></pre>

<p><code>appos</code> is also used to link key-value pairs in addresses, signatures, etc. (see also the <a href="">list</a> label):</p>

<pre><code class="language-sdparse">Jan Novák , tel . : 777-000-111 , e-mail : novak@ab.cz
flat(Jan, Novák)
list(Jan, tel)
list(Jan, e-mail)
appos(tel, 777-000-111)
appos(e-mail, novak@ab.cz)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/appos.md" target="#">edit appos</a></p>

<p><a id="al-cs-dep/aux" class="al-dest"></a></p>
<h2><code>aux</code>: auxiliary</h2>

<p>An auxiliary of a clause is a form of the <a href="cs-pos/AUX">auxiliary verb</a> <em>být</em> “to be”
used to construct the periphrastic future tense, past tense or conditional.</p>

<p>Exception: Auxiliary verb used to construct the passive
<a href="cs-feat/Voice">voice</a> is not labeled <code>aux</code> but <a href="">aux:pass</a>.</p>

<p>Note that besides <code>aux</code> and <code>aux:pass</code>, the verb <em>být</em> may also act as a <a href="cop">copula</a>
and as the main verb.</p>

<pre><code class="language-sdparse">Přijel jsem včera . \n Arrived I-have yesterday .
aux(Přijel, jsem)
aux(Arrived, I-have)
</code></pre>

<pre><code class="language-sdparse">Zítra budu přednášet na univerzitě . \n Tomorrow I-will give-a-talk at university .
aux(přednášet, budu)
aux(give-a-talk, I-will)
</code></pre>

<pre><code class="language-sdparse">Přišel bych dříve , ale ujel mi vlak . \n Come I-would earlier , but missed my train .
aux(Přišel, bych)
aux(Come, I-would)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/aux_.md" target="#">edit aux</a></p>

<p><a id="al-cs-dep/aux:pass" class="al-dest"></a></p>
<h2><code>aux:pass</code>: passive auxiliary</h2>

<p>A passive auxiliary of a clause is a form of the <a href="cs-pos/AUX">auxiliary verb</a> <em>být</em> “to be”
used to construct the periphrastic passive voice (in any tense or in the infinitive).</p>

<pre><code class="language-sdparse">Kennedy byl zabit . \n Kennedy was killed .
aux:pass(zabit, byl)
aux:pass(killed, was)
</code></pre>

<pre><code class="language-sdparse">Kennedy bude zabit . \n Kennedy will-be killed .
aux:pass(zabit, bude)
aux:pass(killed, will-be)
</code></pre>

<pre><code class="language-sdparse">Kennedy netušil , že jeho osudem je být zabit . \n Kennedy did-not-anticipate that his fate is to-be killed .
aux:pass(zabit, být)
aux:pass(killed, to-be)
</code></pre>

<p>Note that the passive participle may be also used as nominal predicate with <a href="cop">copula</a>.
Hence it may be difficult to distinguish a passive construction from a copula construction.
The former focuses on the process while the latter emphasizes the result.</p>

<ul>
  <li>Passive:</li>
</ul>

<pre><code class="language-sdparse">Smlouva byla podepsána v Bílém domě . \n Contract was signed in White House .
aux:pass(podepsána, byla)
aux:pass(signed, was)
</code></pre>

<ul>
  <li>Copula:</li>
</ul>

<pre><code class="language-sdparse">Smlouva byla podepsána červeným inkoustem . \n Contract was signed in-red ink .
cop(podepsána, byla)
cop(signed, was)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/aux-pass.md" target="#">edit aux:pass</a></p>

<p><a id="al-cs-dep/case" class="al-dest"></a></p>
<h2><code>case</code>: case marking</h2>

<p>Czech uses a combination of oblique morphological cases and prepositions to express semantic case.
Unlike in the original annotation of the Prague Dependency Treebank, prepositions in UD are treated as dependents
of the noun they attach to. The relation between the noun and the preposition is labeled <code>case</code>.</p>

<pre><code class="language-sdparse">V pátek.Acc jsme si cestou.Ins do Francie.Gen povídali o té události.Loc . \n On Friday we-have ourselves during-the-journey to France talked about the event .
case(pátek.Acc, V)
case(Friday, On)
case(Francie.Gen, do)
case(France, to)
case(události.Loc, o)
case(event, about)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/case.md" target="#">edit case</a></p>

<p><a id="al-cs-dep/cc" class="al-dest"></a></p>
<h2><code>cc</code>: coordinating conjunction</h2>

<p>For more on coordination, see the <a href="">conj</a> relation.
A <code>cc</code> is the relation between a conjunct and
the <a href="cs-pos/CCONJ">coordinating conjunction</a> that precedes it.
(Note: different dependency grammars have different treatments of coordination.
We take the first conjunct as the head of the coordination.)</p>

<pre><code class="language-sdparse">Je to starý a moudrý muž . \n Is he old and wise man .
cc(moudrý, a)
cc(wise, and)
</code></pre>

<p>A coordinating conjunction may also appear at the beginning of a
sentence. This is also called a <code>cc</code>, and it depends on the root
predicate of the sentence.
(In fact there is a coordination that spans multiple sentences.)</p>

<pre><code class="language-sdparse">A pak jsme odešli . \n And then we-have left .
cc(odešli, A)
cc(left, And)
</code></pre>

<pre><code class="language-sdparse">Máme jablka , hrušky , pomeranče a banány . \n We-have apples , pears , oranges and bananas .
obj(Máme, jablka)
obj(We-have, apples)
conj(jablka, hrušky)
conj(jablka, pomeranče)
conj(jablka, banány)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(banány, a)
cc(bananas, and)
punct(hrušky, ,-3)
punct(pomeranče, ,-5)
punct(pears, ,-13)
punct(oranges, ,-15)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/cc.md" target="#">edit cc</a></p>

<p><a id="al-cs-dep/ccomp" class="al-dest"></a></p>
<h2><code>ccomp</code>: clausal complement</h2>

<p>A clausal complement of a verb or adjective is a dependent clause 
which is a core argument. That is, it functions like an object of the verb, or
adjective.</p>

<pre><code class="language-sdparse">Říká , že ráda plaveš . \n He-says , that like-to you-swim .
ccomp(Říká, plaveš)
ccomp(He-says, you-swim)
</code></pre>

<p>Such clausal complements may be finite or nonfinite. However, if the
subject of the clausal complement is controlled (that is, must be the same
as the higher subject or object, with no other possible interpretation)
the appropriate relation is <a href="">xcomp</a>.</p>

<pre><code class="language-sdparse">Šéf nám nařídil vykopat příkop . \n Boss us ordered to-dig ditch .
ccomp(nařídil, vykopat)
ccomp(ordered, to-dig)
</code></pre>

<pre><code class="language-sdparse">Začali jsme kopat příkop . \n Started we-have to-dig ditch .
xcomp(Začali, kopat)
xcomp(Started, to-dig)
</code></pre>

<p>The key difference here is that, while it is possible to interpret the first
sentence to mean that the boss will not be doing any digging, in the second
sentence it is clear that the subject of <strong>digging</strong> can only be <strong>we</strong>. This is
what distinguishes <code>ccomp</code> and <code>xcomp</code>.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/ccomp.md" target="#">edit ccomp</a></p>

<p><a id="al-cs-dep/compound" class="al-dest"></a></p>
<h2><code>compound</code>: compound</h2>

<p><code>compound</code> is one of the relations in UD for compounding.
In Czech it is used only for compound numbers.
The rightmost numeral is the head, the other numerals are attached as its modifiers.</p>

<pre><code class="language-sdparse">Bude to stát nanejvýš 50 tisíc korun . \n Will it cost at-most 50 thousand crowns .
nummod:gov(korun, tisíc)
nummod:gov(crowns, thousand)
compound(tisíc, 50-5)
compound(thousand, 50-14)
</code></pre>

<pre><code class="language-sdparse">Bude to stát padesát pět tisíc korun . \n Will it cost fifty five thousand crowns .
nummod:gov(korun, tisíc)
nummod:gov(crowns, thousand)
compound(tisíc, padesát)
compound(thousand, fifty)
compound(tisíc, pět)
compound(thousand, five)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/compound.md" target="#">edit compound</a></p>

<p><a id="al-cs-dep/conj" class="al-dest"></a></p>
<h2><code>conj</code>: conjunct</h2>

<p>A conjunct is the relation between two elements connected by a
coordinating conjunction, such as <em>and, or,</em> or a comma or other punctuation.
We treat coordination asymmetrically.
The head of the relation is the first
conjunct and all the other conjuncts depend on it via the <code>conj</code> relation.</p>

<pre><code class="language-sdparse">Je to starý a moudrý muž . \n Is he old and wise man .
conj(starý, moudrý)
conj(old, wise)
</code></pre>

<pre><code class="language-sdparse">Máme jablka , hrušky , pomeranče a banány . \n We-have apples , pears , oranges and bananas .
obj(Máme, jablka)
obj(We-have, apples)
conj(jablka, hrušky)
conj(jablka, pomeranče)
conj(jablka, banány)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(banány, a)
cc(bananas, and)
punct(hrušky, ,-3)
punct(pomeranče, ,-5)
punct(pears, ,-13)
punct(oranges, ,-15)
</code></pre>

<p>Coordinate clauses are treated the same way as coordination of other constituent types:</p>

<pre><code class="language-sdparse">Přišel domů , osprchoval se a hned šel do postele . \n He-came home , showered himself and immediately went to bed .
conj(Přišel, osprchoval)
conj(Přišel, šel)
conj(He-came, showered)
conj(He-came, went)
punct(osprchoval, ,-3)
punct(showered, ,-15)
cc(šel, a)
cc(went, and)
</code></pre>

<p>See <a href="u-dep/conj">universal/conj</a> for more details on various coordination-related issues.
Note that the present conversion procedure loses some annotations of shared modifiers and nested
coordination.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/conj.md" target="#">edit conj</a></p>

<p><a id="al-cs-dep/cop" class="al-dest"></a></p>
<h2><code>cop</code>: copula</h2>

<p>A copula is the relation between the nominal predicate <em>(přísudek jmenný)</em> and
the copular verb <em><b>být</b></em> “to be” (or its variants <em>bývat, bývávat</em>).
The verb <em>stát se</em> “to become”, despite being counted among copular verbs by some authors,
is not analyzed as <code>cop</code>.</p>

<p>We normally take a copula as a dependent of its complement (the nominal predicate).
The nominal predicate is usually a <a href="cs-pos/NOUN">noun</a>, an <a href="cs-pos/ADJ">adjective</a>
or a <a href="../feat/VerbForm.html#part-participle">participle</a>.</p>

<pre><code class="language-sdparse">Ondřej je čestný muž . \n Ondřej is honest man .
cop(muž, je)
cop(man, is)
</code></pre>

<pre><code class="language-sdparse">Ondřej je čestný . \n Ondřej is honest .
cop(čestný, je)
cop(honest, is)
</code></pre>

<p>Note that the passive participle may be also used as nominal predicate with copula.
Hence it may be difficult to distinguish a passive construction from a copula construction.
The former focuses on the process while the latter emphasizes the result.</p>

<ul>
  <li>Passive: <em>Smlouva <b>byla</b>.<code>AUX</code> podepsána v Bílém domě.</em>   “The contract was signed in the White House.”</li>
  <li>Copula: <em>Smlouva <b>byla</b>.<code>VERB</code> podepsána červeným inkoustem.</em>   “The contract was signed in red ink.”</li>
</ul>

<pre><code class="language-sdparse">Smlouva byla podepsána v Bílém domě . \n Contract was signed in White House .
aux:pass(podepsána, byla)
aux:pass(signed, was)
</code></pre>

<pre><code class="language-sdparse">Smlouva byla podepsána červeným inkoustem . \n Contract was signed in-red ink .
cop(podepsána, byla)
cop(signed, was)
</code></pre>

<p>The nominal predicate may also be expressed using a prepositional phrase.
Phrases expressing the state of the subject are clear predicates, e.g. <em>Lenka je v kondici</em> “Lenka is in shape”.
Under the v2 guidelines, prepositional phrases expressing locations are also considered predicates, to increase parallelism across languages.</p>

<p>Thus the following sentences receive parallel analyses:</p>

<ul>
  <li><em>Lenka je skvělá.</em> “Lenka is brilliant.”</li>
  <li><em>Lenka je v kondici.</em> “Lenka is in shape.”</li>
  <li><em>Lenka je v kuchyni.</em> “Lenka is in the kitchen.”</li>
</ul>

<p>In contrast, the following two are no longer parallel:</p>

<ul>
  <li><em>Lenka je v kuchyni.</em> “Lenka is in the kitchen.”</li>
  <li><em>Lenka zůstala v kuchyni.</em> “Lenka stayed in the kitchen.”</li>
</ul>

<pre><code class="language-sdparse">Lenka je v kondici . \n Lenka is in shape .
cop(kondici, je)
cop(shape, is)
case(kondici, v)
case(shape, in)
nsubj(kondici, Lenka-1)
nsubj(shape, Lenka-7)
</code></pre>

<pre><code class="language-sdparse">Lenka je v kuchyni . \n Lenka is in kitchen .
nsubj(kuchyni, Lenka-1)
nsubj(kitchen, Lenka-7)
cop(kuchyni, je)
cop(kitchen, is)
case(kuchyni, v)
case(kitchen, in)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/cop.md" target="#">edit cop</a></p>

<p><a id="al-cs-dep/csubj" class="al-dest"></a></p>
<h2><code>csubj</code>: clausal subject</h2>

<p>A clausal subject is a clausal syntactic subject of a clause, i.e.,
the subject is itself a clause. The governor of this relation might
not always be a verb: when the verb is a copular verb, the root of the
clause is the complement of the copular verb. The dependent is the main lexical verb or other 
predicate of the subject clause.</p>

<pre><code class="language-sdparse">Obžalovanému přitížilo , že neměl alibi . \n To-indictee did-a-disservice , that he-did-not-have alibi .
csubj(přitížilo, neměl)
csubj(did-a-disservice, he-did-not-have)
</code></pre>

<pre><code class="language-sdparse">Podstatou těchto vazeb je , že se děj rozloží na dvě složky . \n The-essence of-these constructions is , that one the-action splits to two parts .
csubj(Podstatou, rozloží)
cop(Podstatou, je)
csubj(The-essence, splits)
cop(The-essence, is)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/csubj.md" target="#">edit csubj</a></p>

<p><a id="al-cs-dep/csubj:pass" class="al-dest"></a></p>
<h2><code>csubj:pass</code>: clausal passive subject</h2>

<p>A clausal passive subject is a clausal syntactic subject of a passive clause.</p>

<pre><code class="language-sdparse">Bylo mi doporučeno , abych to velmi dobře zvážil . \n It-has-been to-me recommended , that-I it very well weigh .
csubj:pass(doporučeno, zvážil)
csubj:pass(recommended, weigh)
</code></pre>

<p>Reflexive passive (the meaning is “You are not expected to come before nine o’clock.”)</p>

<pre><code class="language-sdparse">Nepředpokládá se , že přijdete před devátou . \n It-does-not-expect itself , that you-will-come before nine .
csubj:pass(Nepředpokládá, přijdete)
csubj:pass(It-does-not-expect, you-will-come)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/csubj-pass.md" target="#">edit csubj:pass</a></p>

<p><a id="al-cs-dep/dep" class="al-dest"></a></p>
<h2><code>dep</code>: unspecified dependency</h2>

<p>A dependency is labeled as <code>dep</code> when a system is unable to
determine a more precise dependency relation between two words.  This
may be because of a weird grammatical construction, a limitation in
software, a parser error, or
because of an unresolved long distance dependency.</p>

<p>Most <code>dep</code> instances in the current conversion of the PDT 3.0 data
correspond to the PDT label <code>ExD</code>, which marks ellipsis.
The current conversion software cannot produce the annotation fully conforming
to the UD standard and using the <a href="">orphan</a> relation.</p>

<pre><code class="language-sdparse">K čemu ovšem , to nebylo jasné . \n For what however , that was-not clear .
dep(jasné, čemu)
dep(clear, what)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/dep.md" target="#">edit dep</a></p>

<p><a id="al-cs-dep/det" class="al-dest"></a></p>
<h2><code>det</code>: determiner</h2>

<p>The relation determiner (<code>det</code>) holds between a nominal head and its
<a href="cs-pos/DET">determiner</a>.
This relation is used for pronominal adjectival modifiers of noun phrases; the <code>det</code> modifier has the POS tag <a href="">cs-pos/DET</a> and vice versa.
Non-pronominal adjectives are tagged <a href="">cs-pos/ADJ</a> and the relation is labeled <a href="">amod</a>.</p>

<p>Pronominal quantifiers are tagged <code>DET</code> but their relation to their head is a subtype of the <code>det</code> relation:
either <a href="">cs-dep/det:numgov</a> or <a href="">cs-dep/det:nummod</a>.</p>

<pre><code class="language-sdparse">Ten člověk už je tady . \n The man already is here .
det(člověk, Ten)
det(man, The)
</code></pre>

<pre><code class="language-sdparse">Která kniha se vám líbí nejvíc ? \n Which book is to-you nice the-most ?
det(kniha, Která)
det(book, Which)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/det.md" target="#">edit det</a></p>

<p><a id="al-cs-dep/det:numgov" class="al-dest"></a></p>
<h2><code>det:numgov</code>: pronominal quantifier governing the case of the noun</h2>

<p>Pronominal quantifiers are labeled <code>det:numgov</code> instead of <a href="">det</a>
because they normally do not agree with the quantified noun in case
(unlike non-quantifying determiners).</p>

<p>The quantifier requires the counted noun to be in its genitive form.
The whole phrase (quantifier + noun) is treated as a singular neuter noun phrase
and it can fill roles where nominative, accusative or vocative noun phrases are expected.</p>

<p>Such situations are analyzed in PDT so that the quantifier (numeral) is the head and the noun depends on it.
In UD the dependency direction is reversed and the <code>det:numgov</code> label is used to preserve
the information about case conditions.</p>

<pre><code class="language-conllu"># This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1   Kolik   kolik   NUM     _   Case=Nom                           3   Sb     _   How-many
2   mužů    muž     NOUN    _   Case=Gen|Gender=Masc|Number=Plur   1   Atr    _   men
3   hrálo   hrát    VERB    _   Gender=Neut|Number=Sing            0   Pred   _   played
4   karty   karta   NOUN    _   Case=Acc|Gender=Fem|Number=Plur    3   Obj    _   cards
5   ?       ?       PUNCT   _   _                                  0   AuxK   _   ?
</code></pre>

<pre><code class="language-sdparse">Kolik mužů hrálo karty ? \n How-many men played cards ?
det:numgov(mužů, Kolik)
nsubj(hrálo, mužů)
obj(hrálo, karty)
punct(hrálo, ?-5)
det:numgov(men, How-many)
nsubj(played, men)
obj(played, cards)
punct(played, ?-11)
</code></pre>

<p>See <a href="">nummod</a> for a broader discussion of the various situations with quantifiers.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/det-numgov.md" target="#">edit det:numgov</a></p>

<p><a id="al-cs-dep/det:nummod" class="al-dest"></a></p>
<h2><code>det:nummod</code>: pronominal quantifier agreeing in case with the noun</h2>

<p>Pronominal quantifiers are labeled <code>det:nummod</code> or <a href="">det:numgov</a> instead of <a href="">det</a>
because they normally do not agree with the quantified noun in case
(unlike non-quantifying determiners).
They do agree only if the whole phrase (quantifier + noun) fills a role where
genitive, dative, locative or instrumental noun phrases are expected.
In these situations they are labeled <code>det:nummod</code>.</p>

<pre><code class="language-sdparse">Nepamatuji si , s kolika muži jsem hrál karty . \n I-do-not-remember myself , with how-many men I-have played cards .
ccomp(Nepamatuji, hrál)
expl:pv(Nepamatuji, si)
punct(hrál, ,-3)
aux(hrál, jsem)
obj(hrál, karty)
iobj(hrál, muži)
case(muži, s)
det:nummod(muži, kolika)
punct(Nepamatuji, .-10)
ccomp(I-do-not-remember, played)
expl:pv(I-do-not-remember, myself)
punct(played, ,-14)
aux(played, I-have)
obj(played, cards)
iobj(played, men)
case(men, with)
det:nummod(men, how-many)
punct(I-do-not-remember, .-21)
</code></pre>

<p>See <a href="">nummod</a> for a broader discussion of the various situations with quantifiers.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/det-nummod.md" target="#">edit det:nummod</a></p>

<p><a id="al-cs-dep/discourse" class="al-dest"></a></p>
<h2><code>discourse</code>: discourse element</h2>

<p>At present we use the <code>discourse</code> relation for what is labeled <code>AuxO</code> in the Prague Dependency Treebank:
redundant or emotional items, redundant coreferential pronoun.</p>

<pre><code class="language-sdparse">čemu že se to zpronevěřily \n what that themselves it they-betrayed
discourse(zpronevěřily, to)
discourse(they-betrayed, it)
</code></pre>
<p>(meaning “… what they betrayed”)</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/discourse.md" target="#">edit discourse</a></p>

<p><a id="al-cs-dep/expl:pass" class="al-dest"></a></p>
<h2><code>expl:pass</code>: reflexive pronoun used in reflexive passive</h2>

<p>Reflexive pronouns (see the feature <a href="">cs-feat/Reflex</a>) are used in various constructions in Czech,
including so-called <em>reflexive passive.</em>
In PDT, their relation to the verb is labeled <code>AuxR</code>.
The corresponding label in Czech UD is called <code>expl:pass</code>
(since UD 2.0; in previous versions it was labeled <code>auxpass:reflex</code>).</p>

<pre><code class="language-sdparse">To se řekne snadno . \n It is said easily .
expl:pass(řekne, se)
expl:pass(said, is)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/expl-pass.md" target="#">edit expl:pass</a></p>

<p><a id="al-cs-dep/expl:pv" class="al-dest"></a></p>
<h2><code>expl:pv</code>: reflexive clitic with an inherently reflexive verb</h2>

<p>Reflexive pronouns (see the feature <a href="">cs-feat/Reflex</a>) usually replace objects of verbs.
However, some verbs are inherently reflexive, i.e. the verb always occurs with a reflexive
prounoun, and the pronoun cannot be replaced by a non-reflexive pronoun.</p>

<p>With these verbs, the reflexive pronoun is attached as <code>expl:pv</code> instead of <a href="">obj</a>.
(Note that the <code>expl</code> relation is first used for this purpose in the UD release 1.2,
and it is further subtyped as <code>expl:pv</code> since UD 2.0,
to increase parallelism with other languages. In the previous releases this usage of
reflexive <em>se/si</em> was labeled <code>compound:reflex</code>.)</p>

<pre><code class="language-sdparse">Martin se bojí zvířat . \n Martin REFLEX fears animals .
expl:pv(bojí, se)
expl:pv(fears, REFLEX)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/expl-pv.md" target="#">edit expl:pv</a></p>

<p><a id="al-cs-dep/fixed" class="al-dest"></a></p>
<h2><code>fixed</code>: multi-word expression</h2>

<p>The <code>fixed</code> multi-word expression relation is one of the
relations for compounding and it is intended mostly for function words.
In Czech it is used for multi-word prepositions.
The leftmost word is the head and all the other words are attached as its <code>fixed</code> modifiers.</p>

<pre><code class="language-sdparse">Na rozdíl od tebe já se nemám zač stydět . \n In contrast to you I myself have-not of-what to-be-ashamed .
fixed(Na, rozdíl)
fixed(Na, od)
case(tebe, Na)
fixed(In, contrast)
fixed(In, to)
case(you, In)
</code></pre>

<p>Multi-word prepositions usually form a contiguous span of the sentence. In exceptional cases however, they can be interrupted
by emphasizers and other words:</p>

<pre><code class="language-sdparse">ve srovnání například s úvěry \n in comparison for-example to loans
fixed(ve, srovnání)
fixed(ve, s)
case(úvěry, ve)
advmod:emph(úvěry, například)
fixed(in, comparison)
fixed(in, to)
case(loans, in)
advmod:emph(loans, for-example)
</code></pre>

<p>Another type of interruption is caused by a possessive determiner. For instance, <em>na základě něčeho</em> “based on something”
contains the multi-word preposition <em>na základě</em> “based on”, lit. <em>on the-basis-of</em>. This expression is etymologically
a combination of a proper preposition <em>na</em> “on” and the noun <em>základ</em> “basis”; the argument <em>něčeho</em> “something” is in
genitive. If the phrase <em>na základě</em> were not analyzed as a multi-word expression, we would have a normal genitive
modification between two nominals: <em>základ něčeho</em> “basis of-something”. A genitive modifier can be substituted by
a possessive determiner, and this is possible even within the partially frozen multi-word preposition, as with the
relative possessive determiner in the following example:</p>

<pre><code class="language-sdparse">zákon , na jehož základě byl zřízen fond \n law , on whose basis was created fund
nmod(zřízen, jehož)
nmod(created, whose)
case(jehož, na)
case(whose, on)
fixed(na, základě)
fixed(on, basis)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/fixed.md" target="#">edit fixed</a></p>

<p><a id="al-cs-dep/flat" class="al-dest"></a></p>
<h2><code>flat</code>: personal name</h2>

<p><code>flat</code> is one of the relations for compounding in UD.
In Czech it is used to join the first (or middle) and the last name of a person.</p>

<p>The leftmost name is always the head and the other name(s) are attached to it.
In most cases this is the opposite to PDT where family names are heads and given names are dependents,
and the family name is usually the last name.</p>

<p>The relation is not used to attach adjectives to nouns within multi-word names of places, organizations etc.
(e.g. <em>Český Krumlov</em>).</p>

<pre><code class="language-sdparse">Prezident Václav Havel včera navštívil Český Krumlov . \n President Václav Havel yesterday visited Český Krumlov .
flat(Václav-2, Havel-3)
flat(Václav-11, Havel-12)
nmod(Václav-2, Prezident)
nmod(Václav-11, President)
amod(Krumlov-7, Český-6)
amod(Krumlov-16, Český-15)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/flat.md" target="#">edit flat</a></p>

<p><a id="al-cs-dep/flat:foreign" class="al-dest"></a></p>
<h2><code>flat:foreign</code>: foreign words</h2>

<p>We use <code>flat:foreign</code> to label sequences of foreign words. These are given
a linear analysis: the head is the first token in the foreign phrase.</p>

<p><code>flat:foreign</code> does not apply to loanwords or to foreign <a href="flat">names</a>.
It applies to quoted foreign text incorporated in a sentence/discourse
of the host language (unless we want to and know how to annotate the
internal structure according to the syntax of the foreign language).</p>

<pre><code class="language-sdparse">Jarmusch se objevil ve Wangově snímku Modrá ve tváři ( Blue in the Face ) .
flat:foreign(Blue, in)
flat:foreign(Blue, the)
flat:foreign(Blue, Face)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/flat-foreign.md" target="#">edit flat:foreign</a></p>

<p><a id="al-cs-dep/goeswith" class="al-dest"></a></p>
<h2><code>goeswith</code>: goes with</h2>

<p>This relation links two parts of a word that are separated in text
that is not well edited.
The head is always the first part, the other parts are attached to it with the <code>goeswith</code> relation
(for consistency, similarly as in <a href="">flat</a>, <a href="">fixed</a> and <a href="">conj</a>).
Note that only the last part may be annotated with <code>SpaceAfter=No</code>.</p>

<pre><code class="language-sdparse">Zastavil a z těžka oddychoval .
goeswith(z, těžka)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/goeswith.md" target="#">edit goeswith</a></p>

<p><a id="al-cs-dep/iobj" class="al-dest"></a></p>
<h2><code>iobj</code>: indirect object</h2>

<p>The indirect object of a verb is any nominal phrase that is a core
argument of the verb but is not its subject or <a href="obj">direct object</a>.
The prototypical example is the recipient of ditransitive verbs of
exchange:</p>

<pre><code class="language-sdparse">Pavel dal Petrovi dvě hrušky . \n Pavel gave Petr two pears .
iobj(dal, Petrovi)
iobj(gave, Petr)
</code></pre>

<p>However, Czech allows other semantic roles as additional objects.
The morphological <a href="">cs-feat/Case</a> of the objects is dictated by verb valency.</p>

<p>In the following Czech example, the verb takes two arguments, both are nouns in the accusative case. One of them is direct object (patient), the other is indirect (addressee). It is parallel to how the English translation would be annotated (where there is no morphological case marking) and also to verbs of giving (consider a similar sentence, <em>he gave my daughter a class of maths</em>).</p>

<pre><code class="language-sdparse">On učí mou dceru matematiku . \n He teaches my daughter.Acc maths.Acc .
obj(učí, matematiku)
iobj(učí, dceru)
obj(teaches, maths.Acc)
iobj(teaches, daughter.Acc)
</code></pre>

<p>In general, if there is just one object, it should be labeled
<a href="">obj</a>, regardless of the morphological case or semantic role.
For example, <em>učit</em> “to teach” can take either the subject matter or the recipient as the only object,
and in both cases it would be analyzed as the <a href="">obj</a>:</p>

<pre><code class="language-sdparse">Učí úvod do logiky . \n He-teaches introduction to logic .
obj(Učí, úvod)
obj(He-teaches, introduction)
</code></pre>

<pre><code class="language-sdparse">Učí studenty prvního ročníku . \n He-teaches students of-first year .
obj(Učí, studenty)
obj(He-teaches, students)
</code></pre>

<p>The one exception is when there is a clausal complement.
Then the clausal complement is regarded as a “clausal direct object” and an object nominal will be an <code>iobj</code>, parallel to
the simple ditransitive case:</p>

<pre><code class="language-sdparse">Řekla studentům , že dnes večer musí studovat . \n She-told students , that today evening they-needed to-study .
iobj(Řekla, studentům)
ccomp(Řekla, musí)
iobj(She-told, students)
ccomp(She-told, they-needed)
</code></pre>

<pre><code class="language-sdparse">Řekla studentům svůj plán . \n She-told students her plan .
iobj(Řekla, studentům)
obj(Řekla, plán)
iobj(She-told, students)
obj(She-told, plan)
</code></pre>

<p>If there are two or
more objects, one of them should be <a href="">obj</a> and the others should be
<code>iobj</code>. In such cases it is necessary to decide what is the
most directly affected object <em>(patient).</em></p>

<h2 id="diffs">Diffs</h2>

<h3 id="prague-dependency-treebank">Prague Dependency Treebank</h3>

<p>The manual annotation of the PDT does not distinguish direct and indirect objects.
Therefore most non-clausal dependents labeled <code>Obj</code> in PDT are currently labeled <code>obj</code>
in the converted data, even if it results in two or more direct objects attached to one verb.
Occasionally a heuristic was used: if there are two objects, one of them accusative and the other dative, then the former is obj and the latter iobj.
But such heuristics do not cover all possible objects, and even ditransitive verbs may occur without one of their objects because of ellipsis.
In future, the valency lexicon <a href="http://ufal.mff.cuni.cz/vallex">Vallex</a>
could be used to identify the main object.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/iobj.md" target="#">edit iobj</a></p>

<p><a id="al-cs-dep/list" class="al-dest"></a></p>
<h2><code>list</code>: list</h2>

<p>The <code>list</code> relation is used for chains of comparable items.
In lists with more than two items, all items of the list should modify the first one.
Informal and web text often contains passages which are meant to be interpreted as lists but are parsed as single sentences.
Email signatures often contain these structures, in the form of contact information:
the different contact information items are labeled as <code>list</code>; the key-value pair relations are labeled as <a href="">appos</a>.</p>

<p>However, <code>list</code> should not be over-used. If a construction can be easily analyzed
using the grammatical relations of standard sentences, such as when there is overt coordination,
then it should be analyzed with these more standard relations, even if it is laid out as a list typographically.</p>

<pre><code class="language-sdparse">Steve Jones tel.: 555-9814 e-mail: jones@abc.edf
flat(Steve-1, Jones-2)
list(Steve-1, tel.:-3)
list(Steve-1, e-mail:-5)
appos(tel.:-3, 555-9814-4)
appos(e-mail:-5, jones@abc.edf-6)
</code></pre>

<h2 id="diffs">Diffs</h2>

<h3 id="prague-dependency-treebank">Prague Dependency Treebank</h3>

<p>The <code>list</code> relation is not used in the current conversion of the PDT data to UD.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/list.md" target="#">edit list</a></p>

<p><a id="al-cs-dep/mark" class="al-dest"></a></p>
<h2><code>mark</code>: marker</h2>

<p>A marker is the subordinating conjunction introducing a finite clause subordinate to another clause.
The mark is a dependent of the subordinate clause head.</p>

<pre><code class="language-sdparse">Nevěděl jsem , že umíš německy . \n Not-know I-did , that you-can-speak German .
mark(umíš, že)
mark(you-can-speak, that)
</code></pre>

<pre><code class="language-sdparse">Zboží odešleme , jakmile peníze dorazí na náš účet . \n Goods we-will-dispatch , as-soon-as money arrive at our account .
mark(dorazí, jakmile)
mark(arrive, as-soon-as)
</code></pre>

<p>Note that the subordinating conjunction should not be confused with relative pronouns and adverbs.
These fill a valency slot in the frame of the subordinate predicate,
and are labeled according to their role in the frame, they are not <code>mark</code>:</p>

<pre><code class="language-sdparse">Rád bych věděl , kdy peníze dorazí na náš účet . \n Like-to I-would know , when money arrive at our account .
advmod(dorazí, kdy)
advmod(arrive, when)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/mark.md" target="#">edit mark</a></p>

<p><a id="al-cs-dep/neg" class="al-dest"></a></p>
<h2><code>neg</code>: negation modifier</h2>

<p>The negation modifier is the relation between the negation word <em>ne</em> and the
word it modifies.</p>

<p>Negation in Czech is most of the time expressed using a bound morpheme (the prefix <em>ne-</em>).
Occurrences of the morpheme as a separate word are rare in comparison to other languages,
yet they exist.</p>

<pre><code class="language-sdparse">Potřeboval čtyřnohého a ne dvounohého přítele . \n He-needed quadrupedal and not bipedal friend .
neg(dvounohého, ne)
neg(bipedal, not)
</code></pre>

<p>Note that the negative determiners (pronouns) are attached as <a href="">det</a>, not <code>neg</code>:</p>

<pre><code class="language-sdparse">Premiér není žádný hlupák . \n The-Prime-Minister is-not no fool .
det(hlupák, žádný)
det(fool, no)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/neg.md" target="#">edit neg</a></p>

<p><a id="al-cs-dep/nmod" class="al-dest"></a></p>
<h2><code>nmod</code>: nominal modifier</h2>

<p>The <code>nmod</code> relation is used for nominal modifiers of nominals.</p>

<p>It usually corresponds to a non-agreeing attribute <em>(přívlastek neshodný)</em>
in genitive. (See below for an example of an agreeing attribute, <em>přívlastek shodný</em>.)</p>

<p>In Czech the <code>nmod</code> relation covers only those possessives that are expressed using the genitive <a href="">cs-feat/Case</a>.
If a possessive adjective is used, the relation is labeled <a href="">amod</a>.</p>

<pre><code class="language-sdparse">kancelář ředitele \n office of-the-director
nmod(kancelář, ředitele)
nmod(office, of-the-director)
</code></pre>

<pre><code class="language-sdparse">ředitelova kancelář \n director's office
amod(kancelář, ředitelova)
amod(office, director's)
</code></pre>

<pre><code class="language-sdparse">jeho kancelář \n his office
det(kancelář, jeho)
det(office, his)
</code></pre>

<h2 id="agreeing-attribute-of-a-noun">Agreeing attribute of a noun</h2>

<p><code>nmod</code> noun phrases attached to nouns are usually in the genitive <a href="">cs-feat/Case</a> and follow the modified noun.
However, there is also a different kind of <code>nmod</code> that precedes the modified noun and agrees with it in case and number.
A typical example is a title attached to a name of a person. The relation is similar to the <a href="">flat</a> relation
that links the first and the last name, but it is not labeled <code>flat</code> because the title is not part of the name:</p>

<pre><code class="language-sdparse">český prezident Václav Havel
amod(prezident, český)
nmod(Václav, prezident)
flat(Václav, Havel)
</code></pre>

<p>Note that the same thing can be also expressed using an <a href="appos">apposition</a>.
In the case of apposition, the title follows the modified name and is separated by a punctuation symbol:</p>

<pre><code class="language-sdparse">Václav Havel , český prezident
flat(Václav, Havel)
punct(prezident, ,-3)
amod(prezident, český)
appos(Václav, prezident)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nmod.md" target="#">edit nmod</a></p>

<p><a id="al-cs-dep/nsubj" class="al-dest"></a></p>
<h2><code>nsubj</code>: nominal subject</h2>

<p>A nominal subject is a nominal phrase which is the syntactic subject of a clause;
in Czech, the phrase is in the nominative <a href="">cs-feat/Case</a>.
(See <a href="">csubj</a> for when the subject is clausal.
See <a href="">nsubj:pass</a> and <a href="">csubj:pass</a> for when the subject is not the proto-agent argument due to valence changing operations.)
The governor of the <code>nsubj</code> relation might not always be a verb: when
the verb is a copular verb, the root of the clause is the complement
of the copular verb, which can be an adjective or noun.</p>

<pre><code class="language-sdparse">Novosvětskou symfonii napsal Antonín Dvořák . \n From-the-New-World Symphony wrote Antonín Dvořák .
nsubj(napsal, Dvořák-5)
nsubj(wrote, Dvořák-12)
</code></pre>

<pre><code class="language-sdparse">Auto je červené . \n Car is red .
nsubj(červené, Auto)
nsubj(red, Car)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nsubj.md" target="#">edit nsubj</a></p>

<p><a id="al-cs-dep/nsubj:pass" class="al-dest"></a></p>
<h2><code>nsubj:pass</code>: passive nominal subject</h2>

<p>A passive nominal subject is a noun phrase which is the syntactic
subject of a passive clause.</p>

<pre><code class="language-sdparse">Schwarzenberg byl poražen Zemanem . \n Schwarzenberg was defeated by-Zeman .
nsubj:pass(poražen, Schwarzenberg-1)
nsubj:pass(defeated, Schwarzenberg-7)
</code></pre>

<p>Reflexive passive (the meaning is “This will be solved tomorrow.”)</p>

<pre><code class="language-sdparse">Tohle se bude řešit zítra . \n This itself will solve tomorrow .
nsubj:pass(řešit, Tohle)
nsubj:pass(solve, This)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nsubj-pass.md" target="#">edit nsubj:pass</a></p>

<p><a id="al-cs-dep/nummod" class="al-dest"></a></p>
<h2><code>nummod</code>: numeric modifier</h2>

<p>A numeric modifier of a noun is any <a href="cs-pos/NUM">number</a> phrase
that serves to modify the meaning of the noun with a quantity.</p>

<pre><code class="language-sdparse">Jan snědl tři řízky . \n Jan ate three steaks .
nummod(řízky, tři)
nummod(steaks, three)
</code></pre>

<h2 id="agreement-and-government-with-czech-quantifiers">Agreement and government with Czech quantifiers</h2>

<p>The morphological and syntactic behavior of Czech numerals is a complex matter.
Small cardinal numerals <em>jeden</em> “one”, <em>dva</em> “two”, <em>tři</em> “three” and <em>čtyři</em> “four” agree with the counted
noun in <a href="">cs-feat/Case</a> (<em>jeden</em> also agrees in <a href="">cs-feat/Gender</a> and <a href="">cs-feat/Number</a>;
<em>dva</em> also agrees in <a href="">cs-feat/Gender</a>).
They behave as if they modify the counted noun; they are similar to adjectives in this respect.
Examples:</p>

<ul>
  <li><em><b>Jeden</b> muž spal, <b>dva</b> muži hráli karty.</em> “One man slept, two men played cards.”</li>
  <li><em><b>Jedna</b> žena spala, <b>dvě</b> ženy hrály karty.</em> “One woman slept, two women played cards.”</li>
  <li><em><b>Jedno</b> kotě spalo, <b>dvě</b> koťata si hrála.</em> “One kitten slept, two kittens played.”</li>
</ul>

<p>In PDT, these numerals are attached to their counted nouns as <code>Atr</code> (attribute).
It is straightforward to convert such dependencies to <code>nummod</code>:</p>

<pre><code class="language-sdparse">Jedno kotě spalo . \n One kitten slept .
nummod(kotě, Jedno)
nsubj(spalo, kotě)
punct(spalo, .-4)
nummod(kitten, One)
nsubj(slept, kitten)
punct(slept, .-9)
</code></pre>

<p>Larger cardinals behave differently.
They require that the counted noun be in the genitive case; this indicates that they actually govern the noun.
Such constructions are parallel to nouns modified by other noun phrases in genitive.
The whole phrase (numeral + counted noun) behaves as a noun phrase in neuter gender and singular number
(which is important for subject-verb agreement).</p>

<ul>
  <li><em><b>Pět</b> mužů hrálo karty.</em> “Five men played cards.”</li>
  <li><em>Skupina mužů hrála karty.</em> “A group of men played cards.”</li>
</ul>

<p>In PDT, these numerals are analyzed as heads of the counted nouns, which are attached to the numeral as <code>Atr</code>:</p>

<pre><code class="language-conllu"># This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1   Pět     pět     NUM     _   Case=Nom                           3   Sb     _   Five
2   mužů    muž     NOUN    _   Case=Gen|Gender=Masc|Number=Plur   1   Atr    _   men
3   hrálo   hrát    VERB    _   Gender=Neut|Number=Sing            0   Pred   _   played
4   karty   karta   NOUN    _   Case=Acc|Gender=Fem|Number=Plur    3   Obj    _   cards
5   .       .       PUNCT   _   _                                  0   AuxK   _   .
</code></pre>

<p>There are both advantages and drawbacks to this solution.
On the one hand, it reflects well the agreement in case, gender and number.
On the other hand, it is confusing that there are two different analyses of counted noun constructions,
depending on the numeric value.</p>

<p>Moreover, the numeral does not govern the noun in all morphological cases.
The following table shows the case of the whole phrase (numeral + noun; first column)
and the consequences for the case of the parts (note that these numerals have only
two distinct morphological forms, resulting in homonymy).</p>

<table>
<tr><th>Phrase Case</th><th>Example</th><th>Numeral Case</th><th>Noun Case</th></tr>
<tr><td>Nom</td><td>pět mužů</td>   <td>Nom</td><td>Gen</td></tr>
<tr><td>Gen</td><td>pěti mužů</td>  <td>Gen</td><td>Gen</td></tr>
<tr><td>Dat</td><td>pěti mužům</td> <td>Dat</td><td>Dat</td></tr>
<tr><td>Acc</td><td>pět mužů</td>   <td>Acc</td><td>Gen</td></tr>
<tr><td>Voc</td><td>pět mužů</td>   <td>Voc</td><td>Gen</td></tr>
<tr><td>Loc</td><td>pěti mužích</td><td>Loc</td><td>Loc</td></tr>
<tr><td>Ins</td><td>pěti muži</td>  <td>Ins</td><td>Ins</td></tr>
</table>

<p>We can say that the noun has the case of the whole phrase if it is dative, locative or instrumental.
The numeral then agrees with the noun in case.
The numeral forces the noun to the genitive case if the whole phrase is nominative, accusative or vocative
(but the vocative usage is rather hypothetical).
In genitive, the noun and the numeral agree with each other; but note that the numeral uses its
inflected form, as in the other cases where it agrees with the noun.</p>

<p>In PDT, the genitive, dative, locative and instrumental cases are analyzed in parallel to the low-value numerals,
i.e. the noun governs the numeral:</p>

<pre><code class="language-conllu"># This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1   Hrál      hrát    VERB    _   Gender=Masc|Number=Sing            0   Pred   _   He-played
2   karty     karta   NOUN    _   Case=Acc|Gender=Fem|Number=Plur    1   Obj    _   cards
3   s         s       ADP     _   _                                  1   AuxP   _   with
4   pěti      pět     NUM     _   Case=Ins                           6   Atr    _   five
5   dalšími   další   ADJ     _   Case=Ins|Gender=Masc|Number=Plur   6   Atr    _   other
6   muži      muž     NOUN    _   Case=Ins|Gender=Masc|Number=Plur   3   Obj    _   men
7   .         .       PUNCT   _   _                                  0   AuxK   _   .
</code></pre>

<p>High-value numerals where the lowest-order digit is more than zero and less than five (e.g. 21, 22, 23, 24) may behave both ways:</p>

<ul>
  <li><em>dvacet <b>dva</b> muži</em> (noun governs numeral)</li>
  <li><em>dvacet <b>dva</b> mužů</em> (numeral governs noun)</li>
  <li><em><b>dvaadvacet</b> mužů</em> (alternative form; it does not end with <em>dva</em>, thus the numeral governs the noun)</li>
  <li><em><b>22</b> muži</em> (assuming the reader will pronounce <em>22</em> as <em>dvacet dva,</em> not <em>dvaadvacet</em>)</li>
  <li><em><b>22</b> mužů</em> (pronounced either way)</li>
</ul>

<p>Pronominal quantifiers behave as high-value numerals and govern the quantifed nouns:</p>

<ul>
  <li><em><b>Kolik</b> mužů hrálo karty?</em> “How many men played cards?”</li>
  <li><em><b>Několik</b> (<b>mnoho</b>, <b>málo</b>) mužů hrálo karty.</em> “Several (many, few) men played cards.”</li>
  <li><em><b>Tolik</b> mužů hrát karty jsem ještě neviděl.</em> “I have never seen so many men playing cards.”</li>
</ul>

<pre><code class="language-conllu"># This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1   Kolik   kolik   NUM     _   Case=Nom                           3   Sb     _   How-many
2   mužů    muž     NOUN    _   Case=Gen|Gender=Masc|Number=Plur   1   Atr    _   men
3   hrálo   hrát    VERB    _   Gender=Neut|Number=Sing            0   Pred   _   played
4   karty   karta   NOUN    _   Case=Acc|Gender=Fem|Number=Plur    3   Obj    _   cards
5   ?       ?       PUNCT   _   _                                  0   AuxK   _   ?
</code></pre>

<p>The UD conversion of the PDT data unifies analyses of counted noun phrases
and uses a structure that is parallel among all the above cases,
and also with universal dependencies in other languages.
The counted noun is always the head and the numeral is always attached as its modifier.
Nevertheless, we use different relation labels to mark situations where the numeral (or quantifier)
actually governs the morphological case of the noun.
There are four labels used:</p>

<table>
<tr><td></td><td><strong>Numeric</strong></td><td><strong>Pronominal</strong></td></tr>
<tr><td><strong>Noun governs</strong></td><td><tt>nummod</tt></td><td><tt><a href="det-nummod.html">det:nummod</a></tt></td></tr>
<tr><td><strong>Numeral governs</strong></td><td><tt><a href="nummod-gov.html">nummod:gov</a></tt></td><td><tt><a href="det-numgov.html">det:numgov</a></tt></td></tr>
</table>

<pre><code class="language-sdparse">Tři muži hráli karty . \n Three men played cards .
nummod(muži, Tři)
nsubj(hráli, muži)
obj(hráli, karty)
punct(hráli, .-5)
nummod(men, Three)
nsubj(played, men)
obj(played, cards)
punct(played, .-11)
</code></pre>

<pre><code class="language-sdparse">Pět mužů hrálo karty . \n Five men played cards .
nummod:gov(mužů, Pět)
nsubj(hrálo, mužů)
obj(hrálo, karty)
punct(hrálo, .-5)
nummod:gov(men, Five)
nsubj(played, men)
obj(played, cards)
punct(played, .-11)
</code></pre>

<pre><code class="language-sdparse">Kolik mužů hrálo karty ? \n How-many men played cards ?
det:numgov(mužů, Kolik)
nsubj(hrálo, mužů)
obj(hrálo, karty)
punct(hrálo, ?-5)
det:numgov(men, How-many)
nsubj(played, men)
obj(played, cards)
punct(played, ?-11)
</code></pre>

<pre><code class="language-sdparse">Hrál jsem karty s pěti muži . \n Played I-have cards with five men .
aux(Hrál, jsem)
obj(Hrál, karty)
iobj(Hrál, muži)
case(muži, s)
nummod(muži, pěti)
punct(Hrál, .-7)
aux(Played, I-have)
obj(Played, cards)
iobj(Played, men)
case(men, with)
nummod(men, five)
punct(Played, .-15)
</code></pre>

<pre><code class="language-sdparse">Nepamatuji si , s kolika muži jsem hrál karty . \n I-do-not-remember myself , with how-many men I-have played cards .
ccomp(Nepamatuji, hrál)
expl:pv(Nepamatuji, si)
punct(hrál, ,-3)
aux(hrál, jsem)
obj(hrál, karty)
iobj(hrál, muži)
case(muži, s)
det:nummod(muži, kolika)
punct(Nepamatuji, .-10)
ccomp(I-do-not-remember, played)
expl:pv(I-do-not-remember, myself)
punct(played, ,-14)
aux(played, I-have)
obj(played, cards)
iobj(played, men)
case(men, with)
det:nummod(men, how-many)
punct(I-do-not-remember, .-21)
</code></pre>

<h2 id="additional-remarks">Additional remarks</h2>

<p>In PDT the words <em>milión</em> “million”, <em>miliarda</em> “billion” and higher are usually tagged as <a href="cs-pos/NOUN">nouns</a>,
not as <a href="cs-pos/NUM">numerals</a>.
In the typical case, the million is in genitive, it is preceded by a smaller number,
and it is not followed by smaller numerals (as it is in <em>million five hundred thousand</em>).
It is followed by the counted noun.
Thus the following examples receive parallel analyses:</p>

<pre><code class="language-sdparse">50 miliónů korun \n 50 millions of-crowns
nummod:gov(miliónů, 50-1)
nummod:gov(millions, 50-5)
nmod(miliónů, korun)
nmod(millions, of-crowns)
</code></pre>

<pre><code class="language-sdparse">50 pytlů bankovek \n 50 sacks of-bills
nummod:gov(pytlů, 50-1)
nummod:gov(sacks, 50-5)
nmod(pytlů, bankovek)
nmod(sacks, of-bills)
</code></pre>

<p>On the other hand the word <em>tisíc</em> “thousand” may be a noun
(<em>na náměstí byly tisíce lidí</em> “there were thousands of people in the square”)
or a numeral:</p>

<pre><code class="language-sdparse">nanejvýš 50 tisíc korun \n at-most 50 thousand crowns
advmod:emph(korun, nanejvýš)
nummod:gov(korun, tisíc)
compound(tisíc, 50-2)
advmod:emph(crowns, at-most)
nummod:gov(crowns, thousand)
compound(thousand, 50-7)
</code></pre>

<p>Note that the two numeral words in the above example are joined using the <a href="">compound</a> relation.
Also note that the <a href="advmod:emph">intensifier</a> <em>nanejvýš</em> is attached to the head of the phrase <em>(korun)</em> and not to the number.
This is in accord both with the UD guidelines
and with the original PDT annotation of agreeing numerals (e.g. <em>jen čtyři firmy, jen několik procent</em>).</p>

<p>Similarly there may be other nodes (such as punctuation) that are attached to the head of the phrase
and they are related to the whole phrase rather than directly to the head noun:</p>

<pre><code class="language-sdparse">( 9 dní ) \n ( 9 days )
punct(dní, (-1)
nummod:gov(dní, 9-2)
punct(dní, )-4)
punct(days, (-6)
nummod:gov(days, 9-7)
punct(days, )-9)
</code></pre>

<pre><code class="language-sdparse">5 minut včetně seřízení \n 5 minutes including adjustment
nummod:gov(minut, 5-1)
nmod(minut, seřízení)
case(seřízení, včetně)
nummod:gov(minutes, 5-6)
nmod(minutes, adjustment)
case(adjustment, including)
</code></pre>

<h2 id="dates">Dates</h2>

<!-- mf920922_027.a.gz (3/19) -->
<pre><code class="language-conllu"># This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1    Ředitel         ředitel         NOUN    _   _   2   Sb     _   The-director
2    navrhl          navrhnout       VERB    _   _   0   Pred   _   proposed
3    zrušit          zrušit          VERB    _   _   2   Obj    _   to-disband
4    profesionální   profesionální   ADJ     _   _   5   Atr    _   the-professional
5    scénu           scéna           NOUN    _   _   3   Obj    _   scene
6    k               k               ADP     _   _   3   AuxP   _   towards
7    31              31              NUM     _   _   9   Atr    _   the-31
8    .               .               PUNCT   _   _   7   AuxG   _   th
9    12              12              NUM     _   _   6   Adv    _   December
10   .               .               PUNCT   _   _   9   AuxG   _   .
</code></pre>

<pre><code class="language-sdparse">Ředitel navrhl zrušit profesionální scénu k 31 . 12 . \n Director proposed to-disband professional scene towards 31 st December .
advmod(zrušit, 12)
case(12, k)
punct(12, .-10)
nummod(12, 31-7)
punct(31-7, .-8)
advmod(to-disband, December)
case(December, towards)
punct(December, .-21)
nummod(December, 31-18)
punct(31-18, st)
</code></pre>

<p>Numerals expressed using digits are labeled <code>nummod</code> even if they represent ordinal numerals,
which would be labeled <code>amod</code>:</p>

<!-- ln95045_123.a.gz (8/8) -->
<pre><code class="language-conllu"># This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1    Letošní     letošní      ADJ     _   _   2   Atr    _   This-year's
2    veletrh     veletrh      NOUN    _   _   4   Sb     _   fair
3    se          se           PRON    _   _   4   AuxR   _   itself
4    uskuteční   uskutečnit   VERB    _   _   0   Pred   _   will-take-place
5    od          od           ADP     _   _   4   AuxP   _   from
6    9           9            NUM     _   _   5   ExD    _   9
7    .           .            PUNCT   _   _   6   AuxG   _   th
8    do          do           ADP     _   _   4   AuxP   _   to
9    12          12           NUM     _   _   11  Atr    _   12
10   .           .            PUNCT   _   _   9   AuxG   _   th
11   března      březen       NOUN    _   _   8   Adv    _   March
12   .           .            PUNCT   _   _   0   AuxK   _   .
</code></pre>
<pre><code class="language-sdparse">Letošní veletrh se uskuteční od 9 . do 12 . března . \n This-year's fair itself will-take-place from 9 th to 12 th March .
advmod(uskuteční, března)
case(března, do)
nummod(března, 12-9)
remnant(12-9, 9-6)
remnant(do, od)
advmod(will-take-place, March)
case(March, to)
nummod(March, 12-22)
remnant(12-22, 9-19)
remnant(to, from)
</code></pre>

<h2 id="numbered-objects">Numbered objects</h2>

<p>House number in address is attached as <code>nummod</code> to the name of the street:</p>

<pre><code class="language-sdparse">v budově Na poříčí 12 \n in the-building Na poříčí 12
nmod(budově, poříčí-4)
case(poříčí-4, Na-3)
nummod(poříčí-4, 12-5)
nmod(the-building, poříčí-10)
case(poříčí-10, Na-9)
nummod(poříčí-10, 12-11)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nummod.md" target="#">edit nummod</a></p>

<p><a id="al-cs-dep/nummod:gov" class="al-dest"></a></p>
<h2><code>nummod:gov</code>: numeric modifier governing the case of the noun</h2>

<p><code>nummod:gov</code> differs from <a href="">nummod</a>
in that the numeral requires the counted noun to be in its genitive form.
The whole phrase (numeral + noun) is treated as a singular neuter noun phrase
and it can fill roles where nominative, accusative or vocative noun phrases are expected.</p>

<p>Such situations are analyzed in PDT so that the numeral is the head and the noun depends on it.
In UD the dependency direction is reversed and the <code>nummod:gov</code> label is used to preserve
the information about case conditions.</p>

<pre><code class="language-conllu"># This is not UD, it is Prague Dependency Treebank, and we want to clearly distinguish it from the UD examples.
# visual-style nodes yellow
# visual-style arcs blue
1   Pět     pět     NUM     _   Case=Nom                           3   Sb     _   Five
2   mužů    muž     NOUN    _   Case=Gen|Gender=Masc|Number=Plur   1   Atr    _   men
3   hrálo   hrát    VERB    _   Gender=Neut|Number=Sing            0   Pred   _   played
4   karty   karta   NOUN    _   Case=Acc|Gender=Fem|Number=Plur    3   Obj    _   cards
5   .       .       PUNCT   _   _                                  0   AuxK   _   .
</code></pre>

<pre><code class="language-sdparse">Pět mužů hrálo karty . \n Five men played cards .
nummod:gov(mužů, Pět)
nsubj(hrálo, mužů)
obj(hrálo, karty)
punct(hrálo, .-5)
nummod:gov(men, Five)
nsubj(played, men)
obj(played, cards)
punct(played, .-11)
</code></pre>

<p>See <a href="">nummod</a> for a broader discussion of the various situations with quantifiers.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/nummod-gov.md" target="#">edit nummod:gov</a></p>

<p><a id="al-cs-dep/obj" class="al-dest"></a></p>
<h2><code>obj</code>: direct object</h2>

<p>The direct object of a verb is the noun phrase that denotes the entity acted upon.
Most often the direct object is in the <a href="cs-feat/Case">accusative case</a> but
there are verbs that require their objects be in other cases (except for
nominative and vocative).</p>

<p>Accusative example:</p>

<pre><code class="language-sdparse">Koupil jsem auto . \n Bought I-have car .
obj(Koupil, auto)
obj(Bought, car)
</code></pre>

<p>Genitive example:</p>

<pre><code class="language-sdparse">Cením si vaší pomoci . \n I-appreciate REFLEX your help .
obj(Cením, pomoci)
obj(I-appreciate, help)
</code></pre>

<p>Dative example:</p>

<pre><code class="language-sdparse">Čelíme velkým problémům . \n We-face big problems .
obj(Čelíme, problémům)
obj(We-face, problems)
</code></pre>

<p>Instrumental example:</p>

<pre><code class="language-sdparse">Univerzita nedisponuje takovým rozpočtem . \n University does-not-have-at-disposal such budget .
obj(nedisponuje, rozpočtem)
obj(does-not-have-at-disposal, budget)
</code></pre>

<p>In general, if there is just one object, it should be labeled <code>obj</code>,
regardless of the morphological case or semantic role that it bears. If there are two or more
objects, one of them should be <code>obj</code> and the others should be
<a href="">iobj</a>. In such cases it is necessary to decide what is the most
directly affected object <em>(patient).</em> The one exception is when there is a clausal complement. Then the clausal complement is regarded as a “clausal direct object” and an object nominal will be an iobj.</p>

<h2 id="diffs">Diffs</h2>

<h3 id="prague-dependency-treebank">Prague Dependency Treebank</h3>

<p>The manual annotation of the PDT does not distinguish direct and indirect objects.
Therefore most non-clausal dependents labeled <code>Obj</code> in PDT are currently labeled <code>obj</code>
in the converted data, even if it results in two or more direct objects attached to one verb.
Occasionally a heuristic was used: if there are two objects, one of them accusative and the other dative,
then the former is <code>obj</code> and the latter <code>iobj</code>. But such heuristics do not cover all possible objects,
and even ditransitive verbs may occur without one of their objects because of ellipsis.
In future, the valency lexicon <a href="http://ufal.mff.cuni.cz/vallex">Vallex</a>
could be used to identify the main object.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/obj.md" target="#">edit obj</a></p>

<p><a id="al-cs-dep/obl" class="al-dest"></a></p>
<h2><code>obl</code>: oblique argument or adjunct</h2>

<p>The <code>obl</code> relation is used for oblique nominal arguments and adjuncts of verbs, adjectives or adverbs.</p>

<p><code>obl</code> is a <a href="cs-pos/NOUN">noun</a> (or noun phrase) functioning as a
non-core (oblique) argument or adjunct.
This means that it functionally corresponds to an adverbial when it attaches to a verb, adjective or other adverb.</p>

<pre><code class="language-sdparse">Potkal jsem ho minulý čtvrtek . \n Met I-have him last Thursday .
obl(Potkal, čtvrtek)
obl(Met, Thursday)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/obl.md" target="#">edit obl</a></p>

<p><a id="al-cs-dep/orphan" class="al-dest"></a></p>
<h2><code>orphan</code>: connecting orphaned arguments of elided predicate</h2>

<p>The <code>orphan</code> relation is used to provide a satisfactory treatment of certain instances of
<a href="http://universaldependencies.org/cs/overview/specific-syntax.html#ellipsis">ellipsis</a>
(in the case of gapping and stripping, where a predicational or verbal
head gets elided).</p>

<pre><code class="language-sdparse">Pavel si objednal hovězí a Markéta vepřové . \n Pavel himself ordered beef and Markéta pork .
nsubj(objednal, Pavel-1)
nsubj(ordered, Pavel-10)
obj(objednal, hovězí)
obj(ordered, beef)
conj(objednal, Markéta-6)
conj(ordered, Markéta-15)
orphan(Markéta-6, vepřové)
orphan(Markéta-15, pork)
cc(Markéta-6, a)
cc(Markéta-15, and)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/orphan.md" target="#">edit orphan</a></p>

<p><a id="al-cs-dep/parataxis" class="al-dest"></a></p>
<h2><code>parataxis</code>: parataxis</h2>

<p>The parataxis relation (from Greek for “place side by side”) is a
relation between a word (often the main predicate of a sentence) and other
elements, such as a sentential parenthetical or a clause after a “:” or
a “;”, placed side by side without any explicit
coordination, subordination, or argument relation with the head word. Parataxis is a discourse-like equivalent of coordination, and so usually obeys an iconic ordering. Hence it is normal for the first part of a sentence to be the head and the second part to be the parataxis dependent, regardless of the headedness properties of the language.  But things do get more complicated, such as cases of parentheticals, which appear medially.</p>

<h2 id="an-inventory-of-constructions-to-which-parataxis-has-been-applied">An inventory of constructions to which parataxis has been applied</h2>

<h3 id="treatment-of-reported-speech">Treatment of reported speech</h3>

<p>For this reported speech example:</p>

<pre><code class="language-sdparse">Ten člověk , řekl Honza , odjel brzy ráno . \n The guy , said Honza , left early in-the-morning .
parataxis(odjel, řekl)
parataxis(left, said)
</code></pre>

<p>there are paraphrases that convey essentially the same meaning but
with a different syntactic structure. When the reported speech is embedded in a subordinate clause (with or 
without an overt complementizer <em>že</em> “that”), the subordinate clause is a <a href="">ccomp</a> of the speech verb. When the
reported speech follows the speech verb and is separated by a colon, the reported speech forms a main clause
that attaches to the preceding main clause with a <a href="">parataxis</a> relation, hence with the speech verb as its head.
However, when the speech verb occurs as a medial or final parenthetical, the relation is reversed and the speech
verb is treated as a <a href="">parataxis</a> of the reported speech. 
This analysis is not uncontroversial but follows many authorities, such as Huddleston and Pullum (2002),
<em>The Cambridge Grammar of the English Language</em> (see chapter 11, section 9).</p>

<pre><code class="language-sdparse">Honza řekl , že ten člověk odjel brzy ráno . \n Honza said , that the guy left early in-the-morning .
ccomp(řekl, odjel)
ccomp(said, left)
</code></pre>

<pre><code class="language-sdparse">Honza řekl : „ Ten člověk odjel brzy ráno . “ \n Honza said : “ The guy left early in-the-morning . ”
parataxis(řekl, odjel)
parataxis(said, left)
</code></pre>

<pre><code class="language-sdparse">„ Ten člověk odjel brzy ráno , “ řekl Honza . \n “ The guy left early in-the-morning , ” said Honza .
parataxis(odjel, řekl)
parataxis(left, said)
</code></pre>

<pre><code class="language-sdparse">„ Ten člověk , “ řekl Honza , „ odjel brzy ráno . “ \n “ The guy , ” said Honza , “ left early in-the-morning . ”
parataxis(odjel, řekl)
parataxis(left, said)
</code></pre>

<p>An argument for this analysis is that in the cases analyzed as embedding, the entire clause
can be further embedded (<em>I was taken aback when John said the guy left early in the morning.</em>),
while this is not possible with medial or final placement of the speech verb 
(<em>*I was taken aback when the guy left early this morning, John said.</em>).</p>

<h3 id="news-article-bylines">News article bylines</h3>

<p>The <code>parataxis</code> relation should be used to connect the parts of a news article byline.
There does not seem to be a better relation to use.</p>

<pre><code class="language-sdparse">Washington ( CNN ) :
parataxis(Washington, CNN)
</code></pre>

<h3 id="interjected-clauses-and-phrases">Interjected clauses and phrases</h3>

<pre><code class="language-sdparse">V posledních letech se srovnávání rozšiřuje , přinejmenším pokud jde o platy , na sousední státy . \n In recent years is comparison extended , at-least as concerns about salaries , to neighboring countries .
parataxis(rozšiřuje, jde)
parataxis(extended, concerns)
</code></pre>

<h2 id="diffs">Diffs</h2>

<h3 id="prague-dependency-treebank">Prague Dependency Treebank</h3>

<p>At present the PDT data converted to UD use <code>parataxis</code> only for interjected parentheticals.
The other examples above are analyzed differently (legacy PDT structure).</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/parataxis.md" target="#">edit parataxis</a></p>

<p><a id="al-cs-dep/punct" class="al-dest"></a></p>
<h2><code>punct</code>: punctuation</h2>

<p>This is used for any piece of punctuation in a clause.
See</p>

<pre><code class="language-sdparse">Jdi domů ! \n Go home !
punct(Jdi, !-3)
punct(Go, !-7)
</code></pre>

<p>Tokens with the relation <code>punct</code> always attach to content words (except in cases of ellipsis) and can never have dependents.
Since <code>punct</code> is not a normal dependency relation, the usual criteria for determining the head word do not apply.
Instead, we use the following principles:</p>

<ol>
  <li>A punctuation mark separating coordinated units is attached to the following conjunct.</li>
  <li>A punctuation mark preceding or following a subordinated unit is attached to this unit.</li>
  <li>Within the relevant unit, a punctuation mark is attached at the highest possible node that preserves projectivity.</li>
  <li>Paired punctuation marks (quotes and brackets) should be attached to the same word unless that would create non-projectivity. This word is usually the head of the phrase enclosed in the paired punctuation.</li>
</ol>

<pre><code class="language-sdparse">Máme jablka , hrušky , pomeranče a banány . \n We-have apples , pears , oranges and bananas .
obj(Máme, jablka)
obj(We-have, apples)
conj(jablka, hrušky)
conj(jablka, pomeranče)
conj(jablka, banány)
conj(apples, pears)
conj(apples, oranges)
conj(apples, bananas)
cc(banány, a)
cc(bananas, and)
punct(hrušky, ,-3)
punct(pomeranče, ,-5)
punct(pears, ,-13)
punct(oranges, ,-15)
</code></pre>

<pre><code class="language-sdparse">Muž , kterého jste včera viděl , přišel zas . \n Man , whom you-have yesterday seen , came again .
punct(viděl, ,-2)
punct(seen, ,-13)
punct(viděl, ,-7)
punct(seen, ,-18)
punct(přišel, .-10)
punct(came, .-21)
</code></pre>

<pre><code class="language-sdparse">Zkratka např . znamená „ například “ . \n The-abbreviation eg . means “ for-example ” .
punct(např, .-3)
punct(eg, .-12)
punct(například, „-5)
punct(for-example, “-14)
punct(například, “-7)
punct(for-example, ”-16)
punct(znamená, .-8)
punct(means, .-17)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/punct.md" target="#">edit punct</a></p>

<p><a id="al-cs-dep/reparandum" class="al-dest"></a></p>
<h2><code>reparandum</code>: overridden disfluency</h2>

<p>We use <code>reparandum</code> to indicate disfluencies overridden in a speech
repair. The disfluency is the dependent of the repair.</p>

<pre><code class="language-sdparse">Jděte dopra- doleva . \n Go to-the-righ- to-the-left .
reparandum(doleva, dopra-)
reparandum(to-the-left, to-the-righ-)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/reparandum.md" target="#">edit reparandum</a></p>

<p><a id="al-cs-dep/root" class="al-dest"></a></p>
<h2><code>root</code>: root</h2>

<p>The <code>root</code> grammatical relation points to the root of the sentence. A
fake node <code>ROOT</code> is used as the governor. The <code>ROOT</code> node is indexed
with 0, since the indexing of real words in the sentence starts at 1.</p>

<pre><code class="language-sdparse">ROOT Miluju indická jídla . \n ROOT I-love Indian food .
root(ROOT-1, Miluju)
root(ROOT-7, I-love)
</code></pre>

<p>Since release 1.2 of the Czech UD treebank,
there is just one node with the <code>root</code> dependency relation in every
tree. If the main predicate is not present (due to
<a href="http://universaldependencies.org/cs/overview/specific-syntax.html#ellipsis">ellipsis</a>)
and there are
multiple orphaned dependents, the dependent that is highest in the obliqueness hierarchy is promoted to
the head (root) position and the other orphans are attached to it.</p>

<p>An example sentence-like segment that lacks the main verb:
<em>A co na to [říká] MF?</em>
“And what [does] MF [say] to it?”</p>

<pre><code class="language-sdparse">ROOT A co na to MF ? \n ROOT And what to it MF ?
root(ROOT-1, MF-6)
root(ROOT-9, MF-14)
orphan(MF-6, co)
orphan(MF-14, what)
orphan(MF-6, to-5)
orphan(MF-14, it)
case(to-5, na)
case(it, to-12)
cc(MF-6, A)
cc(MF-14, And)
punct(MF-6, ?-7)
punct(MF-14, ?-15)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/root.md" target="#">edit root</a></p>

<p><a id="al-cs-dep/vocative" class="al-dest"></a></p>
<h2><code>vocative</code>: vocative</h2>

<p>The <code>vocative</code> relation is used to mark the dialogue participant addressed in text.
The relation links the addressee’s name or title to its host sentence.
In Czech, the addressee’s name must also appear in the vocative <a href="">cs-feat/Case</a> form.</p>

<pre><code class="language-sdparse">Pane , jste blázen ! \n Sir , you-are a-fool !
vocative(blázen, Pane)
vocative(a-fool, Sir)
cop(blázen, jste)
cop(a-fool, you-are)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/vocative.md" target="#">edit vocative</a></p>

<p><a id="al-cs-dep/xcomp" class="al-dest"></a></p>
<h2><code>xcomp</code>: open clausal complement</h2>

<p>An open clausal complement (<code>xcomp</code>) of a verb or an adjective is a
predicative or clausal complement without its own subject. The
reference of the subject is necessarily determined by an argument
external to the xcomp (normally by the subject of the next higher
clause). This is often referred to as <em>obligatory control</em>. 
These complements are always non-finite, and they are
complements (arguments of the higher verb or adjective) rather than
adjuncts/modifiers, such as a purpose clause. The name <code>xcomp</code> is
borrowed from Lexical-Functional Grammar.</p>

<pre><code class="language-sdparse">Nechceš si zaplavat ? \n Don't-you-want yourself to-swim ?
xcomp(Nechceš, zaplavat)
xcomp(Don't-you-want, to-swim)
</code></pre>

<pre><code class="language-sdparse">Začal jsem tam pracovat včera . \n Started I-have there to-work yesterday .
xcomp(Začal, pracovat)
xcomp(Started, to-work)
</code></pre>

<p>Note that the above condition “without its own subject” does not mean that a 
clause is an <code>xcomp</code> just because its subject is not <em>overt.</em>
The subject must be necessarily inherited from a fixed position in the higher clause.
That is, there should be no available interpretation where the subject of the lower clause may be distinct
from the specified role of the upper clause.
In cases where the missing subject may or must be distinct from a fixed role in the higher clause,
<a href="">ccomp</a> should be used instead, as below.  This includes cases of arbitrary subjects and anaphoric control.</p>

<pre><code class="language-sdparse">Šéf nařídil vykopat příkop . \n Boss ordered to-dig ditch .
ccomp(nařídil, vykopat)
ccomp(ordered, to-dig)
</code></pre>

<p>Pro-drop languages have clauses where the subject is not present as a separate word,
yet it is inherently present (and often deducible from the form of the verb)
and it does not depend on arguments from a higher clause.
Thus in neither of the following two Czech examples is there any overt subject,
yet only the second example contains an <code>xcomp</code>.</p>

<pre><code class="language-sdparse">Píšu , protože jsem to slíbil . \n I-write , because I-have it promised .
advcl(Píšu, slíbil)
advcl(I-write, promised)
</code></pre>

<pre><code class="language-sdparse">Slíbil jsem psát . \n Promised I-have to-write .
xcomp(Slíbil, psát)
xcomp(Promised, to-write)
</code></pre>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_cs-dep/xcomp.md" target="#">edit xcomp</a></p>



      </div>

<!-- support for embedded visualizations -->
<script type="text/javascript">
    var root = '../../'; // filled in by jekyll
    head.js(
        // External libraries
        root + 'lib/ext/jquery.min.js',
        root + 'lib/ext/jquery.svg.min.js',
        root + 'lib/ext/jquery.svgdom.min.js',
        root + 'lib/ext/jquery.timeago.js',
        root + 'lib/ext/jquery-ui.min.js',
        root + 'lib/ext/waypoints.min.js',
        root + 'lib/ext/jquery.address.min.js',

        // brat helper modules
        root + 'lib/brat/configuration.js',
        root + 'lib/brat/util.js',
        root + 'lib/brat/annotation_log.js',
        root + 'lib/ext/webfont.js',
        // brat modules
        root + 'lib/brat/dispatcher.js',
        root + 'lib/brat/url_monitor.js',
        root + 'lib/brat/visualizer.js',

        // embedding configuration
        root + 'lib/local/config.js',
        // project-specific collection data
        root + 'lib/local/collections.js',

        // NOTE: non-local libraries
        'https://spyysalo.github.io/annodoc/lib/local/annodoc.js',
        'https://spyysalo.github.io/conllu.js/conllu.js'
    );

    var webFontURLs = [
//        root + 'static/fonts/Astloch-Bold.ttf',
        root + 'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        root + 'static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var setupAccordions = function() {
	// preserve state in URL hash, following in part
	// http://www.boduch.ca/2011/05/remembering-jquery-ui-accordion.html
	var accordionChange = function(event, ui) {
	    var context = ui.newHeader ? ui.newHeader.context : null;
	    if (context) {
		var languageCode = context.getAttribute('data-lc');
		if (languageCode !== null) {
		    window.location.hash = languageCode;
		}
	    }
	}
        // jQuery UI "accordion" element initialization
	$(".jquery-ui-accordion").accordion({
	    collapsible: true,
	    active: false,
	    change: accordionChange
	});
	if ($(".jquery-ui-accordion").length) {
	    var matches = window.location.hash.match(/^\#(.*)$/);
	    console.log(matches);
	    if (matches !== null) {
		var languageCode = matches[1];
		var tab = $('[data-lc="'+languageCode+'"]');
		// the following will only work after accordion is initialized
		var index = $('.jquery-ui-accordion div.ui-accordion-header').index(tab);
		if (index !== -1) {
		    $(".jquery-ui-accordion").accordion({ active: index });
		}
	    }
	}
    };

    var setupTimeago = function() {
        jQuery("time.timeago").timeago();
    };

    var setupTabs = function() {
        // standard jQuery UI "tabs" element initialization
        $(".jquery-ui-tabs").tabs({ heightStyle: "auto" });

        // use jQuery address to preserve tab state
        // (see https://github.com/UniversalDependencies/docs/issues/65,
        // http://stackoverflow.com/a/3330919)
        if ($(".jquery-ui-tabs").length > 0) {
            $.address.change(function(event){
	        $(".jquery-ui-tabs").tabs("select", window.location.hash)
	    });
	    $(".jquery-ui-tabs").bind("tabsselect", function(event, ui) { 
	        window.location.hash = ui.tab.hash;
	    });
        }
    };

    head.ready(function() {
        // set up UI tabs on page
        setupTabs();
        setupAccordions();
        setupTimeago();

        // mark current collection (filled in by Jekyll)
        Collections.listing['_current'] = 'cs-overview';

	// perform all embedding and support functions
	Annodoc.activate(Config.bratCollData, Collections.listing);
    });
</script>


<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55233688-1', 'auto');
  ga('send', 'pageview');

</script>


      <div id="footer">
	  <p class="footer-text">&copy; 2014 
	    <a href="http://universaldependencies.org/introduction.html#contributors" style="color:gray">Universal Dependencies contributors</a>. 
	    Site powered by <a href="http://spyysalo.github.io/annodoc" style="color:gray">Annodoc</a> and <a href="http://brat.nlplab.org/" style="color:gray">brat</a></p>.
      </div>
    </div>
  </body>
</html>
