<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Syntax</title>
    <link rel="root" href=""/> <!-- for JS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="../../css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style-vis.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/hint.css"/>
    <script type="text/javascript" src="../../lib/ext/head.load.min.js"></script>
    <script type="text/javascript" src="../../lib/ext/jquery.timeago.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.2.2/anchor.min.js"></script>
    <script>document.addEventListener("DOMContentLoaded", function(event) {anchors.add();});</script>
    <!-- Set up this custom Google search at https://cse.google.com/cse/business/settings?cx=001145188882102106025:dl1mehhcgbo -->
    <script>
      (function() {
        var cx = '001145188882102106025:dl1mehhcgbo';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->


  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
        <table width="100%"><tr><td width="50%">
          <span class="header-text"><a href="http://universaldependencies.org/#language-en">home</a></span>

          <span class="header-text"><a href="https://github.com/universaldependencies/docs/edit/pages-source/_en-overview/specific-syntax.md" target="#">edit page</a></span>
          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
        </td><td>
          <gcse:search></gcse:search>
        </td></tr></table>
      </div>

      <hr/>

      
      <div class="v1warning">
	This page still pertains to UD version 1.
      </div>
      
      
      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          <h1 id="specific-constructions">Specific constructions</h1>

<h2 id="core-clausal-syntax-predicates-and-their-arguments">Core clausal syntax: predicates and their arguments</h2>

<h3 id="predicates">Predicates</h3>

<p>Main predicates in English are most often verbs, but they can also be adjectives, nouns and even adverbs. In UD, predicates are labeled with one of the clausal relations: <code>root</code>, <code>ccomp</code>, <code>xcomp</code>, <code>advcl</code>, <code>acl</code> (and its subtypes); or one of the loose-joining relations, <code>conj</code> and <code>parataxis</code>, under a head that has a clausal label.</p>

<pre><code class="language-sdparse">-ROOT- When you work on something that long , it 's impossible not to get attached to it , I think .
advcl(impossible, work)
xcomp(get, attached)
parataxis(get, think)
root(-ROOT-, impossible)
</code></pre>

<p>Any dependent that can be said to attach at the clausal level (for example, core arguments, adverbial modifiers, complementizers, or conjoined clauses) will have the predicate word as its head.</p>

<p>UD does not distinguish light verbs from full verbs.</p>

<pre><code class="language-sdparse">I 'm going to take a nap .
nsubj(take, I)
dobj(take, nap)
</code></pre>

<h4 id="copulas">Copulas</h4>

<p>This is true even in the case of nonverbal predicates, which is a distinguishing feature of Universal Dependencies. This is evident in the UD treatment of copulas.</p>

<pre><code class="language-sdparse">I think this is very interesting .
ccomp(think, interesting)
nsubj(interesting, this)
</code></pre>

<p>Here, the head of <em>this</em> is <em>interesting</em>, because <code>nsubj</code>-labeled dependents attach at the clausal level, and the head of the lower clause is the adjective <em>interesting</em>. Similarly, it is the predicate that receives the clausal label <code>ccomp</code>.</p>

<p>In equative uses of copulas, the distinction between predicate ans subject is somewhat arbitrary. In those cases, linear order is used as a cue: the subject is taken to appear first.</p>

<p>In some of these equative uses, the right-hand side may be a clause, finite or not. In those cases, exceptionally, the copular verb is treated as the predicate, and the clause is given attached to it, with the <code>ccomp</code> label.</p>

<pre><code class="language-sdparse">-ROOT- The problem is that these sentences are very difficult to analyze .
root(-ROOT-, is)
ccomp(is, difficult)
</code></pre>

<h4 id="nonverbal-predicates-with-no-copular-verb">Nonverbal predicates with no copular verb</h4>

<p>The treatment UD adopts for copulas is consistent with its treatment of small clauses. In a surprisingly wide range of constructions in English, a nonverbal predicate forms a constituent with its core arguments without any mediating verb. These constructions are directly parallel to copulas in the UD scheme, since copular verbs do not mediate relations between nonverbal predicates and their dependents.</p>

<p>In some of these constructions, one might argue that there is an ellided copular verb. We make no attempt to represent such a verb, with no cost to the dependency analysis.</p>

<pre><code class="language-sdparse">Email usually free if you use a wifi connection .
nsubj(free, Email)
</code></pre>

<pre><code class="language-sdparse">If you take him here for shots, no big deal .
advcl(deal, take)
</code></pre>

<pre><code class="language-sdparse">The attack killed 600 Iraqis , most of them women and children .
acl(Iraqis, women)
conj(women, children)
nsubj(women, most)
</code></pre>

<p>In other cases, such as the constructions sometimes called <strong>absolute</strong>, it is harder to argue that there is an ellided verb. The analysis is still parallel to that of other nonverbal predicates, and to that of absolute constructions with nonfinite verbal predicates.</p>

<pre><code class="language-sdparse">The year was bad news for animals , with many species now close to extinction .
advcl(news, close)
nsubj(close, species)
mark(close, with)
advmod(close, now)
</code></pre>

<pre><code class="language-sdparse">NASA is planning on using these shuttles , with industry forecasters predicting a launch as early as 2014 .
advcl(planning, predicting)
nsubj(predicting, forecasters)
mark(predicting, with)
</code></pre>

<h3 id="core-arguments">Core arguments</h3>

<p>UD makes a distinction between core arguments and other dependents of predicates. In English, the UD relations that can designate core arguments are <code>nsubj</code>, <code>nsubjpass</code>, <code>obj</code> and <code>iobj</code> for nominal arguments, and <code>ccomp</code>, <code>xcomp</code>, <code>csubj</code> and <code>csubjpass</code> for clausal arguments.</p>

<p><code>nsubj</code> and <code>nsubjpass</code> are used for external arguments of any predicate (as in the examples above); the only difference is that <code>nsubjpass</code> is used in passive-voice clauses.</p>

<pre><code class="language-sdparse">Unsafe cars sold here !
nsubjpass(sold, cars)
</code></pre>

<p>In the above example, it is important to mention that a plausible alternative representation would analyze this as a nominal phrase with a reduced relative. However, when possible, we prefer to choose a predicate as the root of a sentence.</p>

<pre><code class="language-sdparse">Messages will not be delivered simultaneously .
nsubjpass(delivered, Messages)
</code></pre>

<p>Expletives can occur in subject or object position, and are represented with the label <code>expl</code>.</p>

<pre><code class="language-sdparse">It is raining .
expl(raining, It)
</code></pre>

<pre><code class="language-sdparse">It was Joseph Goebbels who said that .
expl(Goebbels, It)
</code></pre>

<pre><code class="language-sdparse">I find it best not to think about that .
ccomp(find, think)
expl(find, it)
xcomp(find, best)
</code></pre>

<p>Expletives can have a subject-labeled sister.</p>

<pre><code class="language-sdparse">There is dinner in the fridge .
expl(is, There)
nsubj(is, dinner)
</code></pre>

<p>The internal argument labels, <code>obj</code> and <code>iobj</code>, are exclusive to verbal predicates and a handful of adjectives (namely: <em>worth</em>, <em>like</em> and <em>unlike</em>, following Huddleston and Pullum (2001)).</p>

<p>The distinction between <code>obj</code> and <code>iobj</code> is strictly syntactic; <code>iobj</code> is reserved for “second objects” with restricted theta-roles, and is relatively rare in English. Only when another internal argument is present can <code>iobj</code> occur.</p>

<pre><code class="language-sdparse">They gave me the trip as a gift.
iobj(gave, me)
dobj(gave, trip)
</code></pre>

<p>The other internal argument need not be nominal. In English, some verbs can take a nominal complement and a clausal complement together. In the case of these verbs, the nominal complement is always thematically restricted, which suggests it is an <code>iobj</code> serving as a “second object” to the clausal complement. For that reason, the clausal complement label <code>ccomp</code> never cooccurs with <code>obj</code>, but does cooccur with <code>obj</code>.</p>

<pre><code class="language-sdparse">I told them that I 'm planning to come visit .
ccomp(told, planning)
iobj(told, them)
</code></pre>

<p>However, the same observation does not hold of verbs that take open complements, labeled <code>xcomp</code> (more on this label below). Those can clearly cooccur with thematically unrestricted objects under some verbs. For that reason, nominal complements cooccuring with <code>xcomp</code> are uniformly labeled <code>obj</code>, and never <code>iobj</code>.</p>

<pre><code class="language-sdparse">I told them to expect my visit.
dobj(told, them)
xcomp(told, expect)
</code></pre>

<h4 id="clausal-core-arguments">Clausal core arguments</h4>

<p>Like other clausal labels, the clausal core argument labels apply to finite and nonfinite clauses without distinction. (In English <code>xcomp</code> can only be applied to nonfinite clauses because there is no control into finite clauses; but this is not part of the definition of <code>xcomp</code>.)</p>

<p>The distinction between <code>csubj</code> and <code>csubjpass</code> mirrors that between <code>nsubj</code> and <code>nsubjpass</code>.</p>

<pre><code class="language-sdparse">Islamists may disagree on whether killing innocents is sanctioned by the laws of jihad .
csubjpass(sanctioned, killing)
</code></pre>

<pre><code class="language-sdparse">Whether or not you pick them up again is probably a question of practice .
csubj(question, pick)
</code></pre>

<p>The clausal subject labels apply to verbal as well as nonverbal predicates.</p>

<pre><code class="language-sdparse">On the side is a waste , leave it on the bottom .
csubj(waste, side)
cop(waste, is)
</code></pre>

<p>Much like <code>nsubj(pass)</code>, <code>csubj(pass)</code> can (and often does) cooccur with an expletive.</p>

<pre><code class="language-sdparse">It is rare to find a company with such nice workers .
expl(rare, It)
csubj(rare, find)
</code></pre>

<p>Clausal core arguments are restricted to verbal and adjectival predicates. Nouns never take clausal core arguments. (See [](#### Clausal modifiers of nouns) for how to represent clausal dependents of nouns.)</p>

<h4 id="functional-control">Functional control</h4>

<p>The label <code>xcomp</code> is used for predicates whose external argument is <em>controlled</em> by an argument of a higher clause. This applies in multiple types of constructions (often referred to as “small clauses”): <em>raising</em>, <em>obligatory control</em>, <em>resultatives</em> (obligatory and optional alike) and <em>obligatory depictives</em>.</p>

<pre><code class="language-sdparse">The cat seems to be in pain .
nsubj(seems, cat)
xcomp(seems, be)
</code></pre>

<pre><code class="language-sdparse">Convince your parents to let you get a pet .
dobj(Convince, parents)
xcomp(Convince, let)
dobj(let, you)
xcomp(let, get)
</code></pre>

<pre><code class="language-sdparse">Put an oily sauce on the food to make it moist .
dobj(make, it)
xcomp(make, moist)
</code></pre>

<pre><code class="language-sdparse">The pond froze solid .
nsubj(pond, froze)
xcomp(froze, solid)
</code></pre>

<pre><code class="language-sdparse">She thinks it looks artistic .
nsubj(looks, it)
xcomp(looks, artistic)
</code></pre>

<p>This includes copula-like English verbs such as <em>become</em>, <em>remain</em>.</p>

<pre><code class="language-sdparse">I became very upset .
nsubj(became, I)
xcomp(became, upset)
</code></pre>

<h3 id="noncore-arguments-and-predicate-modifiers">Noncore arguments and predicate modifiers</h3>

<p>UD marks core arguments, but it does not make a distinction between noncore arguments and modifiers of a predicate. In English, noncore arguments are introduced by prepositions or subordinating conjunctions (which largely overlap with each other). Optional modifiers can also be introduced by such words. In UD, the representation of noncore arguments and predicate modifiers, while distinct from that of core arguments, is uniform. The entire set will be referred to here as <em>noncore dependents</em>.</p>

<p>Noncore dependents are classified by their syntactic properties. Nominal dependents (i.e., phrases whose lexical head is a noun) are labeled <code>nmod</code>. Most of these, in English, are introduced by prepositions.</p>

<pre><code class="language-sdparse">My parents lived in England in the 1980s .
nmod(lived, England)
nmod(lived, 1980s)
</code></pre>

<p>In the example above, note that <em>in England</em> and <em>in the 1980s</em> are annotated with the same label, even though the former is arguably a noncore argument of <em>live</em>, while the latter is certainly not.</p>

<p>Bare nominals receive the label <code>nmod:npmod</code>, which is an English-specific relation.</p>

<pre><code class="language-sdparse">I am 3 blocks west of Broadway .
nmod:npmod(west, blocks)
</code></pre>

<pre><code class="language-sdparse">The price of crude oil advanced 53 cents .
nmod:npmod(advanced, cents)
</code></pre>

<p>More narrowly, bare nominals denoting a point in time receive the label <code>nmod:tmod</code>, also English-specific.</p>

<pre><code class="language-sdparse">The company will be making an announcement this year that formalizes the relationship.
nmod:tmod(company, year)
</code></pre>

<p>Clausal noncore dependents, whether finite or nonfinite, receive the label <code>advcl</code>.</p>

<p>This label can also apply to nonverbal predicates, as shown in this example (repeated from [](#### Nonverbal predicates with no copular verb)).</p>

<pre><code class="language-sdparse">The year was bad news for animals , with many species now close to extinction .
advcl(news, close)
nsubj(close, species)
mark(close, with)
advmod(close, now)
</code></pre>

<pre><code class="language-sdparse">I know what they are , so no suggestions on just going out to buy one .
advcl(know, suggestions)
</code></pre>

<p>In the example above, an alternative analysis might represent <em>no suggestions</em> as a nominal dependent. However, we take the presence of <em>so</em>, which usually attaches to predicates, as evidence of clausal status.</p>

<h3 id="function-words-attaching-to-predicates">Function words attaching to predicates</h3>

<p>The labels <code>mark</code>, <code>aux</code>, <code>auxpass</code> and <code>cop</code> are used for function words that attach to predicates. While in some linguistic theories these are argued to be heads of constituents, in UD they are demoted to dependents of lexical heads, in line with the principle of primacy of content words.</p>

<p>These function words do not normally have dependents, but there are exceptions. They may have word-level dependents; they may also be coordinated (on the surface, due to VP-ellipsis), and have conjunction and conjunct dependents.</p>

<pre><code class="language-sdparse">We can and will get to the bottom of this .
aux(get, can)
cc(can, and)
conj(can, will)
</code></pre>

<p>Unfortunately, not all conjunctions of function words attaching to predicates lend themselves of this analysis, which leads to a lack of parallelism across some constructions. In the following example, the first conjunct receives a promotion-by-head-ellision treatment.</p>

<pre><code class="language-sdparse">-ROOT- This change has been and will be taken to provide focus for the project .
root(-ROOT-, has)
auxpass(has, been)
cc(has, and)
conj(has, taken)
</code></pre>

<h4 id="complementizers-subordinating-conjunctions-and-the-infinitival-marker">Complementizers, subordinating conjunctions and the infinitival marker</h4>

<p>In English, the label <code>mark</code> applies uniformly to complementizers, subordinating conjunctions and the infinitival marker.</p>

<pre><code class="language-sdparse">Remember that the occupation is ephemeral .
mark(ephemeral, that)
</code></pre>

<pre><code class="language-sdparse">They already have rights to take it .
mark(take, to)
</code></pre>

<pre><code class="language-sdparse">Probably just gon na kick it .
mark(kick, na)
</code></pre>

<pre><code class="language-sdparse">This gives the company a way of influencing and anticipating the direction of change .
mark(influencing, of)
</code></pre>

<pre><code class="language-sdparse">A warming of the magnitude predicted is more likely than not to be beneficial .
mark(not, than)
</code></pre>

<pre><code class="language-sdparse">Bush spent little time reviewing capital punishment cases while governor of Texas .
mark(governor, while)
</code></pre>

<h4 id="copular-verbs">Copular verbs</h4>

<pre><code class="language-sdparse">I think this is very interesting .
ccomp(think, interesting)
nsubj(interesting, this)
</code></pre>

<p>The copular verb <em>be</em> is treated as a function word: it is attached to the predicate and labeled <code>cop</code>, a special label for copular verbs. In English, only <em>be</em> receives this treatment. See [](#### Functional control) for copula-like verbs such as <em>become</em>.</p>

<h4 id="auxiliaries">Auxiliaries</h4>

<p>Modal and auxiliary verbs are uniformly labeled as <code>aux</code> or <code>auxpass</code> in UD, and attached to their main verb. (When there is no main verb, the auxiliary is promoted by head ellision.) This is the case even when there are multiple auxiliaries; rather than chained together to reflect scope properties, they are flatly attached to the main verb.</p>

<p>The <code>auxpass</code> label applies only to passive auxiliaries.</p>

<pre><code class="language-sdparse">By that time , Elena 's story would have been revealed to be a fake .
aux(revealed, would)
aux(revealed, have)
auxpass(revealed, been)
</code></pre>

<p>The verb <em>get</em> can behave as a passive auxiliary, and when it does, it is annotated as such.</p>

<pre><code class="language-sdparse">I got put on hold twice .
auxpass(put, got)
nsubjpass(put, I)
</code></pre>

<h2 id="below-the-clause">Below the clause</h2>

<h3 id="word-level-dependents-complex-lexical-units">Word-level dependents: complex lexical units</h3>

<p>While most types of dependents can be said to attach to phrases (i.e., <code>nsubj</code> dependents attach to verbal phrases; <code>det</code> dependents attach to noun phrases), some attach only at the word level. These types of dependencies form complex lexical units which then enter, as a composite, dependencies of their own.</p>

<p>Three relations can be used to form complex lexical units. The most straightforward one is <code>goeswith</code>, which can be used between any two tokens and serves to indicate that, as a result of input error, a single orthographic word is split into two space-separated tokens in the data.</p>

<pre><code class="language-sdparse">I felt as if I was in an over priced Olive Garden .
goeswith(priced, over)
</code></pre>

<p>The other two relations, <code>fixed</code> and <code>compound</code>, are more interesting. The main difference between them is that <code>fixed</code> applies between function words and other function words or lexical words, while <code>compound</code> applies only between lexical words.</p>

<p>The <code>fixed</code> relation is used sparingly. In general, the relation is used in grammaticalized uses of two or more function words together, often giving rise to noncompositional meaning. Since words joined by the <code>fixed</code> relation often have equal claim to the status of head, any such construction is, by convention, head-initial.</p>

<pre><code class="language-sdparse">How come no one bothers to ask any questions in this section ?
mwe(How, come)
advmod(bothers, How)
</code></pre>

<pre><code class="language-sdparse">I just kind of sat there .
mwe(kind, of)
advmod(sat, kind)
</code></pre>

<pre><code class="language-sdparse">You have to wait , due to financial reasons .
mwe(due, to-7)
case(reasons, due)
</code></pre>

<p>When the multiword expression is composed of more than two words, all non-head words attach directly to the head, in a flat structure.</p>

<p>Decisions about what should be annotated as a multiword expression are difficult due to the fact that such expressions exist in a continuous spectrum between phrases built via fully productive rules on the one hand, and fixed lexicalized expressions on the other. A series of criteria can be used to rule out the <code>fixed</code> label: optionality of one word in the construction; meaning compositionality;  availability of variants in which one of the words is substituted.</p>

<p>The <code>compound</code> relation, on the other hand, can be used freely to represent productive phrase-building. The difference is that <code>compound</code> is used when a string of words joined together are analyzed as a single lexical unit that behaves as a head (i.e., an X^0 node) rather than as a constituent (i.e., an XP node) in the sentence.</p>

<pre><code class="language-sdparse">Most of those making charges flip - flopped .
compound(flopped, flip)
</code></pre>

<pre><code class="language-sdparse">The duck breast was really good .
compound(breast, duck)
</code></pre>

<pre><code class="language-sdparse">There is a pool for the potty - trained children .
compound(trained, potty)
</code></pre>

<p>A distinguished type of compound is the English particle verb. Particles that combine with verbs receive the language-specific label <code>compound:prt</code>.</p>

<pre><code class="language-sdparse">What time are you going to pick me up ?
compound:prt(pick, up)
</code></pre>

<p>Unlike multiword expressions, compounds can have inner structure, when appropriate.</p>

<pre><code class="language-sdparse">The therapeutic agents under discussion include oolong tea extract .
compound(tea, oolong)
compound(extract, tea)
</code></pre>

<h3 id="the-nominal-domain-nominal-and-prepositional-phrases">The nominal domain: nominal and prepositional phrases</h3>

<p>Nominal and prepositional phrases are uniformly organized around their nominal lexical head in UD. In addition to their argument roles, labeled <code>nsubj</code>, <code>nsubjpass</code>, <code>obj</code> and <code>iobj</code>, nominal phrases can have roles as noncore dependents. In these roles, they are labeled <code>nmod</code> (and subtypes). Commonly, noncore dependents are realized as prepositional phrases.</p>

<h4 id="prepositions">Prepositions</h4>

<p>Within prepositional phrases, prepositions are represented as dependents of their complements and labeled <code>case</code>.</p>

<pre><code class="language-sdparse">Foz on the Brazilian side is the larger town.
nmod(Foz, side)
case(side, on)
</code></pre>

<pre><code class="language-sdparse">Convert into DVD .
nmod(Convert, DVD)
case(DVD, into)
</code></pre>

<p>Nested prepositional phrases are also organized around the single lexical head, in a flat representation parallel to that of verb groups.</p>

<pre><code class="language-sdparse">She ran out of the room .
nmod(ran, room)
case(room, of)
case(room, out)
</code></pre>

<h4 id="possessives">Possessives</h4>

<p>The label <code>case</code> is also used for the genitive <em>’s</em> in English. The genitive nominal phrase receives the language-specific label <code>nmod:poss</code>.</p>

<pre><code class="language-sdparse">Tomorrow is Mother 's Day .
nmod:poss(Mother, Day)
case(Mother, 's)
</code></pre>

<p>The <code>nmod:poss</code> label is also used for possessive determiners.</p>

<pre><code class="language-sdparse">That 's your prerogative .
nmod:poss(prerogative, your)
</code></pre>

<p>This possessive modifier analysis is also used for genitives attaching to gerunds.</p>

<pre><code class="language-sdparse">I appreciate your coming here .
nmod:poss(coming, your)
</code></pre>

<h4 id="determiners">Determiners</h4>

<p>In addition to <code>case</code>, the label <code>det</code> and its language-specific extension <code>det:predet</code> also designate function-word dependents of nominal heads. These labels are used for determiners: definite and indefinite articles, demonstrative determiners, quantifiers such as <code>all</code>, <code>some</code>, <code>every</code> and <code>each</code>.</p>

<pre><code class="language-sdparse">I did find this website .
det(website, this)
</code></pre>

<p>Floating quantifiers are attached to the nominal head they modify.</p>

<pre><code class="language-sdparse">The five companies that made the short list all proposed structural changes .
det(companies, all)
</code></pre>

<p>In some English constructions, pronouns can cooccur with nominal heads and exhibit determiner-like behavior. In those constructions, these pronouns are annotated as <code>det</code>.</p>

<pre><code class="language-sdparse">You guys do everything wonderful !
det(guys, You)
</code></pre>

<pre><code class="language-sdparse">She is a disgrace to the rest of us Pet Smart associates .
det(associates, us)
</code></pre>

<p>The label <code>det:predet</code> applies when a determiner is present, and preceding it is another determiner.</p>

<pre><code class="language-sdparse">All the girls were totally shocked .
det(girls, the)
det:predet(girls, All)
</code></pre>

<pre><code class="language-sdparse">What an amazing group !
det:predet(group, What)
det(group, an)
</code></pre>

<p>The label can only apply when <code>det</code> is also present.</p>

<pre><code class="language-sdparse">All girls were totally shocked .
det(girls, All)
</code></pre>

<p>Determiners with negative meaning receive the label <code>neg</code> instead of <code>det</code>.</p>

<pre><code class="language-sdparse">I have no inside information .
neg(information, no)
</code></pre>

<h4 id="appositives">Appositives</h4>

<h3 id="optional-modifiers-adverbial-and-adjectival-phrases">Optional modifiers: adverbial and adjectival phrases</h3>

<p>Both predicates and nominals can be modified by optional phrases – adverbial and adjectival, respectively. Again, a distinction is made between clausal and nonclausal dependents. Adverbial clauses are labeled <code>advcl</code>. Adjectival clauses (of which relative clauses are a subtype) are labeled <code>acl</code>. Nonclausal adverbials are labeled <code>advmod</code>, and nonclausal adjectivals are labeled <code>amod</code>.</p>

<h4 id="clausal-modifiers-of-nouns">Clausal modifiers of nouns</h4>

<p>Relative clauses are the canonical case of clausal modifiers of nouns, and they receive a special language-specific label, <code>acl:relcl</code>. In these clauses, the relative pronoun is analyzed in the function it takes in the lower clause, as illustrated here by <em>that</em>, labeled <code>nsubj</code>, and <em>which</em>, labeled <code>nmod</code>.</p>

<pre><code class="language-sdparse">These links present the many viewpoints that existed .
acl:relcl(viewpoints, existed)
nsubj(existed, that)
</code></pre>

<pre><code class="language-sdparse">Archibald says the frequency with which the subject was discussed was off-putting .
acl:relcl(frequency, discussed)
nmod(discussed, which)
case(which, with)
</code></pre>

<p>The <code>acl:relcl</code> relation is also used in free relatives; see <a href="#free-relatives">the section on free relatives</a>.</p>

<p>Relatives clauses are not, however, the only type of clausal modifiers of nouns. For one example, reduced relative clauses are not typed <code>acl:relcl</code>, but rather <code>acl</code>.</p>

<pre><code class="language-sdparse">There are many online sites offering booking facilities .
acl(sites, offering)
</code></pre>

<pre><code class="language-sdparse">I have a parakeet named cookie .
acl(parakeet, named)
</code></pre>

<p>Additionally, many optional clausal dependents on nominals receive the <code>acl</code> label.</p>

<pre><code class="language-sdparse">These are the issues as I see them .
acl(issues, see)
</code></pre>

<pre><code class="language-sdparse">I just want a simple way to get my discount .
acl(way, get)
</code></pre>

<p><em>Depictives</em> are also represented with the <code>acl</code> relation.</p>

<h4 id="quantifier-phrases">Quantifier phrases</h4>

<p>The notion of <em>quantifier phrase</em> is applied loosely here to a variety of structures that modify nominals. The simplest type is probably simple numerical adjectives, which are labeled <code>nummod</code>.</p>

<pre><code class="language-sdparse">I don 't want to spend more than 20 dollars .
nummod(dollars, 20)
</code></pre>

<p>Often some form of modification is applied to these numerical dependents, in the form of expressions such as <em>more than</em> (which is considered a multiword expression), <em>about</em>, <em>over</em>. These are analyzed as dependents of the numerical modifier, forming a complex quantifier phrase.</p>

<pre><code class="language-sdparse">I don 't want to spend more than 20 dollars .
nummod(dollars, 20)
advmod(20, more)
mwe(more, than)
</code></pre>

<p>Ranges are also treated as numerical dependents. Note that in this case the dash <em>-</em> is represented as a preposition, because it is a functional equivalent of <em>to</em> (as becomes clear from the fact that it is normally read that way).</p>

<pre><code class="language-sdparse">In just 2 - 3 focused lessons , you will be ready .
nummod(lessons, 2)
nmod(2, 3)
case(3,-)
</code></pre>

<h2 id="beyond-the-clause">Beyond the clause</h2>

<p>Beyond core clausal structures, there are many linguistic constructions, usually with discourse functions, that need to be represented in a complete dependency tree. Additionally, complex structures such as coordination and juxtaposition of structures in the same ortographical sentence need to be analyzed. Finally, written communication includes a wealth of information that is structured by rules that exist at the fringes of (or perhaps outside) the grammar of a language. In order to provide a complete representation, we integrate even that information into syntax trees, leading to some special dependency labels, and some peculiar annotation conventions.</p>

<h3 id="discourse-level-dependents">Discourse-level dependents</h3>

<p>UD introduces two special relations for discourse-level dependents: <code>discourse</code>, which is used to type a limited range of discourse markers, and the informatively named <code>vocative</code>, which is used for vocatives. These always attach to predicates, not because they modify them directly, but to express the fact that they have the highest-possible level of attachment.</p>

<pre><code class="language-sdparse">Malach , what say makes sense .
vocative(Malach, makes)
</code></pre>

<pre><code class="language-sdparse">Okay , it 's partly about strippers .
discourse(strippers, Okay)
</code></pre>

<pre><code class="language-sdparse">Morcillas is coagulated blood from animals , ewww .
discourse(blood, ewww)
</code></pre>

<pre><code class="language-sdparse">Can somebody please list ALL the food ?
discourse(list, please)
</code></pre>

<pre><code class="language-sdparse">Of course you can .
discourse(can, Of)
mwe(Of, course)
</code></pre>

<h3 id="coordination-and-loose-joining">Coordination and loose joining</h3>

<p>Coordination is, in a sense, below as well as beyond the clause, since it can occur at any level. But that property is exactly what distinguishes it, and justifies placing it outside of core clausal syntax.</p>

<p>The difficulty of representing coordination, which is symmetrical, with an inherently-asymmetric dependency representation is well-known. UD makes no attempt to disguise this, and adopts first conjuncts, by convention, as the heads of coordinated phrases. Any other conjuncts and conjunctions are attached to that first conjunct.</p>

<pre><code class="language-sdparse">The elated bride and groom danced and sang songs .
cc(bride, and-4)
conj(bride, groom)
cc(danced, and-7)
conj(danced, sang)
amod(bride, elated)
dobj(sang, songs)
</code></pre>

<p>This creates some ambiguities: it is not possible to tell, from the representation alone, whether <em>elated</em> modified <em>bride</em> only, or <em>bride and groom</em>. Conversely, it is clear that <em>songs</em> is an object only of <em>sang</em>, since it attaches to that verb directly rather than to the head of the conjunction, which is <em>danced</em>. A change in the ordering of these constituents can introduce that ambiguity.</p>

<pre><code class="language-sdparse">The elated bride and groom sang songs and danced .
cc(sang, and)
conj(sang, danced)
dobj(sang, songs)
</code></pre>

<p>Another (much less frequent) difficulty is the representation of nested coordinations, which is not always possible. In the following example, the heterogeneous coordination of <em>incarcerated</em>, <em>on probation</em> and <em>on parole</em> forms a complex predicate for the first verbal phrase in this sentence. That first VP is then itself coordinated with <em>once were in one of those categories</em>. The fact that there are two levels of coordination does not come through in the UD representation.</p>

<pre><code class="language-sdparse">Approximately 10 million Americans are incarcerated , on probation , on parole , or once were in one of those categories ?
cop(incarcerated, are)
conj(incarcerated, probation)
conj(incarcerated, parole)
conj(incarcerated, one)
cop(were, one)
nmod(one, categories)
</code></pre>

<p>The auxiliaries <em>have</em> and <em>be</em> occasionally appear outside of coordinated predicates having a different function with respect to each predicate, as shown below. In such cases, we annotate the verb only as a dependent of the first conjunct.</p>

<pre><code class="language-sdparse">The toilet seat was peeling and rough .
conj(peeling, rough)
cc(peeling, and)
nsubj(peeling, seat)
aux(peeling, was)
</code></pre>

<p>In this sentence, <em>was</em> is also a <code>cop</code> dependent of <em>rough</em>, but that edge is not represented.</p>

<h4 id="conjunctions">Conjunctions</h4>

<h4 id="loose-joining-parataxis-and-list">Loose joining: parataxis and list</h4>

<h3 id="special-annotation-conventions">Special annotation conventions</h3>

<h4 id="dates-times-addresses">Dates, times, addresses</h4>

<h4 id="contact-information">Contact information</h4>

<h4 id="itemizations">Itemizations</h4>

<h2 id="specific-constructions-1">Specific constructions</h2>

<h3 id="unpronounced-material">Unpronounced material</h3>

<h4 id="vp-ellipsis-and-related">VP ellipsis (and related)</h4>

<p>While auxiliaries are normally not analyzed as being heads, when a verb has been elided from VP ellipsis, the auxiliary inherits the head-status. This includes the <em>to</em> nonfinite auxiliary.</p>

<pre><code class="language-sdparse">Mary did n't leave , John did
parataxis(leave, did-7)
nsubj(did-7, John)
</code></pre>

<pre><code class="language-sdparse">So please update whatever you need to
dobj(update, whatever)
acl:relcl(whatever, need)
xcomp(need, to)
</code></pre>

<p>Similarly, when a preposition is stranded in a passive construction, the preposition receives the <code>nmod</code> label on account of lacking a nominal head.</p>

<pre><code class="language-sdparse">That matter was talked about in detail already
nmod(talked, about)
</code></pre>

<h4 id="gapping--stripping">Gapping / Stripping</h4>

<p>In ‘gapping’ constructions, where the head of a clause has been elided but two arguments that contrast with arguments in the antecedent clause remain, and ‘stripping’ constructions, where the head of a clause has been elided but one contrasting argument and one polarity adverbial such as <em>not</em> or <em>only</em> remain, the <code>orphan</code> relation is used between the remaining constituents and the words they contrast with:</p>

<pre><code class="language-sdparse">it took another 20 mins to get our orders and a further 45 mins till our starters landed on our table.
cc(took, and)
remnant(mins-5, mins-14)
remnant(get-7, landed-18)
</code></pre>

<pre><code class="language-sdparse">" Commander in Chief " does n't mean that he is the boss of the military , merely that he is the Administrator
remnant(n't, merely)
remnant(boss, Administrator)
</code></pre>

<pre><code class="language-sdparse">He 's not against gays in the bedroom , just at the altar
remnant(not, just)
remnant(bedroom, altar)
</code></pre>

<p>When an argument is ‘sprouted’–present in the second clause with no antecedent–it depends on the head of the antecedent clause.</p>

<pre><code class="language-sdparse">" Commander in Chief " means that he is the Administrator of the military , not the boss
remnant(means, not)
remnant(Administrator, boss)
</code></pre>

<h4 id="right-node-raising">Right-node raising</h4>

<p>In right-node raising constructions where the head of the left conjunct has been elided under identity with the head of the second conjunct, the right conjunct undergoes “promotion by head elision”, and gains the label that would be assigned to the head if it had been present.</p>

<pre><code class="language-sdparse">-ROOT- Iguazu is a big or a small country ?
root(-ROOT-, big)
cc(big, or)
conj(big, country)
</code></pre>

<pre><code class="language-sdparse">-ROOT- I have never been and I will never be a government official
root(-ROOT-, been)
neg(been, never-4)
aux(been, have)
nsubj(been, I-2)
cc(been, and)
neg(official, never-9)
aux(official, will)
nsubj(official, I-7)
conj(been, official)
</code></pre>

<h4 id="marginal-disfluencies">Marginal disfluencies</h4>

<p>In informal language usage, nonstandard constructions and disfluencies sometimes arise. When this involves a gapping-like construction–with one or more contrasting arguments that depend on an absent head–the remnant relation should be used.</p>

<pre><code class="language-sdparse">The letters were to different AMI publications -- one to the National Enquirer and another to The Sun
cc(were, --)
remnant(--, and)
remnant(letters, one)
remnant(publications, Enquirer)
remnant(one, another)
remnant(Enquirer, Sun)
</code></pre>

<p>If, however, the second clause is largely unparallel to the first clause, a different relation should be used (<code>conj</code> or <code>parataxis</code> if the smaller clause is not obviously modifying the larger one, <code>acl</code> or <code>advcl</code> otherwise)</p>

<pre><code class="language-sdparse">Too bad you wo n't make the Compaq thing , but maybe next year
conj(make, year)
cc(make, but)
</code></pre>

<pre><code class="language-sdparse">31 -- Number of Bush administration employees ... ( includes four cabinet secretaries , the six most powerful ... )
acl(Number, includes)
</code></pre>

<h3 id="resultatives-and-depictives">Resultatives and depictives</h3>

<h4 id="resultatives">Resultatives</h4>

<p>Resultatives–predicate arguments of verbs that indicate how another argument of the verb has changed–are considered to be arguments, and therefore receive the <code>xcomp</code> relation instead of a modifier one.</p>

<pre><code class="language-sdparse">-ROOT- He painted the barn red .
root(-ROOT-, painted)
dobj(painted, barn)
xcomp(painted, red)
</code></pre>

<pre><code class="language-sdparse">-ROOT- He made them martyrs .
root(-ROOT-, made)
dobj(made, them)
xcomp(made, martyrs)
</code></pre>

<pre><code class="language-sdparse">-ROOT- The terrorists stormed the church and took the priests hostage
root(-ROOT-, stormed)
conj(stormed, took)
dobj(took, priests)
xcomp(took, hostage)
</code></pre>

<h4 id="depictives">Depictives</h4>

<p>[&lt;!&gt; May be subject to change]</p>

<p>Depictives are generally subject-less modifiers of predicates–consequently, they should be analyzed using the <code>advmod</code> relation.
<!---
Should this be `advmod` or `advcl`?
--></p>

<pre><code class="language-sdparse">I still remember him stuttering about " the general " , unable to remember Musharraf 's name
advmod(stuttering, unable)
</code></pre>

<pre><code class="language-sdparse">You can rest assured that it 's not going to go away
advmod(rest, assured)
ccomp(assured, going)
</code></pre>

<pre><code class="language-sdparse">Find attached resume and cover letter
advmod(Find, attached)
dobj(Find, resume)
</code></pre>

<pre><code class="language-sdparse">Attached please find resume and cover letter
advmod(find, Attached)
dobj(find, resume)
</code></pre>

<pre><code class="language-sdparse">Elk in Yellowstone used to browse unmolested
advmod(browse, unmolested)
</code></pre>

<h3 id="tough-constructions"><em>Tough</em>-constructions</h3>

<h4 id="clauses-with-expletives">Clauses with expletives</h4>
<p>In constructions without any dislocation, of the form <em>it is</em> adj <em>to</em> pred, the <em>it</em> is an <code>expl</code>, meaning that the lower predicate must be a <code>csubj</code>.</p>

<pre><code class="language-sdparse">-ROOT- It 's hard to make money in this economy
root(-ROOT-, hard)
expl(hard, It)
cop(hard, 's)
csubj(hard, make)
</code></pre>

<p>This construction can optionally occur with <em>for</em> and a subject; in this case, there are two possible analyses. If the subject is interpreted as experiencing the adjective predicate in some way, then it analysed as an <code>nmod</code> on the higher predicate; otherwise, it is analyzed as being exclusively the subject of the lower clause, and the <em>for</em> is analyzed as being a <code>mark</code>.</p>

<pre><code class="language-sdparse">-ROOT- It was hard for me to solve this problem.
root(-ROOT-, hard)
expl(hard, It)
nmod(hard, me)
case(me, for)
csubj(hard, solve)
</code></pre>

<pre><code class="language-sdparse">-ROOT- It was helpful for John to solve this problem for us.
root(-ROOT-, helpful)
expl(helpful, It)
csubj(helpful, solve)
nsubj(solve, John)
mark(solve, for)
</code></pre>

<h4 id="fronting-in-tough-constructions">Fronting in <em>tough</em>-constructions</h4>

<p>When the subject is not an argument of the higher clause, then the lower clause can displace the expletive.</p>

<pre><code class="language-sdparse">-ROOT- For John to solve this problem for us was helpful
root(-ROOT-, helpful)
csubj(helpful, solve)
nsubj(solve, John)
mark(solve, For)
</code></pre>

<p>When the subject <em>is</em> an argument of the higher clause, the lower verb phrase (in its gerund form) or its object (in its nominative form) can be fronted, displacing the expletive and maintaining its <code>csubj</code> label. In the latter case, the clause is no longer a <code>csubj</code>, being instead analyzed as an <code>xcomp</code>.</p>

<pre><code class="language-sdparse">-ROOT- Solving this problem was hard for me
root(-ROOT-, hard)
nmod(hard, me)
case(me, for)
csubj(hard, Solving)
</code></pre>

<pre><code class="language-sdparse">-ROOT- This problem was hard for me to solve
root(-ROOT-, hard)
nmod(hard, me)
case(me, for)
nsubj(hard, problem)
xcomp(hard, solve)
</code></pre>

<h3 id="dependency-introducing-adverbs">Dependency-introducing Adverbs</h3>

<h4 id="comparatives">Comparatives</h4>
<p>Canonical comparatives are introduced using a comparative adverb (such as <em>more</em>, <em>less</em>, or <em>as</em>) depending on an adjective, and either a clause or prepositional phrase marked with <em>than</em>, which also depends on the adjective. In the clausal case, this normally means that the comparing clause is headed by an auxiliary or copula that has been “promoted by head elision”.</p>

<pre><code class="language-sdparse">Natália is much more intelligent than me
advmod(more, much)
advmod(intelligent, more)
nmod(intelligent, me)
case(me, than)
</code></pre>

<pre><code class="language-sdparse">Natália is much more intelligent than I am
advmod(more, much)
advmod(intelligent, more)
advcl(intelligent, am)
mark(am, than)
</code></pre>

<p>In many cases, the initial comparative adverb has been dropped or incorporated into the adjective.</p>

<pre><code class="language-sdparse">Natália is much smarter than I am
advmod(smarter, much)
advcl(smarter, am)
mark(am, than)
</code></pre>

<p>When the quantity of a noun is being compared, the same rules apply. Normally modifiers of nouns are deemed <code>amod</code>s, but in this construction the comparative marker is an <code>advmod</code> in all cases.</p>

<pre><code class="language-sdparse">Natália has more brains than me
dobj(has, brains)
advmod(brains, more)
nmod(brains, me)
case(me, than)
</code></pre>

<p><em>More than</em> and <em>less than</em>–when not used synonymously with <em>over</em> and <em>under</em> in quantity expressions–complicate matters slightly, since the comparative adverb is being used without the head that it modifies. We use a “promotion by head elision” solution, making the dependent into the head when the head is absent.</p>

<pre><code class="language-sdparse">All my neighbors have more than I do
dobj(have, more)
mark(do, than)
acl(more, do)
</code></pre>

<p>When predicates are compared to predicates or modifiers are compared to modifiers, the comparing phrase is always labeled as an <code>advcl</code>.</p>

<pre><code class="language-sdparse">That question was far more hurtful than tactful
advmod(more, far)
advmod(hurtful, more)
advcl(hurtful, tactful)
mark(tactful, than)
</code></pre>

<pre><code class="language-sdparse">It 's more likely than not to be beneficial .
advmod(likely, more)
advcl(likely, not)
mark(not, than)
xcomp(likely, beneficial)
</code></pre>

<p>When a noun phrase is used to restrict the meaning of a comparative, it gets the <code>npmod</code> dependency label.</p>

<pre><code class="language-sdparse">Natália is about three times more intelligent than me .
advmod(three, about)
nummod(times, three)
npmod(more, times)
advmod(intelligent, more)
nmod(intelligent, me)
case(me, than)
</code></pre>

<pre><code class="language-sdparse">Some birds are laying eggs four to seven days earlier than they did 25 years ago .
nummod(days, four)
nmod(four, seven)
case(seven, to)
npmod(earlier, days)
advmod(laying, earlier)
advcl(earlier, did)
mark(did, than)
</code></pre>

<h4 id="the-more-the-merrier">The more, the merrier</h4>
<p>In English there exists a very peculiar correlative construction exemplified in the sentences <em>the more, the merrier</em> and <em>the faster, the better</em>. Even though both parts of the construction seem equal, suggesting a paratactic relationship between them, it is possible to have the second half be a standard finite clause while the first half remains unchanged, suggesting that the first is actually an adverbial clause depending on the second. For example, the sentence <em>The angrier he became, the funnier it got</em> can be rephrased as <em>It got funnier the angrier he became</em>, suggesting the following structure:</p>

<pre><code class="language-sdparse">The more , the merrier
advcl(merrier, more)
</code></pre>

<p>The word <em>the</em> in this construction is not serving its usual purpose as definite article (and in fact, historically the construction required it to be in the instrumental case, rather than in a case dictated by the grammatical function of the word it modified), so instead of labeling it <code>det</code> we choose to label it <code>mark</code>.</p>

<pre><code class="language-sdparse">The more , the merrier
advcl(merrier, more)
mark(more, The)
mark(merrier, the)
</code></pre>

<p>The comparative morpheme or adjective can be followed by a clause as well, such as “the more people that show up, the merrier the party will be”. Because the word <em>that</em> can intervene between the comparative word, the strcuture seems most consistent with a relative clause depending on the comparative, so we analyze it as such.</p>

<pre><code class="language-sdparse">The angrier that he became , the funnier that it got .
mark(angrier, The)
relcl(angrier, became)
advmod(became, that-3)
nsubj(became, he)
mark(funnier, the-7)
relcl(funnier, that-9)
aux(that-9, got)
nsubj(that-9, it)
</code></pre>

<p>The sentence <em>so far, so good</em> should receive the same kind of analysis.</p>

<pre><code class="language-sdparse">So far , so good
mark(far, So)
mark(good, so)
advcl(good, far)
</code></pre>

<h4 id="similar-constructions">Similar constructions</h4>
<p>A non-exhaustive list of constructions with analyses very similar to the analysis of standard comparatives.</p>

<p><em>X enough to/that…</em></p>

<pre><code class="language-sdparse">This drink is strong enough to knock out an elephant
advmod(strong, enough)
advcl(strong, knock)
mark(knock, to)
</code></pre>

<pre><code class="language-sdparse">-ROOT- For now it was enough that he had learned his lesson .
root(-ROOT-, enough)
cop(enough, was)
advcl(enough, learned)
</code></pre>

<p><em>So many… that…</em></p>

<pre><code class="language-sdparse">-ROOT- There are so many things to do that you wo n't use your room for much more than sleeping .
root(-ROOT-, things)
amod(things, many)
advmod(many, so)
acl(things, do)
acl(things, use)
mark(use, that)
</code></pre>

<p><em>Too X to…</em></p>

<pre><code class="language-sdparse">This problem was too hard to do .
advmod(hard-5, too-4)
advcl(hard-5, do-7)
mark(do-7, to-6)
</code></pre>

<p><em>Such… that…</em></p>

<pre><code class="language-sdparse">The stock would come public at such a ridiculously high price that it would be too hard for investors to make a profit
advmod(price, such)
acl(price, hard)
mark(hard, that)
</code></pre>

<h3 id="free-relatives">Free relatives</h3>

<h4 id="basic-analysis">Basic analysis</h4>
<p>In the canonical case, <em>wh</em>-clauses function as interrogative clauses or as adverbial clauses. In these cases, the head of the <em>wh</em>-clause is taken to be the verb, and the <em>wh</em>-word is assigned the label corresponding to its grammatical function in the <em>wh</em>-clause:</p>

<pre><code class="language-sdparse">I need to know who you are planning to leave with .
nmod(leave, who)
case(who, with)
ccomp(know, leave)
</code></pre>

<pre><code class="language-sdparse">When you leave , be sure to let me know .
advmod(leave, When)
advcl(sure, leave)
</code></pre>

<p>In free relative constructions, the <em>wh</em>-clause functions as an argument in the higher clause. In these cases, the <em>wh</em>-phrase is deemed the head of the construction, thereby receiving a dependency relation reflective of its function in the higher clause, and the rest of the <em>wh</em>-clause is an <code>acl:relcl</code> dependent on it.</p>

<pre><code class="language-sdparse">I 'll have whatever she 's having .
dobj(have, whatever)
acl:relcl(whatever, having)
</code></pre>

<pre><code class="language-sdparse">I love how well everyone behaved .
dobj(love, well)
advmod(well, how)
acl:relcl(well, behaved)
</code></pre>

<p>This analysis is also extended to cleft constructions.</p>

<pre><code class="language-sdparse">-ROOT- John is who we want to help .
root(-ROOT-, who)
nsubj(who, John)
acl:relcl(who, want)
cop(who, is)
</code></pre>

<pre><code class="language-sdparse">-ROOT- It 's John who we want to help .
expl(who, It)
root(-ROOT-, who)
nsubj(who, John)
acl:relcl(who, want)
cop(who, 's)
</code></pre>

<pre><code class="language-sdparse">-ROOT- What the committee hopes to learn is why all these events transpired .
nsubj(why, What)
acl:relcl(What, hopes)
cop(why, is)
acl:relcl(why, transpired)
nsubj(transpired, events)
root(-ROOT-, why)
</code></pre>

<p>The phrase <em>no matter</em> is analyzed as taking a <code>obj</code> complement in, e.g., <em>no matter the cost</em>. When it takes free relative object, that object is also analyzed according to the rules above.</p>

<pre><code class="language-sdparse">No matter what progress we make as individuals, we will never achieve real health until ...
neg(matter, No)
npmod(achieve, matter)
dobj(matter, progress)
det(progress, what)
acl:relcl(make, progress)
</code></pre>

<h4 id="cyclic-cases">Cyclic cases</h4>
<p>In some cases, the <em>wh</em>-phrase would be analyzed as the head of the <em>wh</em>-clause. For example, in the sentence <em>I love how appreciative everyone was</em>, the word <em>appreciative</em> would normally be a predicative head (since the verb <em>was</em> is a copula and would receive the <code>cop</code> relation). Since <em>appreciative</em> cannot be an <code>acl:relcl</code> dependent on itself, the auxiliary is promoted to the head of the relative clause and assigned the <code>acl:relcl</code> relation.</p>

<pre><code class="language-sdparse">I love how appreciative everyone was .
dobj(love, appreciative)
acl:relcl(appreciative, was)
advmod(how, appreciative)
</code></pre>

<pre><code class="language-sdparse">This is the key to how worthy the effort might be .
nmod(key, worthy)
case(worthy, to)
advmod(worthy, how)
acl:relcl(worthy, be)
</code></pre>


      </div>

<!-- support for embedded visualizations -->
<script type="text/javascript">
    var root = '../../'; // filled in by jekyll
    head.js(
        // External libraries
        root + 'lib/ext/jquery.min.js',
        root + 'lib/ext/jquery.svg.min.js',
        root + 'lib/ext/jquery.svgdom.min.js',
        root + 'lib/ext/jquery.timeago.js',
        root + 'lib/ext/jquery-ui.min.js',
        root + 'lib/ext/waypoints.min.js',
        root + 'lib/ext/jquery.address.min.js',

        // brat helper modules
        root + 'lib/brat/configuration.js',
        root + 'lib/brat/util.js',
        root + 'lib/brat/annotation_log.js',
        root + 'lib/ext/webfont.js',
        // brat modules
        root + 'lib/brat/dispatcher.js',
        root + 'lib/brat/url_monitor.js',
        root + 'lib/brat/visualizer.js',

        // embedding configuration
        root + 'lib/local/config.js',
        // project-specific collection data
        root + 'lib/local/collections.js',

        // NOTE: non-local libraries
        'https://spyysalo.github.io/annodoc/lib/local/annodoc.js',
        'https://spyysalo.github.io/conllu.js/conllu.js'
    );

    var webFontURLs = [
//        root + 'static/fonts/Astloch-Bold.ttf',
        root + 'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        root + 'static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var setupAccordions = function() {
	// preserve state in URL hash, following in part
	// http://www.boduch.ca/2011/05/remembering-jquery-ui-accordion.html

        // Make subaccordions first, make them active to get height, and then close later
        $(".jquery-ui-subaccordion-closed").accordion({collapsible: true, disabled:false, active:0});

	var accordionChange = function(event, ui) {
	    var context = ui.newHeader ? ui.newHeader.context : null;
	    if (context) {
		var languageCode = context.getAttribute('data-lc');
		if (languageCode !== null) {
		    window.location.hash = languageCode;
		}
	    }
	}
        // jQuery UI "accordion" element initialization
	$(".jquery-ui-accordion").accordion({
	    collapsible: true,
	    active: false,
	    change: accordionChange
	});
	if ($(".jquery-ui-accordion").length) {
	    var matches = window.location.hash.match(/^\#(.*)$/);
	    console.log(matches);
	    if (matches !== null) {
		var languageCode = matches[1];
		var tab = $('[data-lc="'+languageCode+'"]');
		// the following will only work after accordion is initialized
		var index = $('.jquery-ui-accordion div.ui-accordion-header').index(tab);
		if (index !== -1) {
		    $(".jquery-ui-accordion").accordion({ active: index });
		}
	    }
	}
        //now reclose these accordions
        $(".jquery-ui-subaccordion-closed").accordion("option","active",false);
    };

    var setupTimeago = function() {
        jQuery("time.timeago").timeago();
    };

    var setupTabs = function() {
        // standard jQuery UI "tabs" element initialization
        $(".jquery-ui-tabs").tabs({ heightStyle: "auto" });

        // use jQuery address to preserve tab state
        // (see https://github.com/UniversalDependencies/docs/issues/65,
        // http://stackoverflow.com/a/3330919)
        if ($(".jquery-ui-tabs").length > 0) {
            $.address.change(function(event){
	        $(".jquery-ui-tabs").tabs("select", window.location.hash)
	    });
	    $(".jquery-ui-tabs").bind("tabsselect", function(event, ui) { 
	        window.location.hash = ui.tab.hash;
	    });
        }
    };

    head.ready(function() {
        // set up UI tabs on page
        setupTabs();
        setupAccordions();
        setupTimeago();

        // mark current collection (filled in by Jekyll)
        Collections.listing['_current'] = 'en-overview';

	// perform all embedding and support functions
	Annodoc.activate(Config.bratCollData, Collections.listing);
    });
</script>


<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55233688-1', 'auto');
  ga('send', 'pageview');

</script>


      <div id="footer">
	  <p class="footer-text">&copy; 2014 
	    <a href="http://universaldependencies.org/introduction.html#contributors" style="color:gray">Universal Dependencies contributors</a>. 
	    Site powered by <a href="http://spyysalo.github.io/annodoc" style="color:gray">Annodoc</a> and <a href="http://brat.nlplab.org/" style="color:gray">brat</a></p>.
      </div>
    </div>
  </body>
</html>
