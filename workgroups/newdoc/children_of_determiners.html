<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Children of Determiners</title>
    <link rel="icon" href="https://universaldependencies.org/logos/logo-ud.png" type="image/png">
    <link rel="root" href=""/> <!-- for JS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="../../css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/style-vis.css"/>
    <link rel="stylesheet" type="text/css" href="../../css/hint.css"/>
    <script type="text/javascript" src="../../lib/ext/head.load.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.2.2/anchor.min.js"></script>
    <script>document.addEventListener("DOMContentLoaded", function(event) {anchors.add();});</script>
    <!-- Set up this custom Google search at https://cse.google.com/cse/business/settings?cx=001145188882102106025:dl1mehhcgbo -->
    <!-- DZ 2021-01-22: I am temporarily hiding the search field to find out whether it slows down loading of the title page.
    <script>
      (function() {
        var cx = '001145188882102106025:dl1mehhcgbo';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script> -->
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->


  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
        <table width="100%"><tr><td width="50%">
          <span class="header-text"><a href="http://universaldependencies.org/#language-">home</a></span>

          <span class="header-text"><a href="https://github.com/universaldependencies/docs/edit/pages-source/workgroups/newdoc/children_of_determiners.md" target="#">edit page</a></span>
          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
        </td><td>
          <gcse:search></gcse:search>
        </td></tr></table>
      </div>

      <hr/>

      
      <div class="v2complete">
        This page pertains to UD version 2.
      </div>
      

      <div id="content">
        <noscript>
          <div id="noscript">
            It appears that you have Javascript disabled.
            Please consider enabling Javascript for this page to see the visualizations.
          </div>
        </noscript>

        <!-- The content may include scripts and styles, hence we must load the shared libraries before the content. -->
        <script type="text/javascript">
            console.time('loading libraries');
            var root = '../../'; // filled in by jekyll
            head.js(
                // External libraries
                // DZ: Copied from embedding.html. I don't know which one is needed for what, so I'm currently keeping them all.
                root + 'lib/ext/jquery.min.js',
                root + 'lib/ext/jquery.svg.min.js',
                root + 'lib/ext/jquery.svgdom.min.js',
                root + 'lib/ext/jquery.timeago.js',
                root + 'lib/ext/jquery-ui.min.js',
                root + 'lib/ext/waypoints.min.js',
                root + 'lib/ext/jquery.address.min.js'
            );
        </script>
        <h1 id="can-determiners-have-children-in-the-tree-structure">Can Determiners Have Children in the Tree Structure?</h1>

<p>This page discusses nodes that are attached to their parents via the <a href="">det</a> relation. When we say <em>determiner</em> in this text, we are referring to the relation and not to the UPOS category <a href="">DET</a>. Of course, there is a strong correlation between the two but it is not absolute. For example, a <code class="language-plaintext highlighter-rouge">DET</code> could be promoted when its noun is elided, then its incoming relation would be something else than <code class="language-plaintext highlighter-rouge">det</code> and the rules discussed here would not apply.</p>

<p>Determiners are generally considered function words in UD. As such, they are typically leaf nodes, that is, they do not have children. However, this rule is not strict and the <a href="/u/overview/syntax.html#the-status-of-function-words">guidelines list some exceptions</a> for various function words including determiners.</p>

<p>For several years, the <a href="/contributing/release_checklist.html#validation">UD validator</a> did not enforce this rule for determiners while it was doing so for other function words. The test was finally <a href="https://github.com/UniversalDependencies/tools/commit/1e4debd">implemented in September 2024</a> under the label <code class="language-plaintext highlighter-rouge">leaf-det-clf</code>, <a href="https://github.com/UniversalDependencies/tools/commit/c5b8cf5ecff55c27affa8ff0eac737cb799883c8">later split</a> to two tests, <code class="language-plaintext highlighter-rouge">leaf-det</code> and <code class="language-plaintext highlighter-rouge">leaf-clf</code>; since this page is about determiners and not about classifiers, we are interested in <code class="language-plaintext highlighter-rouge">leaf-det</code>. Like other similar tests for function words, it allows determiners to have children if the (universal part of the) relation between the determiner and the child is in a predefined subset:</p>

<ul>
  <li><a href="">goeswith</a> – Like any other word, determiner may be incorrectly split to multiple tokens in writing, then the pieces must be connected via <code class="language-plaintext highlighter-rouge">goeswith</code>.</li>
  <li><a href="">reparandum</a> – Like any other word in spoken data, determiner may be the correct word after an incorrect fragment has been uttered, then the incorrect fragment must be attached to the determiner via <code class="language-plaintext highlighter-rouge">reparandum</code>.</li>
  <li><a href="">fixed</a> – This relation is used to connect tokens in fixed multiword expression that act as a function word. Multiword determiners are not common but they do occur e.g. in French <em>lire <b>de la</b> documentation</em> “to read documentation”.</li>
  <li><a href="">conj</a> and <a href="">cc</a> – Determiners can be coordinated (e.g. <em><b>each and every</b> member</em>).</li>
  <li><a href="">punct</a> – Punctuation should normally be attached to a content word, but it must be attached to a function word if
    <ul>
      <li>the function word is the only word enclosed in paired punctuation such as brackets;</li>
      <li>or if it is the only way how to avoid non-projectivity;</li>
      <li>or if it separates coordinate function words.</li>
    </ul>
  </li>
</ul>

<h2 id="light-adverbials">Light Adverbials</h2>

<p>The <a href="/u/overview/syntax.html#function-word-modifiers">guidelines also acknowledge</a> that “certain types of function words can take a restricted class of modifiers, mainly light adverbials (including negation).” They explicitly give one example that involves a determiner: <em><b>not every</b> linguist</em>. Ideally the validator should have the list of permitted modifiers (light adverbials) for each language; as such lists are currently not available, the validator has additional deprel-level exceptions, although they potentially open the door for other adverbials that should not be allowed:</p>

<ul>
  <li><a href="">advmod</a> – It is used to attach negative particles such as <em>not</em> in <em>not every linguist</em>.</li>
  <li><a href="">obl</a> – A modifier could be semantically adverbial but syntactically expressed as a nominal rather than an adverb. In that case, it must be attached as <code class="language-plaintext highlighter-rouge">obl</code> and not as <code class="language-plaintext highlighter-rouge">advmod</code>. This exception was copied from other function words although it is unclear yet whether it is needed with determiners.</li>
</ul>

<h2 id="problematic-constructions">Problematic Constructions</h2>

<p>After the validation test was introduced, it identified problems in over 200 UD treebanks. For some of them, their maintainers suggested that the guidelines should be extended to allow additional specific constructions. The full discussion is in <a href="https://github.com/UniversalDependencies/docs/issues/1059">Issue #1059</a>; as it is extremely long and messy, we try to summarize the interesting points here.</p>

<h3 id="compound-determiners">Compound Determiners</h3>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2413484624">Laura Rituma</a>)</p>

<p>In Latvian, we have several expressions considered as compound pronouns in Latvian traditional grammar which consist of one particle and one pronoun. For example, <em>kaut kāds</em> where <em>kaut</em> is a particle and <em>kāds</em> is a pronoun (this expression roughly means ‘some kind of’). Currently, we annotate the particle as <code class="language-plaintext highlighter-rouge">discourse</code> which is dependent of pronoun, and pronoun occasionally becomes <code class="language-plaintext highlighter-rouge">det</code> if the expression describes a noun. This leads to validation error.</p>

<p>The particles in these expressions usually are <em>kaut</em>, <em>diez</em>, <em>diezin</em>, <em>nez</em>, <em>nezin</em>, and they all have very fuzzy, hard to pin down semantics so we feel uncomfortable annotating them as adverbs.</p>

<p>We would like to annotate these expressions as <a href="">compound</a> (instead of <a href="">fixed</a>) because the pronoun is the second element in the phrase and we feel that it is the head of the phrase  because the pronoun inflects together with a noun and bears the most of semantic meaning of the expression.</p>

<p>It seems that the test should not report cases where a determiner has a <code class="language-plaintext highlighter-rouge">compound</code> child. After all, compound is just a signal that two nodes together act almost like one word, but in contrast to fixed, one of them can be considered the head.</p>

<h3 id="classifiers-under-determiners">Classifiers under Determiners</h3>

<p>According to <a href="/u/dep/clf.html">the guidelines on classifiers</a>, in the demonstrative + classifier construction in Chinese, the classifier forms a constituent with the demonstrative and must be attached as its child. Therefore, <a href="">clf</a> must be added as an exception to the validation rule. This is also an exception to the general rule that function words are not chained in UD trees.</p>

<h3 id="determiners-under-determiners">Determiners under Determiners</h3>

<p>As the guidelines <a href="/u/overview/syntax.html#the-status-of-function-words">say</a>, multiple determiners are always attached directly to the head noun:</p>

<div id="s3c" class="sd-parse">
All/DET these/DET three/NUM books/NOUN .
det(books, All)
det(books, these)
nummod(books, three)
</div>

<p>However, some languages have constructions that look quite different from the English example above.</p>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2400694043">Daniel Swanson</a>)</p>

<p>In Hebrew (both Ancient and Modern), demonstrative pronouns have their own determiners, as in “the men the these” = “these men”. It is also parallel to how adjectival modification works in Modern Hebrew. Maybe determiners under demonstratives could be allowed in some languages but not the others?</p>

<pre><code class="language-conllu"># x- so the RTL text doesn't make this unreadable
1	ה	x-ה	DET	art	PronType=Art	2	det	_	Gloss=the|Ref=GEN_19.8
2	אֲנָשִׁ֤ים	x-אישׁ	NOUN	subs	Gender=Masc|Number=Plur	0	root	_	Gloss=man|Ref=GEN_19.8
3-4	הָאֵל֙	_	_	_	_	_	_	_	_
3	הָ	x-ה	DET	art	PronType=Art	4	det	_	Gloss=the|Ref=GEN_19.8
4	אֵל֙	x-אל	PRON	prde	Number=Plur|PronType=Dem	2	det	_	Gloss=these|Ref=GEN_19.8

</code></pre>

<h3 id="case-under-determiners">Case under Determiners</h3>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2441260051">Petr Kocharov</a>)</p>

<p>Somewhat similar to demonstratives with articles in Hebrew, Classical Armenian has repeated case markers on noun and its demonstrative.
Prepositions and articles can be repeated with modifiers, including demonstrative pronominal adjectives, within NP, cf.</p>

<ul>
  <li><em>i kʻarancʻ y ayscʻanē</em></li>
  <li>from stone.ABL.PL from this.ABL.PL</li>
  <li>“from these (from) stones”</li>
</ul>

<pre><code class="language-sdparse">i kʻarancʻ y ayscʻanē
det(kʻarancʻ, ayscʻanē)
case(kʻarancʻ, i)
case(ayscʻanē, y)
</code></pre>

<p>Attaching the case marker of the demonstrative to the head noun, which has its own copy of the case marker, would be odd.</p>

<p>Unfortunately, if <code class="language-plaintext highlighter-rouge">case</code> under <code class="language-plaintext highlighter-rouge">det</code> is allowed in all languages and not just under Classical Armenian demonstratives, it will open the door for cases that are clear errors. For example, the following is in the current Chinese data (brought up by <a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2435696875">Koichi Yasuoka</a>).</p>

<pre><code class="language-conllu"># text = 她的這本書
1	她	她	PRON	PRP	Person=3	5	det	_	SpaceAfter=No
2	的	的	PART	DEC	Case=Gen	1	case	_	SpaceAfter=No
3	這	這	DET	DT	_	5	det	_	SpaceAfter=No
4	本	本	NOUN	NNB	_	3	clf	_	SpaceAfter=No
5	書	書	NOUN	NN	_	0	root	_	SpaceAfter=No

</code></pre>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2453383938">DZ</a>: 她的 <em>tā de</em> “of her” is a prototypical example of <code class="language-plaintext highlighter-rouge">nmod</code>. So changing the current <code class="language-plaintext highlighter-rouge">det(書, 她)</code> to <code class="language-plaintext highlighter-rouge">nmod(書, 她)</code> will solve it. (On the other hand, the classifier under the second determiner in this example is correct <a href="/u/dep/clf.html">according to the guidelines</a>.)</p>

<h3 id="parentheticals">Parentheticals</h3>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2438448236">Laura Rituma</a> added a Latvian example where <a href="">parataxis</a> may be needed under a determiner.</p>

<p><em>tādā godīgā iestādē ieperinājušies daži (tikai daži!) zagļi</em> “a <strong>few (only a few!) thieves</strong> have nested in such an honest institution”</p>

<pre><code class="language-sdparse">tādā godīgā iestādē ieperinājušies daži ( tikai daži ! ) zagļi
det(zagļi, daži-5)
parataxis(daži-5, daži-8)
</code></pre>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2452635054">Dan Zeman</a> thinks it may warrant a clarification/amendment of the guidelines, allowing parenthetical parataxis of determiners similar to coordination. But <a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2440023939">Joakim Nivre</a> thinks that even here we see two determiners that should be attached as siblings to the head noun.</p>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2407036491">Sylvain Kahane</a> also had an example of <a href="">parataxis</a> but that one turned out to be unproblematic (see below) because the parent node, although tagged <a href="">DET</a>, is not annotated syntactically as a <a href="">det</a> but <a href="">reparandum</a>.</p>

<h3 id="reduplication-flat">Reduplication (flat)</h3>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2419904450">Flavio Cecchini</a>)</p>

<ol>
  <li>The already mentioned reduplication, which is treated through <code class="language-plaintext highlighter-rouge">flat:redup</code> in Latin treebanks. One example is <em>quot quot</em> from <em>quot</em>: while the latter means ‘as many as’, the reduplication has a distributive sense as in ‘for each possible one…’ (this expression is sometimes even univerbated). I think to annotate them separately, each depending on the head, is not the right way to deal with them: here we do not have two or more different terms, but really the same one “clonating” itself. On the other hand, <code class="language-plaintext highlighter-rouge">flat</code> is really the closest relation we have to <code class="language-plaintext highlighter-rouge">fixed</code>, which would cause no problem, but is not a correct choice (well, in my opinion it is never the correct choice)
    <ul>
      <li><strong>Problem:</strong> horizontal relation</li>
    </ul>
  </li>
</ol>

<p>Can we deactivate the validation rule if the child of <code class="language-plaintext highlighter-rouge">det</code> is a <code class="language-plaintext highlighter-rouge">flat</code> relation?</p>

<p>Dan: Why is <a href="">fixed</a> not a good choice?
<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2455257882">Flavio</a>: Because it is productive and not idiosyncratic.</p>

<h2 id="problems-with-referentiality">Problems with Referentiality</h2>

<p>A large part of the discussion slipped to the related problem of deciding between <a href="">det</a> and <a href="">nmod</a> (or their <code class="language-plaintext highlighter-rouge">:poss</code> subtypes). Joakim believes that the guidelines imply, despite not saying it explicitly, that if the word is referential, it should be attached as <code class="language-plaintext highlighter-rouge">nmod</code> rather than <code class="language-plaintext highlighter-rouge">det</code>. It would be the case of all words referring to possessors, regardless whether they are tagged as <a href="">PRON</a>, <a href="">DET</a>, <a href="">NOUN</a> or <a href="">ADJ</a>. But other people (including Dan) do not understand the guidelines this way.</p>

<p>The referentiality criterion would nevertheless have the advantage that some problems with the <code class="language-plaintext highlighter-rouge">leaf-det</code> test would disappear. The problems belonging to this class are listed in this section. The occasional need to attach an apposition or a relative clause to a determiner are caused by the fact that the determiner is referential (because it is a possessive). If the referentiality criterion gains support and is approved via an amendment of the guidelines, many treebanks will require large changes. But in the current context, the <code class="language-plaintext highlighter-rouge">leaf-det</code> test should be probably relaxed for the special cases below.</p>

<h3 id="relative-clause-modifying-a-referent-hidden-in-a-possessive-determiner">Relative Clause Modifying a Referent Hidden in a Possessive Determiner</h3>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2419904450">Flavio Cecchini</a>)</p>

<p>Latin: The phrase <em>nostra qui remansissemus caede</em> ‘the murder of us who are left (behind)’, but more literally ‘our who are left murder’, since <em>nostra</em> is the inflected possessive determiner for the 1st person plural. What happens here is that the possessive adds a nominal person, as it were, and this person is another referent beyond the noun <em>caede</em> ‘murder’ in this phrase; as such, the relative can target it (or at least, Cicero pleases himself in doing so). We could not really justify an analysis where we shift the relative under the head noun, since the murder is not one of its arguments.
    * <strong>Problem:</strong> the relative clause dependent of the determiner cannot be traced back to the referent of its head</p>

<pre><code class="language-sdparse">nostra qui remansissemus caede
det(caede, nostra)
acl:relcl(nostra, remansissemus)
nsubj(remansissemus, qui)
</code></pre>

<p>Can we deactivate this validation rule if the head element has the feature <code class="language-plaintext highlighter-rouge">Person</code>, at least for <code class="language-plaintext highlighter-rouge">acl:relcl</code>?</p>

<h3 id="apposition">Apposition</h3>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2426979819">Jack Rueter</a>)</p>

<p>A possessive determiner may have an appositional child: <em>His, Fred’s, friends come from all over.</em> This is in fact not a problem in English where personal possessives are pronouns rather than determiners (and they are attached as [nmod:poss]) but in other languages it is a problem. For example in Erzya:</p>

<p><em>Конат-конат сонзэ (Степан Иваныч) ладсо сырелгадсть…</em> / <em>Konat-konat sonzè (Stepan Ivanyč) ladso syrelgadstʹ…</em> “such-such.PL his/her (Stepan Ivanych) way.INE become.older.3PL”</p>

<pre><code class="language-sdparse">Конат-конат сонзэ ( Степан Иваныч ) ладсо сырелгадсть
obl(сырелгадсть, ладсо)
det(ладсо, сонзэ)
appos(сонзэ, Степан)
</code></pre>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2437494587">Koichi Yasuoka</a> provided a Chinese example of apposition.</p>

<h3 id="nominal-possessive-modifier-of-a-determiner">Nominal Possessive Modifier of a Determiner</h3>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2424872098">Janine Siewert</a>)</p>

<p>Low Saxon: It is explained in Section 5.1 here: <a href="https://aclanthology.org/2024.lrec-main.1388.pdf">https://aclanthology.org/2024.lrec-main.1388.pdf</a>
The gloss and translation of the sentence can be found in Section 4.3.</p>

<p><em>Ik sto in der Gemoene iarem Denste</em> “I stand in the service of the parish.” (lit. “I stand in the.DAT parish.DAT her.DAT service.DAT”)</p>

<pre><code class="language-sdparse">Ik sto in der Gemoene iarem Denste
nsubj(sto, Ik)
obl(sto, Denste)
case(Denste, in)
det(Denste, iarem)
nmod:poss(iarem, Gemoene)
det(Gemoene, der)
</code></pre>

<p>Attaching the possessor in dative case to the possessee instead of the determiner does not represent the way this construction works because 1) the dative possessor cannot be attached to the possessee without the determiner and 2) the possessee can be dropped while the determiner cannot. E.g., in the example in my paper, “In der Gemoene iarem.” (literally “in the parish hers”) is a valid answer to a specification question in whose service the person stands. (A note to German speakers: Masculine and neuter nouns show that this is indeed a dative, not a genitive.)
The alternative to change the determiners’ tags to PRON in Low Saxon would go against UD’s own definition of determiners.</p>

<p>DZ: Is <em>iarem</em> coreferential with <em>der Gemoene</em>? Attaching <em>Gemoene</em> as <a href="">nmod:poss</a> of <em>iarem</em> is odd because it suggests that <em>Gemoene</em> is the possessor of her, not of the service.
The cited paper also says: “Among the UD languages, we have found comparable constructions in Afrikaans, Frisian Dutch, and Norwegian, but the annotation has been inconsistent across these languages.” The annotation indeed should be made consistent, but maybe one of those languages uses an analysis that works well under the UD guidelines?</p>

<p>Subsequent comment by <a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2435696875">Flavio</a>
and <a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2452688911">Dan</a>.</p>

<h2 id="quantifiers">Quantifiers</h2>

<p>Pronominal quantifiers, as opposed to definite cardinal numerals, are treated as determiners following the UD guidelines (see <a href="">DET</a>, <a href="">NUM</a>; the distinction is currently not mentioned directly in the guidelines for <a href="">det</a> and <a href="">nummod</a>, but these relations are normally used to connect the quantifier with the counted noun, so the UPOS distinction projects to the relation distinction straightforwardly). Nevertheless, pronominal quantifiers can be modified to further specify the quantity or to compare it with some other quantity, as in these Czech examples:</p>

<pre><code class="language-sdparse">třikrát tolik dětí než X \n three.times so.many children than X
advmod(tolik, třikrát)
advmod(so.many, three.times)
det:numgov(dětí, tolik)
det:numgov(children, so.many)
nmod(tolik, X-5)
nmod(so.many, X-11)
case(X-5, než)
case(X-11, than)
</code></pre>

<pre><code class="language-sdparse">víc rozdílů než společných prvků \n more differences than common elements
det:numgov(rozdílů, víc)
det:numgov(differences, more)
nmod(víc, prvků)
nmod(more, elements)
case(prvků, než)
case(elements, than)
amod(prvků, společných)
amod(elements, common)
</code></pre>

<pre><code class="language-sdparse">o 600000 méně lidí \n by 600,000 fewer people
case(600000, o)
case(600,000, by)
nmod(méně, 600000)
nmod(fewer, 600,000)
det:numgov(lidí, méně)
det:numgov(people, fewer)
</code></pre>

<p>The validation exception that could capture these cases looks at the features of the determiner. If there is <a href="">NumType</a> or <a href="">Degree</a>, <a href="">nmod</a> children are allowed.
Alternatively, we could require that the relation between the quantifier and its modifier is <a href="">obl</a> because the quantifier is not really a nominal. Then we would not need a new exception because <a href="">obl</a> is already allowed for other reasons.</p>

<h2 id="problematic-constructions-that-do-not-need-an-exception">Problematic Constructions that Do Not Need an Exception</h2>

<h3 id="adverbial-clauses">Adverbial Clauses</h3>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issue-2574038827">Nathan Schneider</a>)</p>

<p>In English, <em>such</em> is a demonstrative determiner and it may license an <a href="">advcl</a>, as in <a href="https://universal.grew.fr/?custom=66f9b53a31605">these results</a>. The guidelines on <a href="/u/overview/specific-syntax.html#sufficiency-and-excess">sufficiency and excess</a> for <em>so</em> and similar say the <code class="language-plaintext highlighter-rouge">advcl</code> should attach to the adjective or adverb, not the noun in a case like <em>sufficient flour</em>. Then in <em>such a high price <strong>that nobody could afford it</strong></em>, we may want to attach the <code class="language-plaintext highlighter-rouge">advcl</code> dependent to <em>such</em>.</p>

<p>Ideally, the validator should allow <code class="language-plaintext highlighter-rouge">advcl</code> specifically in English and only if the head is <em>such</em>. If there are similar constructions in other languages, they should be also registered specifically for those languages and not en bloc for the whole UD.</p>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2452025700">Joakim Nivre</a>) You have the choice of treating <em>such</em> as <a href="">amod</a>, in which case it is unproblematic to attach an <code class="language-plaintext highlighter-rouge">advcl</code> to it. If you treat <em>such</em> as <code class="language-plaintext highlighter-rouge">det</code>, you instead have to attach the clause to its head (that is, to the whole phrase). This is similar to how we treat some comparative constructions. (Dan Zeman) If <em>such</em> is <code class="language-plaintext highlighter-rouge">amod</code>, then it should probably also have the <a href="">ADJ</a> UPOS tag. Although it looks like the current validator will not complain if it sees a <a href="">DET</a> attached as <code class="language-plaintext highlighter-rouge">amod</code> (it definitely does complain if it sees an <code class="language-plaintext highlighter-rouge">ADJ</code> attached as <code class="language-plaintext highlighter-rouge">det</code>).</p>

<h3 id="vor-allem">Vor allem</h3>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2405829551">Leonie Weissweiler</a>)</p>

<p>German <em>vor allem</em> and <em>unter anderem</em> – resolved in a separate issue?</p>

<h3 id="parentheticals-in-spoken-data">Parentheticals in Spoken Data</h3>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2407036491">Sylvain Kahane</a>)</p>

<ul>
  <li><a href="">parataxis</a> for cases such as “a, I don’t how to call that, a kiosk, …”: here we have a <code class="language-plaintext highlighter-rouge">reparandum</code> link between the two “a”s and we would like to attach the parenthesis to the first “a”. More exactly we use <code class="language-plaintext highlighter-rouge">parataxis:parenth</code> in our spoken French treebanks.</li>
</ul>

<p>DZ: Is attaching the parenthetical to the first determiner better than attaching it to the noun <em>(kiosk)</em>? Apart from the non-projectivity – I realize that there is similarity between this and the <code class="language-plaintext highlighter-rouge">discourse</code> point above.</p>

<p>SK: Yes it is similar to the discourse marker case and I propose the same solution. Moreover, in this case, “<em>a, I don’t know how to call that</em>” forms a kind of semantic and prosodic unit, which is not the case of “<em>I don’t know how to call that, a kiosk</em>”. I really want to attach the parenthesis to the first determiner.</p>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2453479477">DZ</a>: Now I realize that here, too, we shouldn’t have a problem because the first determiner should be attached to the kiosk as a <code class="language-plaintext highlighter-rouge">reparandum</code>:</p>

<pre><code class="language-sdparse">a , I do n't know how to call that , a kiosk
reparandum(kiosk, a-1)
det(kiosk, a-12)
parataxis(a-1, know)
</code></pre>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2453519235">SK</a>: My mistake! Your validator doesn’t forbid <a href="">discourse</a>, <a href="">parataxis</a>, or <a href="">orphan</a> depending on a <a href="">DET</a> which is <a href="">reparandum</a>. And it is good like this.</p>

<p>(DZ: Note however that the question of parentheticals depending on determiners is broader and one of the examples mentioned earlier shows that we may want to allow them anyway.)</p>

<h3 id="fillers-in-spoken-data">Fillers in Spoken Data</h3>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2407036491">Sylvain Kahane</a>)</p>

<p>For spoken data, we need the following to be added to the validator:</p>

<ul>
  <li><a href="">discourse</a>, which is very common between two determiners in false starts: “a, uh, a gap”, “my, uh, our friend”</li>
</ul>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2452618494">Dan Zeman</a>: Does the interjection have to be attached to one of the determiners? The <a href="https://universaldependencies.org/u/dep/discourse.html">discourse page</a> says that they are attached to the most relevant nearby unit, which is not very helpful, but I thought they would be attached at clause level (yes, it would be non-projective in this case).</p>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2452929579">Sylvain</a>: Yes, I really want to analyse the discourse marker as the marker of the reparandum. If you want to keep a constrained rule, we can allow <code class="language-plaintext highlighter-rouge">discourse</code> only when the determiner is a <code class="language-plaintext highlighter-rouge">reparandum</code>. Clearly the determiners around the discourse marker are “the most relevant nearby units”.</p>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2453469086">Dan</a>: I am not sure I understand. If the <code class="language-plaintext highlighter-rouge">discourse</code> child is attached to a parent that itself is a <code class="language-plaintext highlighter-rouge">reparandum</code>, we do not have a problem at all (regardless whether the UPOS tag of the parent is <code class="language-plaintext highlighter-rouge">DET</code>). We would have a problem only if the determiner parent were attached as <code class="language-plaintext highlighter-rouge">det</code>.</p>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2453519235">SK</a>: My mistake! Your validator doesn’t forbid <a href="">discourse</a>, <a href="">parataxis</a>, or <a href="">orphan</a> depending on a <a href="">DET</a> which is <a href="">reparandum</a>. And it is good like this.</p>

<h3 id="false-starts-with-the-dep-relation">False Starts with the dep Relation</h3>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2407036491">Sylvain Kahane</a>)</p>

<p><a href="">dep</a> for false starts such as “the last, the last day”: here “the last” forms a phrase the head of which is missing and we decided to have dep(the, last). I am not against another solution, as long as “the last” is still a phrase.</p>

<p>DZ: I don’t have a strong position for the first two points above but here I do. I really don’t think that <a href="">dep</a> deserves any dedicated rule anywhere in UD, it is a last resort in datasets but its usage should be minimized. I don’t understand what makes this case so different from cases where we use <a href="">reparandum</a>? I always thought we would use it for false starts as well; the only thing that makes them different from true repairs is that the reparandum is identical with the repair, but I still see a strong analogy, when it is uttered for the second time, the first attempt is canceled in a sense. Moreover, here I would not attach the reparandum to the article but to the head of <em>the last day</em>, which would make it unproblematic w.r.t. the rule that determiners do not have children.</p>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2452929579">SK</a>: The problem is not with <em>the last day</em>, the repandum starts from <em>day</em>. The problem is the analysis of <em>the last</em>, the false start itself. I don’t like the idea to analyze it as a correct phrase, for instance with det(last,the). I want to keep the information that it is a false start and not a complete phrase. It is why we chose dep(the, last), but I am ok to use another relation.
I give you another example of false start, which I would like to analyze similarly:</p>

<blockquote>
  <p><em>les gens qu’on, qu’on voit pour la première fois</em>
‘people who we, who we see for the first time’ (In French the relative pronoun cannot be omitted)</p>
</blockquote>

<p>Here we have two pronouns <em>qu’</em> and <em>on</em>, which form the false start together, and I don’t see what could be the link between them apart from <code class="language-plaintext highlighter-rouge">dep</code>. Maybe a dedicated relation such as <code class="language-plaintext highlighter-rouge">flat:disfluency</code>?</p>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2453496870">DZ</a>: It is not a complete phrase but I would still find it natural to apply the UD rules for ellipsis (=&gt; for incomplete phrases), promote <em>last</em> and draw the relation <code class="language-plaintext highlighter-rouge">det(last, the)</code>. I think the information that it is a false start is already encoded in the incoming <code class="language-plaintext highlighter-rouge">reparandum</code> relation (which could be further subtyped to <code class="language-plaintext highlighter-rouge">reparandum:falsestart</code> if it is needed).</p>

<pre><code class="language-sdparse">the last , the last day
det(last-2, the-1)
punct(last-2, ,)
reparandum(day, last-2)
det(day, the-4)
amod(day, last-5)
</code></pre>

<p>DZ: As for the French example, I understand your concern, although I would claim that the UD ellipsis policy provides a possible solution here, too: <code class="language-plaintext highlighter-rouge">orphan(on, qu')</code>.</p>

<pre><code class="language-sdparse">les gens qu' on , qu' on voit pour la première fois
orphan(on-4, qu'-3)
punct(on-4, ,)
reparandum(voit, on-4)
obj(voit, qu'-6)
nsubj(voit, on-7)
</code></pre>

<p>SK: Maybe a dedicated relation such as <code class="language-plaintext highlighter-rouge">flat:disfluency</code>?</p>

<p>DZ: Right now I think I prefer the ellipsis solution sketched above, but <code class="language-plaintext highlighter-rouge">flat</code> would probably still be better than <code class="language-plaintext highlighter-rouge">dep</code>. None of the two solutions should trigger the <code class="language-plaintext highlighter-rouge">leaf-det</code> validation test.</p>

<p><a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2453519235">SK</a>: My mistake! Your validator doesn’t forbid <a href="">discourse</a>, <a href="">parataxis</a>, or <a href="">orphan</a> depending on a <a href="">DET</a> which is <a href="">reparandum</a>. And it is good like this.</p>

<h3 id="semantic-coordination-syntactic-flat">Semantic Coordination, Syntactic Flat?</h3>

<p>(<a href="https://github.com/UniversalDependencies/docs/issues/1059#issuecomment-2433801928">Koichi Yasuoka</a>)</p>

<p>In Classical Chinese 彼此兵 “those and these soldiers” is invalidated by this rule. The English translation has coordinate determiners but there is no coordinating conjunction in the original and 彼此 “that this” are connected via <a href="">flat</a>. Then “that” is attached as <a href="">det</a> to “soldier”.</p>

<p>Flavio (and Dan): Here the simplest solution would be to use <a href="">conj</a> instead of <a href="">flat</a>. (But in the end, <code class="language-plaintext highlighter-rouge">flat</code> may be allowed because of other things, namely reduplication of function words.</p>

      </div>

<!-- support for embedded visualizations -->
<script type="text/javascript">
    var root = '../../'; // filled in by jekyll
    head.js(
        // We assume that external libraries such as jquery.min.js have already been loaded outside!
        // (See _layouts/base.html.)

        // brat helper modules
        root + 'lib/brat/configuration.js',
        root + 'lib/brat/util.js',
        root + 'lib/brat/annotation_log.js',
        root + 'lib/ext/webfont.js',
        // brat modules
        root + 'lib/brat/dispatcher.js',
        root + 'lib/brat/url_monitor.js',
        root + 'lib/brat/visualizer.js',

        // embedding configuration
        root + 'lib/local/config.js',
        // project-specific collection data
        root + 'lib/local/collections.js',

        // Annodoc
        root + 'lib/annodoc/annodoc.js',

        // NOTE: non-local libraries
        'https://spyysalo.github.io/conllu.js/conllu.js'
    );

    var webFontURLs = [
//        root + 'static/fonts/Astloch-Bold.ttf',
        root + 'static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        root + 'static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var setupTimeago = function() {
        jQuery("time.timeago").timeago();
    };

    head.ready(function() {
        setupTimeago();

        // mark current collection (filled in by Jekyll)
        Collections.listing['_current'] = '';

	// perform all embedding and support functions
	Annodoc.activate(Config.bratCollData, Collections.listing);
    });
</script>


<!-- google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55233688-1', 'auto');
  ga('send', 'pageview');

</script>


      <div id="footer">
          <p class="footer-text">&copy; 2014–2024
            <a href="http://universaldependencies.org/introduction.html#contributors" style="color:gray">Universal Dependencies contributors</a>.
            Site powered by <a href="http://spyysalo.github.io/annodoc" style="color:gray">Annodoc</a> and <a href="http://brat.nlplab.org/" style="color:gray">brat</a></p>.
      </div>
    </div>
  </body>
</html>
